{{
  "language": "Solidity",
  "sources": {
    "contracts/token/lite.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract ERC20 {\n    string public name = \"LITE\";\n    string public symbol = \"LITE\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 0;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public owner;\n    mapping(address => bool) public whitelist;\n    mapping(address => bool) public isPair;\n\n    uint256 public taxFee = 50; // 50/1000 5%\n    address public fundsAddress;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed holder,\n        address indexed spender,\n        uint256 value\n    );\n\n    constructor(address dao_) {\n        owner = msg.sender;\n        _mint(dao_, 50000 ether);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n    function setFundsAddress(address newAddr) external onlyOwner {\n        fundsAddress = newAddr;\n    }\n\n    function setTaxFee(uint256 newTaxFee) external onlyOwner {\n        taxFee = newTaxFee;\n    }\n\n    function setPair(address newAddr, bool _value) external onlyOwner {\n        isPair[newAddr] = _value;\n    }\n\n    function setWhitelist(\n        address[] memory new_addr,\n        bool _value\n    ) external onlyOwner {\n        for (uint256 i = 0; i < new_addr.length; i++) {\n            whitelist[new_addr[i]] = _value;\n        }\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external virtual returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) external virtual returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = allowance[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external virtual returns (bool) {\n        uint256 currentAllowance = allowance[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = balanceOf[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            balanceOf[sender] = senderBalance - amount;\n        }\n        balanceOf[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        totalSupply += amount;\n        balanceOf[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[holder][spender] = amount;\n        emit Approval(holder, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (whitelist[from] || taxFee == 0) {\n            return;\n        }\n\n        if (isPair[to]) {\n            uint256 fee = (amount * taxFee) / 1000;\n            balanceOf[to] -= fee;\n            balanceOf[fundsAddress] += fee;\n            emit Transfer(to, fundsAddress, fee);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}