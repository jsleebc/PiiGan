{"BasicToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport  \"./Pauseable.sol\";\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\nabstract contract BEP20Basic {\n    uint public totalSupply;\n     function balanceOf(address who) public virtual view returns (uint256);\n     function transfer(address to, uint256 value) public virtual returns(bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\nabstract contract BasicToken is BEP20Basic, Pauseable {\n    \n    using SafeMath for uint256;\n    \n    mapping(address =\u003e uint256) internal Frozen;\n    \n    mapping(address =\u003e uint256) internal _balances;\n    \n    function  transfer(address to, uint256 value) public override  stoppable validRecipient(to) returns(bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    \n    function _transfer(address from, address to, uint256 value) internal {\n        require(from != address(0));\n        require(value \u003e 0);\n        require(_balances[from].sub(Frozen[from]) \u003e= value);\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n   function balanceOf(address _owner)  public override view returns(uint256) {\n      return _balances[_owner];\n    }\n\n    function availableBalance(address _owner) public view returns(uint256) {\n        return _balances[_owner].sub(Frozen[_owner]);\n    }\n\n    function frozenOf(address _owner) public view returns(uint256) {\n        return Frozen[_owner];\n    }\n \n    modifier validRecipient(address _recipient) {\n        require(_recipient != address(0) \u0026\u0026 _recipient != address(this));\n    _;\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\n\nabstract contract Ownable {\n    address private _owner;\n    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipRenounced(address indexed previousOwner);\n    \n    constructor()  {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == _owner);\n        _;\n    }\n    \n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        emit OwnershipTransferred(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(_owner);\n        _owner = address(0);\n    }\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n}"},"Pauseable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./Ownable.sol\";\n\n\nabstract contract Pauseable is Ownable {\n\n    event Stopped(address _owner);\n\n    event Started(address _owner);\n\n    bool private stopped;\n    \n    constructor()  {\n        stopped = false;\n    }\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n\n    function paused() public view returns (bool) {\n        return stopped;\n    }\n\n    function halt() public onlyOwner {\n        stopped = true;\n        emit Stopped(msg.sender);\n    }\n\n    function start() public onlyOwner {\n        stopped = false;\n        emit Started(msg.sender);\n    }\n}"},"SmartToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./StandardToken.sol\";\n\n\nabstract contract IBEP677 is IBEP20 {\n    function transferAndCall(address receiver, uint value, bytes memory data) public virtual returns (bool success);\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\nabstract contract BEP677Receiver {\n    function onTokenTransfer(address _sender, uint _value, bytes memory _data) public virtual;\n}\n\nabstract contract SmartToken is IBEP677, StandardToken {\n    \n    function transferAndCall(address _to, uint256 _value, bytes memory _data) public override validRecipient(_to) returns(bool success) {\n        _transfer(msg.sender, _to, _value);\n        emit Transfer(msg.sender, _to, _value, _data);\n        if (isContract(_to)) {\n            contractFallback(_to, _value, _data);\n        }\n        return true;\n    }\n\n    function contractFallback(address _to, uint _value, bytes memory _data) private {\n        BEP677Receiver receiver = BEP677Receiver(_to);\n        receiver.onTokenTransfer(msg.sender, _value, _data);\n    }\n\n    function isContract(address _addr) private view returns (bool hasCode) {\n    uint length;\n    assembly { length := extcodesize(_addr) }\n    return length \u003e 0;\n    }\n    \n}"},"StandardToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./BasicToken.sol\";\n\n\nabstract contract IBEP20 is BEP20Basic {\n    function allowance(address owner, address spender) public virtual view returns (uint256);\n    function approve(address spender, uint256 value) public virtual returns (bool);\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\nabstract contract StandardToken is IBEP20, BasicToken {\n    using SafeMath for uint256;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowed;\n\n    function approve(address spender, uint256 value) public override stoppable validRecipient(spender) returns(bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n    \n    function _approve(address _owner, address spender, uint256 value) private {\n        _allowed[_owner][spender] = value;\n        emit Approval(_owner, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public override stoppable validRecipient(to) returns(bool) {\n        require(_allowed[from][msg.sender] \u003e= value);\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256) {\n        return _allowed[_owner][_spender];\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public stoppable validRecipient(spender) returns(bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n    \n    function decreaseAllowance(address spender, uint256 subtractValue) public stoppable validRecipient(spender) returns(bool) {\n        uint256 oldValue = _allowed[msg.sender][spender];\n        if(subtractValue \u003e oldValue) {\n            _approve(msg.sender, spender, 0);\n        }\n        else {\n            _approve(msg.sender, spender, oldValue.sub(subtractValue));\n        }\n        return true;\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner stoppable validRecipient(account) returns(bool) {\n        totalSupply = totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n        return true;\n    }\n\n    function burn(uint256 amount) public stoppable onlyOwner returns(bool) {\n        require(amount \u003e 0 \u0026\u0026 _balances[msg.sender] \u003e= amount);\n        totalSupply = totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        emit Transfer(msg.sender, address(0), amount);\n        return true;\n    }\n}"},"X.AI.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./SmartToken.sol\";\n\ncontract XAI is SmartToken {\n    using SafeMath for uint256;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    \n    constructor()  {\n        _name = \"X.AI\";\n        _symbol = \"XAI\";\n        _decimals = 9;\n        mint(msg.sender, 100000000000000000e9);\n    }\n\n    function name() public view returns(string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    \n    event Freeze(address indexed from, address indexed to, uint256 value);\n    event Melt(address indexed from ,address indexed to, uint256 value);\n\n    function freeze(address to, uint256 value) public onlyOwner stoppable returns(bool) {\n        _freeze(msg.sender, to, value);\n        return true;\n    }\n\n    function _freeze(address _from, address to, uint256 value) private {\n        Frozen[to] = Frozen[to].add(value);\n        _transfer(_from, to, value);\n        emit Freeze(_from ,to, value);\n    }\n    \n    function melt(address to, uint256 value) public  onlyOwner stoppable returns(bool) {\n        _melt(msg.sender, to, value);\n        return true;\n    }\n    \n    function _melt(address _onBehalfOf, address to, uint256 value) private {\n        require(Frozen[to] \u003e= value);\n        Frozen[to] = Frozen[to].sub(value);\n        emit Melt(_onBehalfOf, to, value);\n    }\n    \n    function transferAnyBEP20(address _tokenAddress, address _to, uint256 _amount) public onlyOwner {\n        IBEP20(_tokenAddress).transfer(_to, _amount);\n    }\n\n    function withdrawBNB() public onlyOwner returns(bool) {\n        payable(msg.sender).transfer(address(this).balance);\n        return true;\n    }\n}"}}