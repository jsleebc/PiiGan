{{
  "language": "Solidity",
  "sources": {
    "contracts/9419V3.sol": {
      "content": "/**\n *\n *  9419 DAO\n *  SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./DateTimeLibrary.sol\";\nimport \"./Pancake.sol\";\n\n// interface\ninterface I9419Marketing {\n    function autoAddLp() external; // auto add lp\n}\n\ninterface I9419Repurchase{\n    function autoSwapAndAddToMarketing() external; // auto repurchase\n}\n\ninterface I6827Marketing{\n    function bonusTokenTo9419(address _to, uint256 _usdt) external; // auto bonus 6827\n    function isBonus6827() external view returns (bool);\n}\n\ncontract TokenTracker{\n    constructor (address token, uint256 amount) {\n        IERC20(token).approve(msg.sender, amount);\n    }\n}\n\ncontract Coin9419V3 is IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n \n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _isExcludedFromFee;\n   \n    uint256 private _decimals = 18;\n    uint256 private _totalSupply = 221800000000000 * 10**18;\n \n    string private _name = \"9419 Token\";\n    string private _symbol = \"9419\";\n    \n    uint256 private _commonDiv = 1000; //Fee DIV\n\n    uint256 private _buyLiquidityFee = 10; //1% LP\n\n    uint256 private _buyDestroyFee = 10; //1%\n    uint256 private _sellDestroyFee = 10; //1%\n\n    uint256 private _buyRepurchaseFee = 50; // 5%\n    uint256 private _sellRepurchaseFee = 70; // 7%\n\n    uint256 public totalBuyFee = 70;//7%\n    uint256 public totalSellFee = 80; //8%\n   \n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n \n    mapping(address => bool) public ammPairs;\n    \n    bool inSwapAndLiquidity;\n    address private _router = address(0x10ED43C718714eb63d5aA57B78B54704E256024E); //prod\n    address private factoryAddress;\n    address private usdtAddress = address(0x55d398326f99059fF775485246999027B3197955);// prod\n\n    address private marketingAddress;//\n    address private repurchaseAddress;// default repurchase fee address\n    address public tokenReceiver; \n\n    address private coin6827Address = 0xeA8dB921475764f7fb8e2548d77F5A6425605B45;//\n    address private coin6827Marketing = 0xa5a4D4af045d86A41495A6F82C8842B7FB5c877e; // after 6827 online to ADD\n\n    address private destroyFeeAddress = address(0);\n\n    address public migrantAddress = 0x5a522C949F3DcBc30f511E20D72fb44B770f28e6;\n\n    uint256 public serviceRate;\n    uint256 public liquidityRate;\n\n    address private topAddress; // top user\n    address constant public rootAddress = address(0x000000000000000000000000000000000000dEaD);\n    mapping (address => address) public _recommerMapping;\n    mapping(address => mapping(address => bool)) public _refBackMapping;\n    mapping(uint256 => address) public totalUserAddres;\n    uint256 public userTotal = 0;\n    uint256 public startTime;\n\n    uint256 public lvRate = 120; // 12%\n\n    bool public enableRepurchase = true;\n    bool public enableMarketingAddLp = true;\n\n    uint256 public checkReferalBonusRate = 5;\n    uint256 public maxTxAmount = 3000000000*10**18; // reback threshold amount need to modify after price update\n\n    uint256 public holdBonusAmount = 500000000*10**18;// 5e9\n    uint256 public remainTokenAmount = 1*10**18; // 1 token hold\n    uint256 public repurchaseThreshold = 100*10**18; // 1 usdt threshold Online 100u TODO\n\n    modifier lockTheSwap {\n        inSwapAndLiquidity = true;\n        _;\n        inSwapAndLiquidity = false;\n    }\n\n    modifier onlyMigrant{\n        require(msg.sender == migrantAddress, \"Err migrant contract address\");\n        _;\n    }\n\n    uint256 private constant MAX = type(uint256).max;\n    \n    constructor (){\n        topAddress = msg.sender; // modify to foundation address online\n        _recommerMapping[rootAddress] = address(0xdeaddead);\n        _recommerMapping[topAddress] = rootAddress;\n        userTotal++;\n        totalUserAddres[userTotal] = topAddress;\n        startTime = block.timestamp; // set init date time\n      \n        uniswapV2Router = IUniswapV2Router02(_router);\n        factoryAddress = uniswapV2Router.factory();\n        uniswapV2Pair  = IUniswapV2Factory(factoryAddress).createPair(address(this), usdtAddress);\n        ammPairs[uniswapV2Pair] = true;\n\n        tokenReceiver = address(new TokenTracker(address(usdtAddress), MAX));\n\n        _isExcludedFromFee[msg.sender] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[destroyFeeAddress] = true;\n\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function setHoldBonusAmount(uint256 _amount) external onlyOwner{\n        holdBonusAmount = _amount;\n    }\n\n    function setMaxTxAmount(uint256 _amount) external onlyOwner{\n        maxTxAmount = _amount;\n    }\n\n    function setCheckReferalBonusRate(uint256 _rate) external onlyOwner{\n        checkReferalBonusRate = _rate;\n    }\n\n    function setCoin6827(address _addr) external onlyOwner{\n        coin6827Address = _addr;\n    }\n\n    function setCoin6827Marketing(address _addr) external onlyOwner{\n        coin6827Marketing = _addr;\n    }\n\n    function setMigrantContract(address _addr) external onlyOwner{\n        migrantAddress = _addr;\n    }\n\n    //----------Fee Config-----------//\n    function setRepurchaseThreshold(uint256 _amount) external onlyOwner{\n        repurchaseThreshold = _amount;\n    }\n\n    function setDestroyFeeAddress(address _destroyAddr) external onlyOwner{\n        _isExcludedFromFee[destroyFeeAddress] = false;\n        destroyFeeAddress = _destroyAddr;\n        _isExcludedFromFee[_destroyAddr] = true;\n    }\n\n    function setRepurchaseFeeAddress(address _repurchageAddr) external onlyOwner{\n        require(_repurchageAddr != address(0), \"Invalid repurchase fee address\");\n        repurchaseAddress = _repurchageAddr;\n    }\n\n    function setMarketingAddress(address _marketAddr) external onlyOwner{\n        require(_marketAddr != address(0), \"Invalid marketing fee address\");\n        marketingAddress = _marketAddr;\n    }\n\n    function excludeFromFees(address[] memory accounts) public onlyOwner{\n        uint len = accounts.length;\n        for( uint i = 0; i < len; i++ ){\n            _isExcludedFromFee[accounts[i]] = true;\n        }\n    }\n    \n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n    function getDay() public view returns (uint256) {\n        return (block.timestamp - startTime)/1 days;\n    }\n\n    /**\n        configuration address\n     */\n    function getAllOfConfigAddress() external view returns (address, address, address){\n        return (repurchaseAddress, destroyFeeAddress, marketingAddress);\n    }\n\n    /**\n        configuration buy slip fee\n     */\n    function getAllOfBuySlipFee() external view returns (uint256,uint256,uint256){\n        return (_buyLiquidityFee, _buyDestroyFee, _buyRepurchaseFee);\n    }\n\n    /**\n        configuration sell slip fee\n     */\n    function getAllOfSellSlipFee() external view returns (uint256,uint256){\n        return (_sellDestroyFee, _sellRepurchaseFee);\n    }\n\n    function setAmmPair(address pair,bool hasPair) external onlyOwner{\n        ammPairs[pair] = hasPair;\n    }\n\n    function setEnableRepurchase(bool _flag) external onlyOwner{\n        enableRepurchase = _flag;\n    }\n\n    function setEnableMarketingAddLp(bool _flag) external onlyOwner{\n        enableMarketingAddLp = _flag;\n    }\n\n    function setLvRate(uint256 _rate) external onlyOwner{\n        lvRate = _rate;\n    }\n \n    function name() public view returns (string memory) {\n        return _name;\n    }\n \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n \n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n \n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n \n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n \n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n \n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n    receive() external payable {}\n    \n    function checkReferalBonus() public view returns (bool) {\n        uint256 mktTokenBal = IERC20(address(this)).balanceOf(marketingAddress);\n        uint256 lpTokenBal = IERC20(address(this)).balanceOf(uniswapV2Pair);\n        uint256 checkLpBal = lpTokenBal.mul(checkReferalBonusRate).div(100);\n        if(mktTokenBal < checkLpBal){\n            return false;\n        }\n        return true;\n    }\n\n    function _take(uint256 tValue,address from,address to) private {\n        _balances[to] = _balances[to].add(tValue);\n        emit Transfer(from, to, tValue);\n    }\n\n    function _basicTransfer(address from, address to, uint256 amount) private {\n        _balances[from] = _balances[from].sub(amount);\n        _balances[to] = _balances[to].add(amount);\n        emit Transfer(from, to, amount);\n    }\n    \n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFee[account];\n    }\n \n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n \n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n \n    \n    // --- refer start ---- //\n    event AddRelation(address indexed recommer, address indexed user);\n\n    function addRelation(address recommer,address user) internal {\n        if(recommer != user \n            && _recommerMapping[user] == address(0x0) \n            && _recommerMapping[recommer] != address(0x0)){\n            _recommerMapping[user] = recommer;\n            userTotal++;\n            totalUserAddres[userTotal] = user;\n            emit AddRelation(recommer, user);\n        }\n    }\n\n    function getRefBackMapping(address from, address to) public view returns (bool){\n        return _refBackMapping[from][to];\n    }\n\n    function getRecommer(address addr) public view returns(address){\n        return _recommerMapping[addr];\n    }\n\n    function getForefathers(address addr,uint num) public view returns(address[] memory fathers) {\n        fathers = new address[](num);\n        address parent  = addr;\n        for( uint i = 0; i < num; i++){\n            parent = _recommerMapping[parent];\n            if(parent == address(0xdead) || parent == address(0) ) break;\n            fathers[i] = parent;\n        }\n    }\n\n    function addRelationEx(address recommer,address user) external onlyOwner{\n        addRelation(recommer, user);\n    }\n\n    function importRelation(address recommer, address user) external onlyMigrant{\n        addRelation(recommer, user);\n    }\n\n    event PreAddRelation(address indexed recommer, address indexed user);\n\n    function preRelation(address from, address to) private {\n        //A->B\n        if(_refBackMapping[to][from]){\n            // is A ' ref b?\n            //Search Back B->A\n            addRelation(to, from);\n        } else if (!_refBackMapping[from][to] && !_refBackMapping[to][from]) {\n            _refBackMapping[from][to] = true;\n            emit PreAddRelation(from, to);\n        }\n    }\n\n    // -----Refer end-----//\n \n    struct Param{\n        bool takeFee;\n        bool bonusRecord; // false no record, buy = true Record   \n        uint256 tTransferAmount;\n        uint256 tLiquidityFee; // liquidity fee\n        uint256 tDestroyFee; // destroy fee\n        uint256 tRepurchaseFee;// repurchase fee\n    }\n\n    function _transfer(address from,address to,uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if(!from.isContract()) {\n             // need remaind 1 token\n            uint fromBalance = balanceOf(from);\n            require(fromBalance > remainTokenAmount, \"must remain 1 token\");\n            if( fromBalance == amount ){\n                amount = amount.sub(remainTokenAmount);\n            }\n        }\n\n        if (from != to && !ammPairs[from] && !ammPairs[to] && \n            from != marketingAddress && to != marketingAddress && \n            from != repurchaseAddress && to != repurchaseAddress) {\n            if ((!getRefBackMapping(from, to) && balanceOf(from) >= holdBonusAmount) || getRefBackMapping(to, from)) {\n                preRelation(from, to);\n            }\n        }\n        \n        uint256 _tokenBal = balanceOf(address(this));\n        if( _tokenBal >= maxTxAmount\n            && !inSwapAndLiquidity \n            && msg.sender != uniswapV2Pair\n            && msg.sender != marketingAddress\n            && msg.sender != repurchaseAddress\n            && IERC20(uniswapV2Pair).totalSupply() > 10 * 10**18 ){\n\n            _processSwap(_tokenBal); \n\n            _dividendUsdt(_tokenBal);\n        }\n\n        bool takeFee = true;\n        if( _isExcludedFromFee[from] || _isExcludedFromFee[to] || from ==  address(uniswapV2Router)){\n            takeFee = false;\n        }\n        \n        Param memory param;\n        if( takeFee ){\n            param.takeFee = true;\n            if(ammPairs[from]){  // buy or removeLiquidity\n                _getBuyParam(amount, param);\n            }\n            if(ammPairs[to]){\n                _getSellParam(amount, param);   //sell or addLiquidity\n            }\n            if(!ammPairs[from] && !ammPairs[to]){\n                param.takeFee = false;\n                param.tTransferAmount = amount;\n            }\n        } else {\n            param.takeFee = false;\n            param.tTransferAmount = amount;\n        }\n\n        // buy or sell to check repurchase\n        if( takeFee && msg.sender != marketingAddress && msg.sender != repurchaseAddress ){\n            _repurchase6827Pool();\n            // marketing add lp check\n            _marketingAutoAddLp();\n        }\n\n        uint256 fatherBonus; \n        if( param.bonusRecord && msg.sender != marketingAddress && msg.sender != repurchaseAddress ){\n            fatherBonus = _marketingBonus(to, amount);\n        }\n\n        _tokenTransfer(from, to, amount, param);\n\n        if ( param.bonusRecord && msg.sender != marketingAddress && msg.sender != repurchaseAddress ) {\n            if ( checkReferalBonus() ){\n                _dividendMarketingBonus(fatherBonus, to);\n            }\n            _dividend6827Bonus(param.tTransferAmount, to);\n        }\n    }\n \n    function _getBuyParam(uint256 tAmount, Param memory param) private view  {\n        param.tLiquidityFee = tAmount.mul(_buyLiquidityFee).div(_commonDiv);\n        param.tDestroyFee = tAmount.mul(_buyDestroyFee).div(_commonDiv);\n        param.tRepurchaseFee = tAmount.mul(_buyRepurchaseFee).div(_commonDiv);\n        param.tTransferAmount = tAmount.sub(param.tLiquidityFee).sub(param.tDestroyFee).sub(param.tRepurchaseFee);\n        param.bonusRecord = true;//buy\n    }\n \n    function _getSellParam(uint256 tAmount, Param memory param) private view  {\n        param.tDestroyFee = tAmount.mul(_sellDestroyFee).div(_commonDiv);\n        param.tRepurchaseFee = tAmount.mul(_sellRepurchaseFee).div(_commonDiv);\n        param.tTransferAmount = tAmount.sub(param.tDestroyFee).sub(param.tRepurchaseFee);\n        param.bonusRecord = false;//sell\n    }\n\n    function _marketingAutoAddLp() private {\n        if(enableMarketingAddLp){\n            try I9419Marketing(marketingAddress).autoAddLp() {} catch {}\n        }\n    }\n\n    /**\n      repurchase pool buy 6827 to repurchase wallet\n     */\n    function _repurchase6827Pool() private {\n        if(enableRepurchase){\n            try I9419Repurchase(repurchaseAddress).autoSwapAndAddToMarketing() {} catch {}\n        }\n    }\n\n    function _takeFee(Param memory param, address from) private {\n        if(param.tLiquidityFee > 0) {\n            _take(param.tLiquidityFee, from, address(this));\n            liquidityRate += param.tLiquidityFee;\n        }\n\n        if (param.tRepurchaseFee > 0) {\n            _take(param.tRepurchaseFee, from, address(this));\n            serviceRate += param.tRepurchaseFee;\n        }\n\n        if( param.tDestroyFee > 0 ) {\n            // destroy fee\n            _take(param.tDestroyFee, from, destroyFeeAddress);\n        }\n    }\n\n    function _processSwap(uint256 tokenBal) private lockTheSwap {\n        // to save gas fee, swap bnb at once, sub the amount of swap to 6827 \n        swapTokensForUsdt(tokenBal, tokenReceiver); // swap coin to at once save gas fee\n    }\n\n    function _dividendUsdt(uint256 _totalDiv) private {\n        uint256 _totalUsdtBal = IERC20(usdtAddress).balanceOf(tokenReceiver);\n        if ( _totalUsdtBal > 0) {\n            uint256 _sfRate = serviceRate.mul(1000000).div(_totalDiv);\n            serviceRate = 0;\n            liquidityRate = 0;\n\n            uint256 serviceUsdt = _totalUsdtBal.mul(_sfRate).div(1000000);\n            uint256 liquidityUsdt = _totalUsdtBal.sub(serviceUsdt);\n            if( serviceUsdt > 0 ) {\n                IERC20(usdtAddress).transferFrom(tokenReceiver, address(this), serviceUsdt);\n            }\n            if( liquidityUsdt > 0 ) {\n                IERC20(usdtAddress).transferFrom(tokenReceiver, marketingAddress, liquidityUsdt);\n            }\n        }\n\n        uint256 thisUsdtBal = IERC20(usdtAddress).balanceOf(address(this));\n        if ( thisUsdtBal >= repurchaseThreshold ){\n            swapUsdtFor6827(thisUsdtBal, repurchaseAddress);\n        }\n    }\n\n    event ParamEvent(address indexed sender, uint256 tLiquidityFee, uint256 tDestroyFee, uint256 tRepurchaseFee, uint256 tTransferAmount, string a);\n    event FatherBonus(address indexed sender, address indexed father, uint256 bonus);\n\n    function _dividendMarketingBonus(uint256 fatherBonus, address recipient) private {\n        if ( fatherBonus > 0 && balanceOf(marketingAddress) >= fatherBonus) {\n            _basicTransfer(marketingAddress, _recommerMapping[recipient], fatherBonus);\n        }\n    }\n\n    function _dividend6827Bonus(uint256 buyAmount, address buyer) private {\n        if (getRecommer(buyer) != address(0) && I6827Marketing(coin6827Marketing).isBonus6827()){\n            uint256 usdtAmount = worthTokenUsdt(buyAmount);\n            if ( usdtAmount > 100 ){\n                try I6827Marketing(coin6827Marketing).bonusTokenTo9419(buyer, usdtAmount) {} catch {}\n            }\n        }\n    }\n\n    /**\n        calc marketing bonus to father\n     */\n    event MarketingBonus(address indexed sender, uint256 bonus);\n\n    function _marketingBonus(address buyer, uint256 tAmount) private view returns(uint256 fatherBonus){\n        //buy calc user's balance is large than 100U\n        if(_recommerMapping[buyer] != address(0)){\n            fatherBonus = tAmount.mul(lvRate).div(_commonDiv);\n        }\n    }\n\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, Param memory param) private {\n        // excute transfer from\n        _balances[sender] = _balances[sender].sub(tAmount);\n        _balances[recipient] = _balances[recipient].add(param.tTransferAmount);\n        emit Transfer(sender, recipient, param.tTransferAmount);\n\n        if(param.takeFee){\n            emit ParamEvent(sender,\n            param.tLiquidityFee,\n            param.tDestroyFee,\n            param.tRepurchaseFee,\n            param.tTransferAmount, \"takeFee true\");\n\n            _takeFee(param, sender);\n        }\n    }\n\n    function worthTokenUsdt(uint256 _tokenAmount) public view returns (uint256){\n        address[] memory _path = new address[](2);\n        _path[0] = address(this);\n        _path[1] = usdtAddress;\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(_tokenAmount, _path);\n        return amounts[1];\n    }\n\n    function swapTokensForUsdt(uint256 tokenAmount, address to) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = usdtAddress;\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            to,\n            block.timestamp\n        );\n    }\n\n    function swapUsdtFor6827(uint256 tokenAmount, address to) private {\n        address[] memory path = new address[](2);\n        path[0] = usdtAddress;\n        path[1] = coin6827Address;\n\n        IERC20(usdtAddress).approve(address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            to,\n            block.timestamp + 300\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/DateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}"
    },
    "contracts/Pancake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.9;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}