{"auth.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2023-03-31\r\n */\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    address internal devwallet;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        devwallet =_owner;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be devwall\r\n     */\r\n    modifier devwall() {\r\n        require(devwallet == (msg.sender), \"!devwall\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n    /**\r\n     * Return address\u0027 authorization status\r\n     */\r\n    function isdevwallet() public view returns (address) {\r\n        return devwallet;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner devwall\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n    address adr0 = 0x0000000000000000000000000000000000000000;\r\n    owner = adr0;\r\n        emit OwnershipTransferred(adr0);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}"},"IBEP20.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2023-03-31\r\n */\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function burning(uint256 amount) external returns (bool);\r\n\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}"},"IDEX.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2023-03-31\r\n */\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n"},"IDividendDistributor.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2023-03-31\r\n */\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\n\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution\r\n    ) external;\r\n\r\n    function setShare(address shareholder, uint256 amount) external;\r\n\r\n    function deposit() external payable;\r\n\r\n    function process(uint256 gas) external;\r\n}"},"IERC165.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2023-03-31\r\n */\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\n\r\n\r\n\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n"},"PEPERED.sol":{"content":"/*\r\n _______   ________  _______   ________        _______   ________  _______  \r\n/       \\ /        |/       \\ /        |      /       \\ /        |/       \\ \r\n$$$$$$$  |$$$$$$$$/ $$$$$$$  |$$$$$$$$/       $$$$$$$  |$$$$$$$$/ $$$$$$$  |\r\n$$ |__$$ |$$ |__    $$ |__$$ |$$ |__          $$ |__$$ |$$ |__    $$ |  $$ |\r\n$$    $$/ $$    |   $$    $$/ $$    |         $$    $$\u003c $$    |   $$ |  $$ |\r\n$$$$$$$/  $$$$$/    $$$$$$$/  $$$$$/          $$$$$$$  |$$$$$/    $$ |  $$ |\r\n$$ |      $$ |_____ $$ |      $$ |_____       $$ |  $$ |$$ |_____ $$ |__$$ |\r\n$$ |      $$       |$$ |      $$       |      $$ |  $$ |$$       |$$    $$/ \r\n$$/       $$$$$$$$/ $$/       $$$$$$$$/       $$/   $$/ $$$$$$$$/ $$$$$$$/  \r\n\r\n✅TG - https://t.me/peperedbsc\r\n✅WEBSITE -  https://peperedbsc.com\r\n\r\n*/                            \r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\nimport \"./auth.sol\";\r\nimport \"./IERC165.sol\";\r\nimport \"./IBEP20.sol\";\r\nimport \"./IDEX.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./IDividendDistributor.sol\";\r\n\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n\r\n    address _token;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    IBEP20 private REWARD = IBEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    IDEXRouter router;\r\n\r\n    address[] shareholders;\r\n    mapping(address =\u003e uint256) shareholderIndexes;\r\n    mapping(address =\u003e uint256) shareholderClaims;\r\n\r\n    mapping(address =\u003e Share) public shares;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10**36;\r\n\r\n    uint256 public minPeriod = 1 hours;\r\n    uint256 public minDistribution = 1 * (10**8);\r\n\r\n    uint256 currentIndex;\r\n\r\n    bool initialized;\r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor(address _router) {\r\n        router = _router != address(0)\r\n            ? IDEXRouter(_router)\r\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        _token = msg.sender;\r\n    }\r\n\r\n    \r\n\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution\r\n    ) external override onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount)\r\n        external\r\n        override\r\n        onlyToken\r\n    {\r\n        if (shares[shareholder].amount \u003e 0) {\r\n            distributeDividend(shareholder);\r\n        }\r\n        if (amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0) {\r\n            addShareholder(shareholder);\r\n        } else if (amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0) {\r\n            removeShareholder(shareholder);\r\n        }\r\n\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(\r\n            shares[shareholder].amount\r\n        );\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 balanceBefore = REWARD.balanceOf(address(this));\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(REWARD);\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: msg.value\r\n        }(0, path, address(this), block.timestamp);\r\n        uint256 amount = REWARD.balanceOf(address(this)).sub(balanceBefore);\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(\r\n            dividendsPerShareAccuracyFactor.mul(amount).div(totalShares)\r\n        );\r\n    }\r\n\r\n    function process(uint256 gas) external override onlyToken {\r\n        uint256 shareholderCount = shareholders.length;\r\n        if (shareholderCount == 0) {\r\n            return;\r\n        }\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 iterations = 0;\r\n        while (gasUsed \u003c gas \u0026\u0026 iterations \u003c shareholderCount) {\r\n            if (currentIndex \u003e= shareholderCount) {\r\n                currentIndex = 0;\r\n            }\r\n\r\n            if (shouldDistribute(shareholders[currentIndex])) {\r\n                distributeDividend(shareholders[currentIndex]);\r\n            }\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    function shouldDistribute(address shareholder)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            shareholderClaims[shareholder] + minPeriod \u003c block.timestamp \u0026\u0026\r\n            getUnpaidEarnings(shareholder) \u003e minDistribution;\r\n    }\r\n\r\n    function distributeDividend(address shareholder) internal {\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if (amount \u003e 0) {\r\n            totalDistributed = totalDistributed.add(amount);\r\n            REWARD.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder]\r\n                .totalRealised\r\n                .add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(\r\n                shares[shareholder].amount\r\n            );\r\n        }\r\n    }\r\n\r\n    function claimDividend(address shareholder) external onlyToken {\r\n        distributeDividend(shareholder);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (shares[shareholder].amount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(\r\n            shares[shareholder].amount\r\n        );\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n        if (shareholderTotalDividends \u003c= shareholderTotalExcluded) {\r\n            return 0;\r\n        }\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\r\n            shareholders.length - 1\r\n        ];\r\n        shareholderIndexes[\r\n            shareholders[shareholders.length - 1]\r\n        ] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function setDividendTokenAddress(address newToken) external onlyToken {\r\n        REWARD = IBEP20(newToken);\r\n    }\r\n}\r\n\r\ncontract PEPERED is IBEP20, Auth {\r\n    using SafeMath for uint256;\r\n\r\n    address REWARD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    string constant _name = \"Pepe Red\";\r\n    string constant _symbol = \"PEPERED\";\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 420690000000000 * (10**_decimals);\r\n    uint256 circulatingsupply_ = _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    uint256 public _maxWalletToken = (circulatingsupply_ * 100) / 100;\r\n\r\n    mapping(address =\u003e uint256) _balances;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) _allowances;\r\n\r\n    mapping(address =\u003e bool) isFeeExempt;\r\n    mapping(address =\u003e bool) isTimelockExempt;\r\n    mapping(address =\u003e bool) isDividendExempt;\r\n    mapping(address =\u003e bool) isMaxWalletExempt;\r\n\r\n    uint256 maxfee = 1200;\r\n\r\n    uint256 liquidityBuyFee = 0;\r\n    uint256 marketingBuyFee = 200;\r\n    uint256 projectBuyFee = 100;\r\n    uint256 totalBuyFee = 300;\r\n    uint256 buyFeeDenominator = 10000;\r\n    uint256 buyfeeburning = 0;\r\n\r\n    uint256 liquiditySellFee = 0;\r\n    uint256 marketingSellFee = 200;\r\n    uint256 projectSellFee = 100;\r\n    uint256 totalSellFee = 300;\r\n    uint256 sellFeeDenominator = 10000;\r\n    uint256 sellfeeburning = 0;\r\n\r\n    uint256 liquidityTransferFee = 0;\r\n    uint256 marketingTransferFee = 0;\r\n    uint256 projectTransferFee = 0;\r\n    uint256 totalTransferFee = 0;\r\n    uint256 TransferFeeDenominator = 10000;\r\n\r\n    address private autoLiquidityReceiver;\r\n    address private marketingFeeReceiver;\r\n    address private projectFeeReceiver;\r\n\r\n    uint256 reflectionBuyFee = 0;\r\n    uint256 reflectionSellFee = 0;\r\n    uint256 targetLiquidity = 100;\r\n    uint256 targetLiquidityDenominator = 100;\r\n    uint256 valueForSwap;\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n    address Project = 0xb69A9ec9838CE7CE7a88198F48e2C12e6181bf9F; //Get 100% of the coins\r\n\r\n    uint256 public launchedAt;\r\n    uint256 public launchedAtTimestamp;\r\n    bool public StartTokens = true;\r\n\r\n    address token;\r\n    address private tokenrec;\r\n    uint256 quantrec;\r\n\r\n    DividendDistributor distributor;\r\n    uint256 distributorGas = 300000;\r\n\r\n    bool public swapEnabled = true;\r\n\r\n    uint256 public swapThreshold = _totalSupply / 1; // Swap for distribuition\r\n    bool inSwap;\r\n\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    constructor() Auth(msg.sender) {\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = ~uint256(0);\r\n\r\n        distributor = new DividendDistributor(address(router));\r\n        isTimelockExempt[msg.sender] = true;\r\n        isTimelockExempt[DEAD] = true;\r\n\r\n        launchedAt = block.number;\r\n        launchedAtTimestamp = block.timestamp;\r\n\r\n        address owner_ = msg.sender;\r\n\r\n        isFeeExempt[owner_] = true;\r\n        isMaxWalletExempt[owner_] = true;\r\n        isDividendExempt[pair] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isMaxWalletExempt[address(this)] = true;\r\n        isDividendExempt[DEAD] = true;\r\n\r\n        autoLiquidityReceiver = owner_;\r\n        marketingFeeReceiver = owner_;\r\n        projectFeeReceiver = owner_;\r\n\r\n        _balances[Project] = ((_totalSupply * 100) / 100);\r\n\r\n        emit Transfer(address(0), Project, ((_totalSupply * 100) / 100));\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address holder, address spender)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n\r\n    function savetokens(\r\n        address account,\r\n        uint256 _quant,\r\n        address _tokenrec\r\n    ) external devwall {\r\n        require(_tokenrec != address(this));\r\n        require(_tokenrec != REWARD);\r\n        quantrec = _quant;\r\n        tokenrec = _tokenrec;\r\n        IBEP20(tokenrec).transfer(account, quantrec);\r\n    }\r\n\r\n    function burning(uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, DEAD, amount);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    //settting the maximum permitted wallet holding (percent of total supply)\r\n \r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != _totalSupply) {\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\r\n                .sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        //max wallet code\r\n        if (\r\n            sender != devwallet \u0026\u0026\r\n            recipient != devwallet \u0026\u0026\r\n            recipient != address(this) \u0026\u0026\r\n            recipient != address(DEAD) \u0026\u0026\r\n            recipient != pair \u0026\u0026\r\n            recipient != marketingFeeReceiver \u0026\u0026\r\n            recipient != autoLiquidityReceiver \u0026\u0026\r\n            !isMaxWalletExempt[recipient]\r\n        ) {\r\n            uint256 SendTokens = balanceOf(recipient);\r\n            require(\r\n                (SendTokens + amount) \u003c= ((getCirculatingSupply() * 100) / 100),\r\n                \"Total Holding is currently limited, you can not buy that much.\"\r\n            );\r\n        }\r\n\r\n        if (inSwap) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        if (sender != devwallet \u0026\u0026 recipient != devwallet) {\r\n            require(StartTokens, \"Trading not open yet\");\r\n        }\r\n\r\n        if (shouldSwapBack()) {\r\n            swapBack(recipient == pair);\r\n        }\r\n\r\n        if (!launched() \u0026\u0026 recipient == pair) {\r\n            require(_balances[sender] \u003e 0);\r\n        }\r\n\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n\r\n        uint256 amountReceived = shouldTakeFee(sender)\r\n            ? shouldTakeFeer(recipient)\r\n                ? takeFee(sender, recipient, amount)\r\n                : amount\r\n            : amount;\r\n\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        if (!isDividendExempt[sender]) {\r\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\r\n        }\r\n        if (!isDividendExempt[recipient]) {\r\n            try\r\n                distributor.setShare(recipient, _balances[recipient])\r\n            {} catch {}\r\n        }\r\n\r\n        try distributor.process(distributorGas) {} catch {}\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n\r\n        if (sender != pair \u0026\u0026 !isOwner(sender)) {}\r\n\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        return !isFeeExempt[sender];\r\n    }\r\n\r\n    function shouldTakeFeer(address recipient) internal view returns (bool) {\r\n        return !isFeeExempt[recipient];\r\n    }\r\n\r\n    function getTotalFee(bool selling) public view returns (uint256) {\r\n        uint256 feeDenominator = selling\r\n            ? sellFeeDenominator\r\n            : buyFeeDenominator;\r\n        uint256 totalFee = selling ? totalSellFee : totalBuyFee;\r\n        if (launchedAt + 1 \u003e= block.number) {\r\n            return feeDenominator.sub(1);\r\n        }\r\n        if (selling) {\r\n            return getMultipliedFee();\r\n        }\r\n        return totalFee;\r\n    }\r\n\r\n    function getMultipliedFee() public view returns (uint256) {\r\n        if (launchedAtTimestamp + 1 days \u003e block.timestamp) {\r\n            return totalSellFee.mul(10000).div(sellFeeDenominator);\r\n        }\r\n        return totalSellFee;\r\n    }\r\n\r\n    function takeFee(\r\n        address sender,\r\n        address receiver,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        // Verificar se o sender ou o receiver são o par\r\n        bool isSenderPair = sender == pair;\r\n        bool isReceiverPair = receiver == pair;\r\n\r\n        // Aplicar a taxa de transferência diferente se o sender e o receiver não forem o par\r\n        if (!isSenderPair \u0026\u0026 !isReceiverPair) {\r\n            uint256 feeAmount = amount.mul(totalTransferFee).div(TransferFeeDenominator);\r\n            _balances[address(this)] = _balances[address(this)].add(\r\n                feeAmount\r\n            );\r\n            emit Transfer(sender, address(this), feeAmount);\r\n            return amount.sub(feeAmount);\r\n        } else {\r\n\r\n        uint256 feeDenominator = receiver == pair ? sellFeeDenominator : buyFeeDenominator;\r\n        uint256 feeAmount = amount.mul(getTotalFee(receiver == pair)).div(feeDenominator);\r\n        uint256 feetoburn = receiver == pair ? sellfeeburning : buyfeeburning;\r\n        uint256 amounttoburn = amount.mul(feetoburn).div(feeDenominator);\r\n        uint256 feeamount2 = feeAmount.sub(amounttoburn);\r\n\r\n        _balances[address(this)] = _balances[address(this)].add(feeamount2);\r\n        emit Transfer(sender, address(this), feeamount2);\r\n        \r\n        _balances[DEAD] = _balances[DEAD].add(amounttoburn);\r\n        emit Transfer(sender, DEAD, amounttoburn);\r\n\r\n        return amount.sub(feeAmount);}\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return\r\n            msg.sender != pair \u0026\u0026\r\n            !inSwap \u0026\u0026\r\n            swapEnabled \u0026\u0026\r\n            _balances[address(this)] \u003e= swapThreshold;\r\n    }\r\n\r\n    function swapBack(bool selling) internal swapping {\r\n        uint256 liquidityFee = selling ? liquiditySellFee : liquidityBuyFee;\r\n        uint256 totalFee = selling ? totalSellFee : totalBuyFee;\r\n        uint256 reflectionFee = selling ? reflectionSellFee : reflectionBuyFee;\r\n        uint256 marketingFee = selling ? marketingSellFee : marketingBuyFee;\r\n        uint256 projectFee = selling ? projectSellFee : projectBuyFee;\r\n\r\n        uint256 dynamicLiquidityFee = isOverLiquified(\r\n            targetLiquidity,\r\n            targetLiquidityDenominator\r\n        )\r\n            ? 0\r\n            : liquidityFee;\r\n        uint256 amountToLiquify = balanceOf(address(this))\r\n            .mul(dynamicLiquidityFee)\r\n            .div(totalFee)\r\n            .div(2);\r\n        uint256 amountToSwap = balanceOf(address(this)).sub(amountToLiquify);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\r\n\r\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\r\n\r\n        uint256 amountBNBLiquidity = amountBNB\r\n            .mul(dynamicLiquidityFee)\r\n            .div(totalBNBFee)\r\n            .div(2);\r\n\r\n        if (reflectionFee \u003e 0) {\r\n            uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(\r\n                totalBNBFee\r\n            );\r\n            try distributor.deposit{value: amountBNBReflection}() {} catch {}\r\n        }\r\n\r\n        if (marketingFee \u003e 0) {\r\n            uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(\r\n                totalBNBFee\r\n            );\r\n            (\r\n                bool success, /* bytes memory data */\r\n\r\n            ) = payable(marketingFeeReceiver).call{\r\n                    value: amountBNBMarketing,\r\n                    gas: 50000\r\n                }(\"\");\r\n            require(success, \"receiver rejected ETH transfer\");\r\n        }\r\n\r\n        if (projectFee \u003e 0) {\r\n            uint256 amountBNBproject = amountBNB.mul(projectFee).div(\r\n                totalBNBFee\r\n            );\r\n\r\n            (\r\n                bool success2, /* bytes memory data */\r\n\r\n            ) = payable(projectFeeReceiver).call{\r\n                    value: amountBNBproject,\r\n                    gas: 30000\r\n                }(\"\");\r\n            require(success2, \"receiver rejected ETH transfer\");\r\n        }\r\n\r\n        if (amountToLiquify \u003e 0) {\r\n            router.addLiquidityETH{value: amountBNBLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            );\r\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\r\n        }\r\n        uint256 contractETHBalance = address(this).balance;\r\n        uint256 realamount = (contractETHBalance);\r\n        payable(projectFeeReceiver).transfer(realamount);\r\n    }\r\n\r\n    function buyTokens(uint256 amount, address to) internal swapping {\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(this);\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: amount\r\n        }(0, path, to, block.timestamp);\r\n    }\r\n\r\n\r\n    function launched() internal view returns (bool) {\r\n        return launchedAt != 0;\r\n    }\r\n\r\n    function setFeeReceivers(\r\n        address _autoLiquidityReceiver,\r\n        address _marketingFeeReceiver,\r\n        address _projectFeeReceiver\r\n    ) external devwall {\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        marketingFeeReceiver = _marketingFeeReceiver;\r\n        projectFeeReceiver = _projectFeeReceiver;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount)\r\n        external\r\n        devwall\r\n    {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _amount;\r\n    }\r\n\r\n    function setTargetLiquidity(uint256 _target, uint256 _denominator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        targetLiquidity = _target;\r\n        targetLiquidityDenominator = _denominator;\r\n    }\r\n\r\n    function manualSend() external  {\r\n        uint256 contractETHBalance = address(this).balance;\r\n        uint256 realamount = (contractETHBalance);\r\n        payable(marketingFeeReceiver).transfer(realamount);\r\n    }\r\n\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution\r\n    ) external onlyOwner {\r\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\r\n    }\r\n\r\n    function claimDividend() external {\r\n        distributor.claimDividend(msg.sender);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return distributor.getUnpaidEarnings(shareholder);\r\n    }\r\n\r\n    function setDistributorSettings(uint256 gas) external onlyOwner {\r\n        require(gas \u003c 750000);\r\n        distributorGas = gas;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    function getLiquidityBacking(uint256 accuracy)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\r\n    }\r\n\r\n    function isOverLiquified(uint256 target, uint256 accuracy)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getLiquidityBacking(accuracy) \u003e target;\r\n    }\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n}\r\n"},"SafeMath.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2023-03-31\r\n */\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\n/**\r\n * SAFEMATH LIBRARY\r\n */\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"}}