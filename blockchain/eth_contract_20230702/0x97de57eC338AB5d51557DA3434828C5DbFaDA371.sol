{{
  "language": "Solidity",
  "sources": {
    "contracts/Lybra.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./EUSD.sol\";\nimport \"./Governable.sol\";\n\ninterface Ilido {\n    function submit(address _referral) external payable returns (uint256 StETH);\n\n    function withdraw(address _to) external returns (uint256 ETH);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function transfer(address _recipient, uint256 _amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external returns (bool);\n}\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface esLBRMinter {\n    function refreshReward(address user) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\ncontract Lybra is EUSD, Governable {\n    uint256 public totalDepositedEther;\n    uint256 public lastReportTime;\n    uint256 public totalEUSDCirculation;\n    uint256 year = 86400 * 365;\n\n    uint256 public mintFeeApy = 150;\n    uint256 public safeCollateralRate = 160 * 1e18;\n    uint256 public immutable badCollateralRate = 150 * 1e18;\n    uint256 public redemptionFee = 50;\n    uint8 public keeperRate = 1;\n\n    mapping(address => uint256) public depositedEther;\n    mapping(address => uint256) borrowed;\n    mapping(address => bool) redemptionProvider;\n    uint256 public feeStored;\n\n    Ilido lido = Ilido(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    esLBRMinter public eslbrMinter;\n    LbrStakingPool public serviceFeePool;\n\n    event BorrowApyChanged(uint256 newApy);\n    event SafeCollateralRateChanged(uint256 newRatio);\n    event KeeperRateChanged(uint256 newSlippage);\n    event RedemptionFeeChanged(uint256 newSlippage);\n    event DepositEther(\n        address sponsor,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event WithdrawEther(\n        address sponsor,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event Mint(\n        address sponsor,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event Burn(\n        address sponsor,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 timestamp\n    );\n    event LiquidationRecord(\n        address provider,\n        address keeper,\n        address indexed onBehalfOf,\n        uint256 eusdamount,\n        uint256 LiquidateEtherAmount,\n        uint256 keeperReward,\n        bool superLiquidation,\n        uint256 timestamp\n    );\n    event LSDistribution(\n        uint256 stETHAdded,\n        uint256 payoutEUSD,\n        uint256 timestamp\n    );\n    event RedemptionProvider(address user, bool status);\n    event RigidRedemption(\n        address indexed caller,\n        address indexed provider,\n        uint256 eusdAmount,\n        uint256 etherAmount,\n        uint256 timestamp\n    );\n    event FeeDistribution(\n        address indexed feeAddress,\n        uint256 feeAmount,\n        uint256 timestamp\n    );\n    event ServiceFeePoolChanged(address pool, uint256 timestamp);\n    event ESLBRMinterChanged(address pool, uint256 timestamp);\n\n    constructor() {\n        gov = msg.sender;\n    }\n\n    function setBorrowApy(uint256 newApy) external onlyGov {\n        require(newApy <= 150, \"Borrow APY cannot exceed 1.5%\");\n        _saveReport();\n        mintFeeApy = newApy;\n        emit BorrowApyChanged(newApy);\n    }\n\n    /**\n     * @notice  safeCollateralRate can be decided by DAO,starts at 160%\n     */\n    function setSafeCollateralRate(uint256 newRatio) external onlyGov {\n        require(\n            newRatio >= 160 * 1e18,\n            \"Safe CollateralRate should more than 160%\"\n        );\n        safeCollateralRate = newRatio;\n        emit SafeCollateralRateChanged(newRatio);\n    }\n\n    /**\n     * @notice KeeperRate can be decided by DAO,1 means 1% of revenue\n     */\n    function setKeeperRate(uint8 newRate) external onlyGov {\n        require(newRate <= 5, \"Max Keeper reward is 5%\");\n        keeperRate = newRate;\n        emit KeeperRateChanged(newRate);\n    }\n\n    /**\n     * @notice DAO sets RedemptionFee, 100 means 1%\n     */\n    function setRedemptionFee(uint8 newFee) external onlyGov {\n        require(newFee <= 500, \"Max Redemption Fee is 5%\");\n        redemptionFee = newFee;\n        emit RedemptionFeeChanged(newFee);\n    }\n\n    function setLbrStakingPool(address addr) external onlyGov {\n        serviceFeePool = LbrStakingPool(addr);\n        emit ServiceFeePoolChanged(addr, block.timestamp);\n    }\n\n    function setESLBRMinter(address addr) external onlyGov {\n        eslbrMinter = esLBRMinter(addr);\n        emit ESLBRMinterChanged(addr, block.timestamp);\n    }\n\n    /**\n     * @notice User chooses to become a Redemption Provider\n     */\n    function becomeRedemptionProvider(bool _bool) external {\n        eslbrMinter.refreshReward(msg.sender);\n        redemptionProvider[msg.sender] = _bool;\n        emit RedemptionProvider(msg.sender, _bool);\n    }\n\n    /**\n     * @notice Deposit ETH on behalf of an address, update the interest distribution and deposit record the this address, can mint EUSD directly\n     *\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     *\n     * @dev Record the deposited ETH in the ratio of 1:1 and convert it into stETH.\n     */\n    function depositEtherToMint(address onBehalfOf, uint256 mintAmount)\n        external\n        payable\n    {\n        require(onBehalfOf != address(0), \"DEPOSIT_TO_THE_ZERO_ADDRESS\");\n        require(msg.value >= 1 ether, \"Deposit should not be less than 1 ETH.\");\n\n        //convert to steth\n        uint256 sharesAmount = lido.submit{value: msg.value}(gov);\n        require(sharesAmount > 0, \"ZERO_DEPOSIT\");\n\n        totalDepositedEther += msg.value;\n        depositedEther[onBehalfOf] += msg.value;\n\n        if (mintAmount > 0) {\n            _mintEUSD(onBehalfOf, onBehalfOf, mintAmount);\n        }\n\n        emit DepositEther(msg.sender, onBehalfOf, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice Deposit stETH on behalf of an address, update the interest distribution and deposit record the this address, can mint EUSD directly\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `stETHamount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * @dev Record the deposited stETH in the ratio of 1:1.\n     */\n    function depositStETHToMint(\n        address onBehalfOf,\n        uint256 stETHamount,\n        uint256 mintAmount\n    ) external {\n        require(onBehalfOf != address(0), \"DEPOSIT_TO_THE_ZERO_ADDRESS\");\n        require(stETHamount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n        lido.transferFrom(msg.sender, address(this), stETHamount);\n\n        totalDepositedEther += stETHamount;\n        depositedEther[onBehalfOf] += stETHamount;\n        if (mintAmount > 0) {\n            _mintEUSD(onBehalfOf, onBehalfOf, mintAmount);\n        }\n        emit DepositEther(msg.sender, onBehalfOf, stETHamount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check userâ€™s collateral rate after withdrawal, should be higher than `safeCollateralRate`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"WITHDRAW_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedEther[msg.sender] >= amount, \"Insufficient Balance\");\n        totalDepositedEther -= amount;\n        depositedEther[msg.sender] -= amount;\n\n        lido.transfer(onBehalfOf, amount);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender);\n        }\n        emit WithdrawEther(msg.sender, onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) public {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount);\n        if (\n            (borrowed[msg.sender] * 100) / totalSupply() > 10 &&\n            totalSupply() > 10_000_000 * 1e18\n        ) revert(\"Mint Amount cannot be more than 10% of total circulation\");\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRate is above 150%, Keeper liquidates borrowers whose collateral rate is below badCollateralRate, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Rate should be below badCollateralRate\n     * - etherAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by etherAmount * etherPrice, collateral is reduced by the etherAmount corresponding to 110% of the value. Keeper gets keeperRate / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(\n        address provider,\n        address onBehalfOf,\n        uint256 etherAmount\n    ) external {\n        uint256 etherPrice = _etherPrice();\n        uint256 onBehalfOfCollateralRate = (depositedEther[onBehalfOf] *\n            etherPrice *\n            100) / borrowed[onBehalfOf];\n        require(\n            onBehalfOfCollateralRate < badCollateralRate,\n            \"Borrowers collateral rate should below badCollateralRate\"\n        );\n\n        require(\n            etherAmount * 2 <= depositedEther[onBehalfOf],\n            \"a max of 50% collateral can be liquidated\"\n        );\n        uint256 eusdAmount = (etherAmount * etherPrice) / 1e18;\n        require(\n            allowance(provider, address(this)) >= eusdAmount,\n            \"provider should authorize to provide liquidation EUSD\"\n        );\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedEther = (etherAmount * 11) / 10;\n        totalDepositedEther -= reducedEther;\n        depositedEther[onBehalfOf] -= reducedEther;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            lido.transfer(msg.sender, reducedEther);\n        } else {\n            reward2keeper = (reducedEther * keeperRate) / 110;\n            lido.transfer(provider, reducedEther - reward2keeper);\n            lido.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(\n            provider,\n            msg.sender,\n            onBehalfOf,\n            eusdAmount,\n            reducedEther,\n            reward2keeper,\n            false,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice When overallCollateralRate is below badCollateralRate, borrowers with collateralRate below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRate should be below badCollateralRate\n     * - `onBehalfOf`collateralRate should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by etherAmount * etherPrice, deposit is reduced by etherAmount * borrower's collateralRate. Keeper gets a liquidation reward of `keeperRate / borrower's collateralRate\n     */\n    function superLiquidation(\n        address provider,\n        address onBehalfOf,\n        uint256 etherAmount\n    ) external {\n        uint256 etherPrice = _etherPrice();\n        require(\n            (totalDepositedEther * etherPrice * 100) / totalSupply() <\n                badCollateralRate,\n            \"overallCollateralRate should below 150%\"\n        );\n        uint256 onBehalfOfCollateralRate = (depositedEther[onBehalfOf] *\n            etherPrice *\n            100) / borrowed[onBehalfOf];\n        require(\n            onBehalfOfCollateralRate < 125 * 1e18,\n            \"borrowers collateralRate should below 125%\"\n        );\n        require(\n            etherAmount <= depositedEther[onBehalfOf],\n            \"total of collateral can be liquidated at most\"\n        );\n        uint256 eusdAmount = (etherAmount * etherPrice) / 1e18;\n        if (onBehalfOfCollateralRate >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRate;\n        }\n        require(\n            allowance(provider, address(this)) >= eusdAmount,\n            \"provider should authorize to provide liquidation EUSD\"\n        );\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedEther -= etherAmount;\n        depositedEther[onBehalfOf] -= etherAmount;\n        uint256 reward2keeper;\n        if (\n            msg.sender != provider &&\n            onBehalfOfCollateralRate >= 1e20 + keeperRate * 1e18\n        ) {\n            reward2keeper =\n                ((etherAmount * keeperRate) * 1e18) /\n                onBehalfOfCollateralRate;\n            lido.transfer(msg.sender, reward2keeper);\n        }\n        lido.transfer(provider, etherAmount - reward2keeper);\n\n        emit LiquidationRecord(\n            provider,\n            msg.sender,\n            onBehalfOf,\n            eusdAmount,\n            etherAmount,\n            reward2keeper,\n            true,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedEther after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external {\n        uint256 payoutEther = (payAmount * 1e18) / _etherPrice();\n        require(\n            payoutEther <=\n                lido.balanceOf(address(this)) - totalDepositedEther &&\n                payoutEther > 0,\n            \"Only LSD excess income can be exchanged\"\n        );\n\n        uint256 income = feeStored + _newFee();\n\n        if (payAmount > income) {\n            _transfer(msg.sender, address(serviceFeePool), income);\n            serviceFeePool.notifyRewardAmount(income);\n\n            uint256 sharesAmount = getSharesByMintedEUSD(payAmount - income);\n            if (sharesAmount == 0) {\n                //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n                sharesAmount = payAmount - income;\n            }\n            //Income is distributed to LBR staker.\n            _burnShares(msg.sender, sharesAmount);\n            feeStored = 0;\n            emit FeeDistribution(\n                address(serviceFeePool),\n                income,\n                block.timestamp\n            );\n        } else {\n            _transfer(msg.sender, address(serviceFeePool), payAmount);\n            serviceFeePool.notifyRewardAmount(payAmount);\n            feeStored = income - payAmount;\n            emit FeeDistribution(\n                address(serviceFeePool),\n                payAmount,\n                block.timestamp\n            );\n        }\n\n        lastReportTime = block.timestamp;\n        lido.transfer(msg.sender, payoutEther);\n\n        emit LSDistribution(payoutEther, payAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external {\n        require(\n            redemptionProvider[provider],\n            \"provider is not a RedemptionProvider\"\n        );\n        require(\n            borrowed[provider] >= eusdAmount,\n            \"eusdAmount cannot surpass providers debt\"\n        );\n        uint256 etherPrice = _etherPrice();\n        uint256 providerCollateralRate = (depositedEther[provider] *\n            etherPrice *\n            100) / borrowed[provider];\n        require(\n            providerCollateralRate >= 100 * 1e18,\n            \"provider's collateral rate should more than 100%\"\n        );\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 etherAmount = (((eusdAmount * 1e18) / etherPrice) *\n            (10000 - redemptionFee)) / 10000;\n        depositedEther[provider] -= etherAmount;\n        totalDepositedEther -= etherAmount;\n        lido.transfer(msg.sender, etherAmount);\n        emit RigidRedemption(\n            msg.sender,\n            provider,\n            eusdAmount,\n            etherAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalEUSDCirculation. Check providers collateralRate cannot below `safeCollateralRate`after minting.\n     */\n    function _mintEUSD(\n        address _provider,\n        address _onBehalfOf,\n        uint256 _amount\n    ) internal {\n        uint256 sharesAmount = getSharesByMintedEUSD(_amount);\n        if (sharesAmount == 0) {\n            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n            sharesAmount = _amount;\n        }\n        eslbrMinter.refreshReward(_provider);\n        borrowed[_provider] += _amount;\n\n        _mintShares(_onBehalfOf, sharesAmount);\n\n        _saveReport();\n        totalEUSDCirculation += _amount;\n        _checkHealth(_provider);\n        emit Mint(msg.sender, _onBehalfOf, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(\n        address _provider,\n        address _onBehalfOf,\n        uint256 _amount\n    ) internal {\n        require(\n            borrowed[_onBehalfOf] >= _amount,\n            \"Repaying Amount Surpasses Borrowing Amount\"\n        );\n\n        uint256 sharesAmount = getSharesByMintedEUSD(_amount);\n        _burnShares(_provider, sharesAmount);\n\n        eslbrMinter.refreshReward(_onBehalfOf);\n\n        borrowed[_onBehalfOf] -= _amount;\n        _saveReport();\n        totalEUSDCirculation -= _amount;\n\n        emit Burn(_provider, _onBehalfOf, _amount, block.timestamp);\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Rate.\n     */\n    function _checkHealth(address user) internal {\n        if (\n            ((depositedEther[user] * _etherPrice() * 100) / borrowed[user]) <\n            safeCollateralRate\n        ) revert(\"collateralRate is Below safeCollateralRate\");\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     * https://etherscan.io/address/0x4c517D4e2C851CA76d7eC94B805269Df0f2201De#code\n     */\n    function _etherPrice() internal returns (uint256) {\n        return\n            IPriceFeed(0x4c517D4e2C851CA76d7eC94B805269Df0f2201De).fetchPrice();\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return\n            (totalEUSDCirculation *\n                mintFeeApy *\n                (block.timestamp - lastReportTime)) /\n            year /\n            10000;\n    }\n\n    /**\n     * @dev total circulation of EUSD\n     */\n    function _getTotalMintedEUSD() internal view override returns (uint256) {\n        return totalEUSDCirculation;\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function isRedemptionProvider(address user) external view returns (bool) {\n        return redemptionProvider[user];\n    }\n}\n"
    },
    "contracts/Governable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.8.17;\r\ncontract Governable {\r\n    address public gov;\r\n\r\n    event GovernanceAuthorityTransfer(address newGov);\r\n\r\n    modifier onlyGov() {\r\n        require(msg.sender == gov, \"Governable: forbidden\");\r\n        _;\r\n    }\r\n\r\n    function setGov(address _gov) external onlyGov {\r\n        gov = _gov;\r\n        emit GovernanceAuthorityTransfer(_gov);\r\n    }\r\n}"
    },
    "contracts/EUSD.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\n/**\r\n * @title Interest-bearing ERC20-like token for Lybra protocol.\r\n *\r\n * This contract is abstract. To make the contract deployable override the\r\n * `_getTotalMintedEUSD` function. `Lybra.sol` contract inherits EUSD and defines\r\n * the `_getTotalMintedEUSD` function.\r\n *\r\n * EUSD balances are dynamic and represent the holder's share in the total amount\r\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\r\n * contract also stores the sum of all shares to calculate each account's token balance\r\n * which equals to:\r\n *\r\n *   shares[account] * _getTotalMintedEUSD() / _getTotalShares()\r\n *\r\n * For example, assume that we have:\r\n *\r\n *   _getTotalMintedEUSD() -> 1000 EUSD\r\n *   sharesOf(user1) -> 100\r\n *   sharesOf(user2) -> 400\r\n *\r\n * Therefore:\r\n *\r\n *   balanceOf(user1) -> 2 tokens which corresponds 200 EUSD\r\n *   balanceOf(user2) -> 8 tokens which corresponds 800 EUSD\r\n *\r\n * Since balances of all token holders change when the amount of total supplied EUSD\r\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\r\n * events upon explicit transfer between holders. In contrast, when total amount of\r\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\r\n * emitting an event for each token holder and thus running an unbounded loop.\r\n */\r\nabstract contract EUSD is IERC20 {\r\n    using SafeMath for uint256;\r\n    uint256 private totalShares;\r\n\r\n    /**\r\n     * @dev EUSD balances are dynamic and are calculated based on the accounts' shares\r\n     * and the total supply by the protocol. Account shares aren't\r\n     * normalized, so the contract also stores the sum of all shares to calculate\r\n     * each account's token balance which equals to:\r\n     *\r\n     *   shares[account] * _getTotalMintedEUSD() / _getTotalShares()\r\n     */\r\n    mapping(address => uint256) private shares;\r\n\r\n    /**\r\n     * @dev Allowances are nominated in tokens, not token shares.\r\n     */\r\n    mapping(address => mapping(address => uint256)) private allowances;\r\n\r\n    /**\r\n     * @notice An executed shares transfer from `sender` to `recipient`.\r\n     *\r\n     * @dev emitted in pair with an ERC20-defined `Transfer` event.\r\n     */\r\n    event TransferShares(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 sharesValue\r\n    );\r\n\r\n    /**\r\n     * @notice An executed `burnShares` request\r\n     *\r\n     * @dev Reports simultaneously burnt shares amount\r\n     * and corresponding EUSD amount.\r\n     * The EUSD amount is calculated twice: before and after the burning incurred rebase.\r\n     *\r\n     * @param account holder of the burnt shares\r\n     * @param preRebaseTokenAmount amount of EUSD the burnt shares corresponded to before the burn\r\n     * @param postRebaseTokenAmount amount of EUSD the burnt shares corresponded to after the burn\r\n     * @param sharesAmount amount of burnt shares\r\n     */\r\n    event SharesBurnt(\r\n        address indexed account,\r\n        uint256 preRebaseTokenAmount,\r\n        uint256 postRebaseTokenAmount,\r\n        uint256 sharesAmount\r\n    );\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public pure returns (string memory) {\r\n        return \"eUSD\";\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public pure returns (string memory) {\r\n        return \"eUSD\";\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals for getting user representation of a token amount.\r\n     */\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of EUSD in existence.\r\n     *\r\n     * @dev Always equals to `_getTotalMintedEUSD()` since token amount\r\n     * is pegged to the total amount of EUSD controlled by the protocol.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _getTotalMintedEUSD();\r\n    }\r\n\r\n    /**\r\n     * @return the amount of tokens owned by the `_account`.\r\n     *\r\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\r\n     * total Ether controlled by the protocol. See `sharesOf`.\r\n     */\r\n    function balanceOf(address _account) public view returns (uint256) {\r\n        return getMintedEUSDByShares(_sharesOf(_account));\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\r\n     *\r\n     * @return a boolean value indicating whether the operation succeeded.\r\n     * Emits a `Transfer` event.\r\n     * Emits a `TransferShares` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `_amount`.\r\n     * - the contract must not be paused.\r\n     *\r\n     * @dev The `_amount` argument is the amount of tokens, not shares.\r\n     */\r\n    function transfer(\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) public returns (bool) {\r\n        _transfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the remaining number of tokens that `_spender` is allowed to spend\r\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\r\n     *\r\n     * @dev This value changes when `approve` or `transferFrom` is called.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    ) public view returns (uint256) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\r\n     *\r\n     * @return a boolean value indicating whether the operation succeeded.\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_spender` cannot be the zero address.\r\n     * - the contract must not be paused.\r\n     *\r\n     * @dev The `_amount` argument is the amount of tokens, not shares.\r\n     */\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        _approve(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\r\n     * allowance mechanism. `_amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * @return a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     * Emits a `TransferShares` event.\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_sender` and `_recipient` cannot be the zero addresses.\r\n     * - `_sender` must have a balance of at least `_amount`.\r\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\r\n     * - the contract must not be paused.\r\n     *\r\n     * @dev The `_amount` argument is the amount of tokens, not shares.\r\n     */\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) public returns (bool) {\r\n        uint256 currentAllowance = allowances[_sender][msg.sender];\r\n        require(\r\n            currentAllowance >= _amount,\r\n            \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\"\r\n        );\r\n\r\n        _transfer(_sender, _recipient, _amount);\r\n        _approve(_sender, msg.sender, currentAllowance.sub(_amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in:\r\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_spender` cannot be the the zero address.\r\n     * - the contract must not be paused.\r\n     */\r\n    function increaseAllowance(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) public returns (bool) {\r\n        _approve(\r\n            msg.sender,\r\n            _spender,\r\n            allowances[msg.sender][_spender].add(_addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in:\r\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_spender` cannot be the zero address.\r\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\r\n     * - the contract must not be paused.\r\n     */\r\n    function decreaseAllowance(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    ) public returns (bool) {\r\n        uint256 currentAllowance = allowances[msg.sender][_spender];\r\n        require(\r\n            currentAllowance >= _subtractedValue,\r\n            \"DECREASED_ALLOWANCE_BELOW_ZERO\"\r\n        );\r\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the total amount of shares in existence.\r\n     *\r\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\r\n     * it is necessary to store it in order to calculate each account's relative share.\r\n     */\r\n    function getTotalShares() public view returns (uint256) {\r\n        return _getTotalShares();\r\n    }\r\n\r\n    /**\r\n     * @return the amount of shares owned by `_account`.\r\n     */\r\n    function sharesOf(address _account) public view returns (uint256) {\r\n        return _sharesOf(_account);\r\n    }\r\n\r\n    /**\r\n     * @return the amount of shares that corresponds to `_EUSDAmount` protocol-supplied EUSD.\r\n     */\r\n    function getSharesByMintedEUSD(\r\n        uint256 _EUSDAmount\r\n    ) public view returns (uint256) {\r\n        uint256 totalMintedEUSD = _getTotalMintedEUSD();\r\n        if (totalMintedEUSD == 0) {\r\n            return 0;\r\n        } else {\r\n            return _EUSDAmount.mul(_getTotalShares()).div(totalMintedEUSD);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the amount of EUSD that corresponds to `_sharesAmount` token shares.\r\n     */\r\n    function getMintedEUSDByShares(\r\n        uint256 _sharesAmount\r\n    ) public view returns (uint256) {\r\n        uint256 totalSharesAmount = _getTotalShares();\r\n        if (totalShares == 0) {\r\n            return 0;\r\n        } else {\r\n            return\r\n                _sharesAmount.mul(_getTotalMintedEUSD()).div(totalSharesAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\r\n     *\r\n     * @return amount of transferred tokens.\r\n     * Emits a `TransferShares` event.\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_recipient` cannot be the zero address.\r\n     * - the caller must have at least `_sharesAmount` shares.\r\n     * - the contract must not be paused.\r\n     *\r\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\r\n     */\r\n    function transferShares(\r\n        address _recipient,\r\n        uint256 _sharesAmount\r\n    ) public returns (uint256) {\r\n        _transferShares(msg.sender, _recipient, _sharesAmount);\r\n        emit TransferShares(msg.sender, _recipient, _sharesAmount);\r\n        uint256 tokensAmount = getMintedEUSDByShares(_sharesAmount);\r\n        emit Transfer(msg.sender, _recipient, tokensAmount);\r\n        return tokensAmount;\r\n    }\r\n\r\n    /**\r\n     * @return the total amount of EUSD.\r\n     * @dev This is used for calculating tokens from shares and vice versa.\r\n     * @dev This function is required to be implemented in a derived contract.\r\n     */\r\n    function _getTotalMintedEUSD() internal view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\r\n     * Emits a `Transfer` event.\r\n     * Emits a `TransferShares` event.\r\n     */\r\n    function _transfer(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        uint256 _sharesToTransfer = getSharesByMintedEUSD(_amount);\r\n        _transferShares(_sender, _recipient, _sharesToTransfer);\r\n        emit Transfer(_sender, _recipient, _amount);\r\n        emit TransferShares(_sender, _recipient, _sharesToTransfer);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_owner` cannot be the zero address.\r\n     * - `_spender` cannot be the zero address.\r\n     * - the contract must not be paused.\r\n     */\r\n    function _approve(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\r\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\r\n\r\n        allowances[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @return the total amount of shares in existence.\r\n     */\r\n    function _getTotalShares() internal view returns (uint256) {\r\n        return totalShares;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of shares owned by `_account`.\r\n     */\r\n    function _sharesOf(address _account) internal view returns (uint256) {\r\n        return shares[_account];\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_sender` cannot be the zero address.\r\n     * - `_recipient` cannot be the zero address.\r\n     * - `_sender` must hold at least `_sharesAmount` shares.\r\n     * - the contract must not be paused.\r\n     */\r\n    function _transferShares(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _sharesAmount\r\n    ) internal {\r\n        require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\r\n        require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\r\n\r\n        uint256 currentSenderShares = shares[_sender];\r\n        require(\r\n            _sharesAmount <= currentSenderShares,\r\n            \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\"\r\n        );\r\n\r\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\r\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\r\n     * @dev This doesn't increase the token total supply.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_recipient` cannot be the zero address.\r\n     * - the contract must not be paused.\r\n     */\r\n    function _mintShares(\r\n        address _recipient,\r\n        uint256 _sharesAmount\r\n    ) internal returns (uint256 newTotalShares) {\r\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\r\n\r\n        newTotalShares = _getTotalShares().add(_sharesAmount);\r\n        totalShares = newTotalShares;\r\n\r\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\r\n\r\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\r\n        // works by taking the amount of tokens corresponding to the minted shares from all other\r\n        // token holders, proportionally to their share. The total supply of the token doesn't change\r\n        // as the result. This is equivalent to performing a send from each other token holder's\r\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\r\n        // number of events.\r\n    }\r\n\r\n    /**\r\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\r\n     * @dev This doesn't decrease the token total supply.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_account` cannot be the zero address.\r\n     * - `_account` must hold at least `_sharesAmount` shares.\r\n     * - the contract must not be paused.\r\n     */\r\n    function _burnShares(\r\n        address _account,\r\n        uint256 _sharesAmount\r\n    ) internal returns (uint256 newTotalShares) {\r\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\r\n\r\n        uint256 accountShares = shares[_account];\r\n        require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\r\n\r\n        uint256 preRebaseTokenAmount = getMintedEUSDByShares(_sharesAmount);\r\n\r\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\r\n        totalShares = newTotalShares;\r\n\r\n        shares[_account] = accountShares.sub(_sharesAmount);\r\n\r\n        uint256 postRebaseTokenAmount = getMintedEUSDByShares(_sharesAmount);\r\n\r\n        emit SharesBurnt(\r\n            _account,\r\n            preRebaseTokenAmount,\r\n            postRebaseTokenAmount,\r\n            _sharesAmount\r\n        );\r\n\r\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\r\n        // works by redistributing the amount of tokens corresponding to the burned shares between\r\n        // all other token holders. The total supply of the token doesn't change as the result.\r\n        // This is equivalent to performing a send from `address` to each other token holder address,\r\n        // but we cannot reflect this as it would require sending an unbounded number of events.\r\n\r\n        // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\r\n    }\r\n}"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}"
    },
    "contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}