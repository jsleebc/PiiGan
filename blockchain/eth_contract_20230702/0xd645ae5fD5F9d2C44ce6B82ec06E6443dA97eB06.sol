{{
  "language": "Solidity",
  "sources": {
    "contracts/Transferly.sol": {
      "content": "\n/*\n\nTRANSFERLY\n\nWebsite: \nhttps://www.transferly.tech/\n\n*/\n\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.18;\n\ninterface IERC20 {\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function totalSupply() external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Permit is IERC20 {\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\ncontract Ownable {\n  address private _owner;\n  address private _previousOwner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\n    _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n}\n\ninterface IUniswapV2Factory {\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function factory() external pure returns (address);\n  function WETH() external pure returns (address);\n}\n\ninterface ITransferly {\n  error AmountExceedAllowance();\n  error ExpiredDeadline();\n  error InvalidSignature();\n  error ZeroAddress();\n  error TradingClose();\n  error MaxTx();\n}\n\ncontract Transferly is ITransferly, IERC20Permit, Ownable {\n  /*///////////////////////////////////////////////////////////////\n                            Mappings\n  //////////////////////////////////////////////////////////////*/\n  mapping(address => uint256) private _balance;\n  mapping(address => mapping(address => uint256)) private _allowances;\n  mapping(address => bool) private _walletExcluded;\n  mapping(address => uint256) public nonces;\n\n  /*///////////////////////////////////////////////////////////////\n                            Constants\n  //////////////////////////////////////////////////////////////*/\n  string public constant name = \"Transferly\";\n  string public constant symbol = \"TFY\";\n  uint8 public constant decimals = 18;\n  uint256 public constant totalSupply = 10 ** 7 * 10 ** decimals;\n  uint256 public constant MIN_SWAP = 4000 * 10 ** decimals; // MINSWAP = 0,04%\n  uint256 private constant _ONE_PERCENT = 100_000 * 10 ** decimals;\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  /*///////////////////////////////////////////////////////////////\n                        Private State Variables\n  //////////////////////////////////////////////////////////////*/\n  address payable private _treasuryAddress;\n  IUniswapV2Router02 private _uniswapV2Router;\n  uint256 private _launchBlock;\n  uint256 private _tax;\n  bool private _launch = false;\n  uint256 private _buyValue = 0;\n\n  /*///////////////////////////////////////////////////////////////\n                        Public State Variables\n  //////////////////////////////////////////////////////////////*/\n  uint256 public buyTax = 25;\n  uint256 public sellTax = 60;\n  uint256 public maxTxAmount = _ONE_PERCENT * 2;\n  address public uniswapV2Pair;\n  bytes32 public DOMAIN_SEPARATOR;\n\n  /*///////////////////////////////////////////////////////////////\n                            Constructor\n  //////////////////////////////////////////////////////////////*/\n  constructor(address[] memory _wallets) {\n    // Uni info\n    _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n\n    // Treasury address logic\n    _treasuryAddress = payable(_wallets[0]);\n    for (uint256 _i; _i < _wallets.length;) {\n      _walletExcluded[_wallets[_i]] = true;\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Total supply\n    _balance[msg.sender] = totalSupply;\n    _walletExcluded[msg.sender] = true;\n    _walletExcluded[address(this)] = true;\n\n    // Emit\n    emit Transfer(address(0), _msgSender(), totalSupply);\n\n    // Assembly low gas get chain\n    uint256 _chainId;\n    assembly {\n      _chainId := chainid()\n    }\n\n    // Domain separator hash\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256(bytes(name)),\n        keccak256('1'),\n        _chainId,\n        address(this)\n      )\n    );\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                        External Functions\n  //////////////////////////////////////////////////////////////*/\n  function balanceOf(address _account) public view override returns (uint256 _amount) {\n    _amount = _balance[_account];\n  }\n\n  function transfer(address _recipient, uint256 _amount) public override returns (bool _result) {\n    _transfer(_msgSender(), _recipient, _amount);\n    _result = true;\n  }\n\n  function allowance(address _owner, address _spender) public view override returns (uint256 _amount) {\n    _amount = _allowances[_owner][_spender];\n  }\n\n  function approve(address _spender, uint256 _amount) public override returns (bool _result) {\n    _approve(_msgSender(), _spender, _amount);\n    _result = true;\n  }\n\n  function transferFrom(address _sender, address _recipient, uint256 _amount) public override returns (bool _result) {\n    _transfer(_sender, _recipient, _amount);\n\n    if (_amount > _allowances[_sender][_msgSender()]) revert AmountExceedAllowance();\n    _approve(_sender, _msgSender(), _amount);\n    _result = true;\n  }\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external override {\n    if (block.timestamp > _deadline) revert ExpiredDeadline();\n\n    bytes32 _structHash = keccak256(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _deadline));\n    bytes32 _hash = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, _structHash));\n    address _signer = ecrecover(_hash, _v, _r, _s);\n    if (_signer != _owner) revert InvalidSignature();\n\n    _approve(_owner, _spender, _value);\n  }\n\n  function enableTrading() external onlyOwner {\n    _launch = true;\n    _launchBlock = block.number;\n  }\n\n  function addExcludedWallet(address _wallet) external onlyOwner {\n    _walletExcluded[_wallet] = true;\n  }\n\n  function removeLimits() external onlyOwner {\n    maxTxAmount = totalSupply;\n  }\n\n  function changeTax(uint256 _newBuyTax, uint256 _newSellTax) external onlyOwner {\n    buyTax = _newBuyTax;\n    sellTax = _newSellTax;\n  }\n\n  function changeBuyValue(uint256 newBuyValue) external onlyOwner {\n    _buyValue = newBuyValue;\n  }\n\n  function manualSendBalance() external {\n    if (msg.sender != _treasuryAddress) revert();\n    uint256 _contractETHBalance = address(this).balance;\n    _treasuryAddress.transfer(_contractETHBalance);\n\n    uint256 _contractBalance = balanceOf(address(this));\n    _treasuryAddress.transfer(_contractBalance);\n  }\n\n  function manualSwapTokens() external {\n    if (msg.sender != _treasuryAddress) revert();\n    uint256 _contractBalance = balanceOf(address(this));\n    _swapTokensForEth(_contractBalance);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                        Private Functions\n  //////////////////////////////////////////////////////////////*/\n  function _approve(address _owner, address _spender, uint256 _amount) private {\n    if (_owner == address(0) || _spender == address(0)) revert ZeroAddress();\n    _allowances[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  function _tokenTransfer(address _from, address _to, uint256 _amount) private {\n    uint256 _taxTokens = (_amount * _tax) / 100;\n    uint256 _transferAmount = _amount - _taxTokens;\n\n    _balance[_from] = _balance[_from] - _amount;\n    _balance[_to] = _balance[_to] + _transferAmount;\n    _balance[address(this)] = _balance[address(this)] + _taxTokens;\n\n    emit Transfer(_from, _to, _transferAmount);\n  }\n\n  function _transfer(address _from, address _to, uint256 _amount) private {\n    if (_from == address(0)) revert ZeroAddress();\n\n    if (_walletExcluded[_from] || _walletExcluded[_to]) {\n      _tax = 0;\n    } else {\n      require(_launch, \"Trading not open\");\n      require(_amount <= maxTxAmount, \"MaxTx Enabled at launch\");\n      // DEATHBLOCKS 3 BLOCKS AFTER LAUNCH\n      if (block.number < _launchBlock + _buyValue + 2) {\n        _tax = 99;\n      } else {\n        if (_from == uniswapV2Pair) {\n          _tax = buyTax;\n        } else if (_to == uniswapV2Pair) {\n          uint256 _tokensToSwap = balanceOf(address(this));\n          if (_tokensToSwap > MIN_SWAP) {\n            if (_tokensToSwap > _ONE_PERCENT * 4) {\n              _tokensToSwap = _ONE_PERCENT * 4;\n            }\n            _swapTokensForEth(_tokensToSwap);\n          }\n          _tax = sellTax;\n        } else {\n          _tax = 0;\n        }\n      }\n    }\n    _tokenTransfer(_from, _to, _amount);\n  }\n\n  function _swapTokensForEth(uint256 _tokenAmount) private {\n    address[] memory _path = new address[](2);\n    _path[0] = address(this);\n    _path[1] = _uniswapV2Router.WETH();\n    _approve(address(this), address(_uniswapV2Router), _tokenAmount);\n    _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      _tokenAmount, 0, _path, _treasuryAddress, block.timestamp\n    );\n  }\n\n  receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}