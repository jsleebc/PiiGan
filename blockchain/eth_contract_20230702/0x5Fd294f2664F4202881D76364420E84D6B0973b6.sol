{{
  "language": "Solidity",
  "sources": {
    "contracts/peakypepe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n    unchecked {\n        _approve(sender, _msgSender(), currentAllowance - amount);\n    }\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n    }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n        _balances[sender] = senderBalance - amount;\n    }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IDexRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n    external\n    payable\n    returns (\n        uint256 amountToken,\n        uint256 amountETH,\n        uint256 liquidity\n    );\n}\n\ninterface IDexFactory {\n    function createPair(address tokenA, address tokenB)\n    external\n    returns (address pair);\n}\n\ncontract PeakyPepe is ERC20, Ownable {\n\n    uint256 public minBuyAmount;\n    uint256 public maxWalletAmount;\n\n    IDexRouter public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n\n    bool private swapping;\n    uint256 public swapTokensAtAmount;\n\n    address private TreasuryAddress;\n    address private RewardsAddress;\n\n    uint256 public deadBlocks = 2;\n\n    bool public limitsInEffect = true;\n    bool public tradingActive = false;\n    bool public swapEnabled = false;\n\n    uint256 public buyTotalFees;\n    uint256 public buyTreasuryFee;\n    uint256 public buyLiquidityFee;\n    uint256 public buyRewardsFee;\n\n    uint256 public sellTotalFees;\n    uint256 public sellTreasuryFee;\n    uint256 public sellLiquidityFee;\n    uint256 public sellRewardsFee;\n\n    uint256 public tokensForTreasury;\n    uint256 public tokensForLiquidity;\n    uint256 public tokensForRewards;\n\n\n    // exlcude from fees and max transaction amount\n    mapping (address => bool) private _isExcludedFromFees;\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\n\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n    // could be subject to a maximum transfer amount\n    mapping (address => bool) public automatedMarketMakerPairs;\n    mapping (address => bool) private _isSniper;\n\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n    event EnabledTrading(bool tradingActive, uint256 deadBlocks);\n    event RemovedLimits();\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n\n    event UpdatedMinBuyAmount(uint256 newAmount);\n\n    event UpdatedMaxWalletAmount(uint256 newAmount);\n\n    event UpdatedTreasuryAddress(address indexed newWallet);\n\n    event UpdatedRewardsAddress(address indexed newWallet);\n\n    event MaxTransactionExclusion(address _address, bool excluded);\n\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiquidity\n    );\n\n    event TransferForeignToken(address token, uint256 amount);\n\n\n    constructor() ERC20(\"Peaky Pepe\", \"PEAKY\") {\n\n        address newOwner = msg.sender; \n\n        IDexRouter _uniswapV2Router = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n        _excludeFromMaxTransaction(address(_uniswapV2Router), true);\n        uniswapV2Router = _uniswapV2Router;\n\n        uniswapV2Pair = IDexFactory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n\n        uint256 totalSupply = 420696969696969 * 1e18;\n\n        minBuyAmount = totalSupply *  50 / 10000;\n        maxWalletAmount = totalSupply * 90 / 10000;\n        swapTokensAtAmount = totalSupply * 50 / 100000; \n\n        buyTreasuryFee = 10;\n        buyLiquidityFee = 0;\n        buyRewardsFee = 0;\n        buyTotalFees = buyTreasuryFee + buyLiquidityFee + buyRewardsFee;\n\n        sellTreasuryFee = 30;\n        sellLiquidityFee = 10;\n        sellRewardsFee = 0;\n        sellTotalFees = sellTreasuryFee + sellLiquidityFee + sellRewardsFee;\n\n        _excludeFromMaxTransaction(newOwner, true);\n        _excludeFromMaxTransaction(address(this), true);\n        _excludeFromMaxTransaction(address(0xdead), true);\n\n        TreasuryAddress = address(0x592a32B40cb23b69f24a3caa079F1F44eCA09435);\n        RewardsAddress = address(0x592a32B40cb23b69f24a3caa079F1F44eCA09435);\n\n        excludeFromFees(newOwner, true);\n        excludeFromFees(address(this), true);\n        excludeFromFees(address(0xdead), true);\n\n        _createInitialSupply(newOwner, totalSupply);\n        transferOwnership(newOwner);\n    }\n\n    receive() external payable {}\n\n    function updateMinBuyAmount(uint256 newNum) external onlyOwner {\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \"Cannot set max buy amount lower than 0.1%\");\n        minBuyAmount = newNum * (10**18);\n        emit UpdatedMinBuyAmount(minBuyAmount);\n    }\n    \n    // remove limits after token is stable\n    function removeLimits() external onlyOwner {\n        limitsInEffect = false;\n        emit RemovedLimits();\n    }\n\n\n    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\n        emit MaxTransactionExclusion(updAds, isExcluded);\n    }\n\n    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {\n        if(!isEx){\n            require(updAds != uniswapV2Pair, \"Cannot remove uniswap pair from max txn\");\n        }\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\n    }\n\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\n        require(newNum >= (totalSupply() * 3 / 1000)/1e18, \"Cannot set max wallet amount lower than 0.3%\");\n        maxWalletAmount = newNum * (10**18);\n        emit UpdatedMaxWalletAmount(maxWalletAmount);\n    }\n\n    // change the minimum amount of tokens to sell from fees\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\n        swapTokensAtAmount = newAmount;\n    }\n\n    \n\n    function updateBuyFees(uint256 _treasuryFee, uint256 _liquidityFee, uint256 _rewardsFee) external onlyOwner {\n        buyTreasuryFee = _treasuryFee;\n        buyLiquidityFee = _liquidityFee;\n        buyRewardsFee = _rewardsFee;\n        buyTotalFees = buyTreasuryFee + buyLiquidityFee + buyRewardsFee;\n        require(buyTotalFees <= 15, \"Must keep fees at 15% or less\");\n    }\n\n    function updateSellFees(uint256 _treasuryFee, uint256 _liquidityFee, uint256 _rewardsFee) external onlyOwner {\n        sellTreasuryFee = _treasuryFee;\n        sellLiquidityFee = _liquidityFee;\n        sellRewardsFee = _rewardsFee;\n        sellTotalFees = sellTreasuryFee + sellLiquidityFee + sellRewardsFee;\n        require(sellTotalFees <= 30, \"Must keep fees at 30% or less\");\n    }\n\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        _isExcludedFromFees[account] = excluded;\n        emit ExcludeFromFees(account, excluded);\n    }\n\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"amount must be greater than 0\");\n        require(!_isSniper[from], \"You are a sniper, get life!\");\n        require(!_isSniper[to], \"You are a sniper, get life!\");\n\n\n        if(limitsInEffect){\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead)){\n                if(!tradingActive){\n                    require(_isExcludedMaxTransactionAmount[from] || _isExcludedMaxTransactionAmount[to], \"Trading is not active.\");\n                    require(from == owner(), \"Trading is enabled\");\n                }\n\n                //when buy\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    require(amount >= minBuyAmount, \"Buy transfer amount doesnt exceed the min buy.\");\n                    require(amount + balanceOf(to) <= maxWalletAmount, \"Cannot Exceed max wallet\");\n                }\n                else if (!_isExcludedMaxTransactionAmount[to] && !_isExcludedMaxTransactionAmount[from]){\n                    require(amount + balanceOf(to) <= maxWalletAmount, \"Cannot Exceed max wallet\");\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n            swapping = true;\n\n            swapBack();\n\n            swapping = false;\n        }\n\n        bool takeFee = true;\n        // if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n\n        uint256 fees = 0;\n        uint256 penaltyAmount = 0;\n        // only take fees on Trades, not on wallet transfers\n\n        if(takeFee){\n            // on sell\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\n                fees = amount * sellTotalFees /100;\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\n                tokensForRewards += fees * sellRewardsFee / sellTotalFees;\n            }\n            // on buy\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n                fees = amount * buyTotalFees / 100;\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\n                tokensForRewards += fees * buyRewardsFee / buyTotalFees;\n            }\n\n            if(fees > 0){\n                super._transfer(from, address(this), fees);\n            }\n\n            amount -= fees + penaltyAmount;\n        }\n\n        super._transfer(from, to, amount);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\n        require(pair != uniswapV2Pair, \"The pair cannot be removed from automatedMarketMakerPairs\");\n\n        _setAutomatedMarketMakerPair(pair, value);\n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        automatedMarketMakerPairs[pair] = value;\n\n        _excludeFromMaxTransaction(pair, value);\n\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n\n    // once enabled, can never be turned off\n    function enableTrading(uint256 _deadBlocks) external onlyOwner {\n        require(!tradingActive, \"Cannot re enable trading\");\n        tradingActive = true;\n        swapEnabled = true;\n        deadBlocks = _deadBlocks;\n        emit EnabledTrading(tradingActive, _deadBlocks);\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // add the liquidity\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            address(owner()),\n            block.timestamp\n        );\n    }\n\n    function transferForeignToken(address _token, address _to) external onlyOwner returns (bool _sent) {\n        require(_token != address(0), \"_token address cannot be 0\");\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\n        emit TransferForeignToken(_token, _contractBalance);\n    }\n\n    // withdraw ETH if stuck or someone sends to the address\n    function withdrawStuckETH() external onlyOwner {\n        bool success;\n        (success,) = address(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n    function setTreasuryAddress(address _TreasuryAddress) external onlyOwner {\n        require(_TreasuryAddress != address(0), \"_TreasuryAddress address cannot be 0\");\n        TreasuryAddress = payable(_TreasuryAddress);\n        emit UpdatedTreasuryAddress(_TreasuryAddress);\n    }\n\n    function setRewardsAddress(address _RewardsAddress) external onlyOwner {\n        require(_RewardsAddress != address(0), \"_RewardsAddress address cannot be 0\");\n        RewardsAddress = payable(_RewardsAddress);\n        emit UpdatedRewardsAddress(_RewardsAddress);\n    }\n\n    function manage_Snipers(address[] calldata addresses, bool status) public onlyOwner {\n        for (uint256 i; i < addresses.length; ++i) {\n                _isSniper[addresses[i]] = status;\n        }\n    }\n\n    function isSniper(address account) public view returns (bool) {\n        return _isSniper[account];\n    }\n\n   \n    function swapBack() private {\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForTreasury + tokensForRewards;\n\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\n\n        if(contractBalance > swapTokensAtAmount * 10){\n            contractBalance = swapTokensAtAmount * 10;\n        }\n\n        bool success;\n\n        // Halve the amount of liquidity tokens\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\n\n        swapTokensForEth(contractBalance - liquidityTokens);\n\n        uint256 ethBalance = address(this).balance;\n        uint256 ethForLiquidity = ethBalance;\n\n        uint256 ethForTreasury = ethBalance * tokensForTreasury / (totalTokensToSwap - (tokensForLiquidity/2));\n        uint256 ethForRewards = ethBalance * tokensForRewards / (totalTokensToSwap - (tokensForLiquidity/2));\n\n        ethForLiquidity -= ethForTreasury + ethForRewards;\n\n        tokensForLiquidity = 0;\n        tokensForTreasury = 0;\n        tokensForRewards = 0;\n\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\n            addLiquidity(liquidityTokens, ethForLiquidity);\n        }\n\n        (success,) = address(RewardsAddress).call{value: ethForRewards}(\"\");\n\n        (success,) = address(TreasuryAddress).call{value: address(this).balance}(\"\");\n    }\n\n   \n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}