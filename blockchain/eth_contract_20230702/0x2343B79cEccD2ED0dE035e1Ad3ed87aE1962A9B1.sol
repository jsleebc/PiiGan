{{
  "language": "Solidity",
  "sources": {
    "Gonerc.sol": {
      "content": "// t.me/wereallgoners\n// https://twitter.com/GonersGone\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.9;\n\nabstract contract Context {\nfunction _msgSender() internal view virtual returns (address) {\nreturn msg.sender;\n}\n}\n\ninterface IERC20 {\nfunction totalSupply() external view returns (uint256);\n\nfunction balanceOf(address account) external view returns (uint256);\n\nfunction transfer(address recipient, uint256 amount) external returns (bool);\n\nfunction allowance(address owner, address spender) external view returns (uint256);\n\nfunction approve(address spender, uint256 amount) external returns (bool);\n\nfunction transferFrom(\naddress sender,\naddress recipient,\nuint256 amount\n) external returns (bool);\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(\naddress indexed owner,\naddress indexed spender,\nuint256 value\n);\n}\n\ncontract Ownable is Context {\naddress private _owner;\naddress private _previousOwner;\nevent OwnershipTransferred(\naddress indexed previousOwner,\naddress indexed newOwner\n);\n\nconstructor() {\naddress msgSender = _msgSender();\n_owner = msgSender;\nemit OwnershipTransferred(address(0), msgSender);\n}\n\nfunction owner() public view returns (address) {\nreturn _owner;\n}\n\nmodifier onlyOwner() {\nrequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n_;\n}\n\nfunction renounceOwnership() public virtual onlyOwner {\nemit OwnershipTransferred(_owner, address(0));\n_owner = address(0);\n}\n\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\nemit OwnershipTransferred(_owner, newOwner);\n_owner = newOwner;\n}\n\n}\n\nlibrary SafeMath {\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c >= a, \"SafeMath: addition overflow\");\nreturn c;\n}\n\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nreturn sub(a, b, \"SafeMath: subtraction overflow\");\n}\n\nfunction sub(\nuint256 a,\nuint256 b,\nstring memory errorMessage\n) internal pure returns (uint256) {\nrequire(b <= a, errorMessage);\nuint256 c = a - b;\nreturn c;\n}\n\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\nif (a == 0) {\nreturn 0;\n}\nuint256 c = a * b;\nrequire(c / a == b, \"SafeMath: multiplication overflow\");\nreturn c;\n}\n\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\nreturn div(a, b, \"SafeMath: division by zero\");\n}\n\nfunction div(\nuint256 a,\nuint256 b,\nstring memory errorMessage\n) internal pure returns (uint256) {\nrequire(b > 0, errorMessage);\nuint256 c = a / b;\nreturn c;\n}\n}\n\ninterface IUniswapV2Factory {\nfunction createPair(address tokenA, address tokenB)\nexternal\nreturns (address pair);\n}\n\ninterface IUniswapV2Router02 {\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\nuint256 amountIn,\nuint256 amountOutMin,\naddress[] calldata path,\naddress to,\nuint256 deadline\n) external;\n\nfunction factory() external pure returns (address);\n\nfunction WETH() external pure returns (address);\n\nfunction addLiquidityETH(\naddress token,\nuint256 amountTokenDesired,\nuint256 amountTokenMin,\nuint256 amountETHMin,\naddress to,\nuint256 deadline\n)\nexternal\npayable\nreturns (\nuint256 amountToken,\nuint256 amountETH,\nuint256 liquidity\n);\n}\n\ncontract Goner is Context, IERC20, Ownable {\n\nusing SafeMath for uint256;\n\nstring private constant _name = \"GONER\";\nstring private constant _symbol = \"GONER\";\nuint8 private constant _decimals = 9;\n\nmapping(address => uint256) private _rOwned;\nmapping(address => uint256) private _tOwned;\nmapping(address => mapping(address => uint256)) private _allowances;\nmapping(address => bool) private _isExcludedFromFee;\nuint256 private constant MAX = ~uint256(0);\nuint256 private constant _tTotal = 6942000000 * 10**9;\nuint256 private _rTotal = (MAX - (MAX % _tTotal));\nuint256 private _tFeeTotal;\nuint256 private _redisFeeOnBuy = 0;\nuint256 private _taxFeeOnBuy = 0;\nuint256 private _redisFeeOnSell = 0;\nuint256 private _taxFeeOnSell = 0;\n\n//Original Goner Fee\nuint256 private _redisFee = _redisFeeOnSell;\nuint256 private _taxFee = _taxFeeOnSell;\n\nuint256 private _previousredisFee = _redisFee;\nuint256 private _previoustaxFee = _taxFee;\n\nmapping(address => bool) public bots; mapping (address => uint256) public _buyMap;\naddress payable private _developmentAddress = payable(0x3E465F636D9ef324166Bcfc33251ee0A8ea37E17);\naddress payable private _marketingAddress = payable(0x7038CB19740b38BcD44ECe3563ED8ef6867c6d25);\n\nIUniswapV2Router02 public uniswapV2Router;\naddress public uniswapV2Pair;\n\nbool private tradingOpen = true;\nbool private inSwap = false;\nbool private swapEnabled = true;\n\nuint256 public _maxTxAmount = 20000000 * 10**9;\nuint256 public _maxWalletSize = 20000000 * 10**9;\nuint256 public _swapTokensAtAmount = 10000000 * 10**9;\n\nevent MaxTxAmountUpdated(uint256 _maxTxAmount);\nmodifier lockTheSwap {\ninSwap = true;\n_;\ninSwap = false;\n}\n\nconstructor() {\n\n_rOwned[_msgSender()] = _rTotal;\n\nIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);//\nuniswapV2Router = _uniswapV2Router;\nuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n.createPair(address(this), _uniswapV2Router.WETH());\n\n_isExcludedFromFee[owner()] = true;\n_isExcludedFromFee[address(this)] = true;\n_isExcludedFromFee[_developmentAddress] = true;\n_isExcludedFromFee[_marketingAddress] = true;\n\nemit Transfer(address(0), _msgSender(), _tTotal);\n}\n\nfunction name() public pure returns (string memory) {\nreturn _name;\n}\n\nfunction symbol() public pure returns (string memory) {\nreturn _symbol;\n}\n\nfunction decimals() public pure returns (uint8) {\nreturn _decimals;\n}\n\nfunction totalSupply() public pure override returns (uint256) {\nreturn _tTotal;\n}\n\nfunction balanceOf(address account) public view override returns (uint256) {\nreturn tokenFromReflection(_rOwned[account]);\n}\n\nfunction transfer(address recipient, uint256 amount)\npublic\noverride\nreturns (bool)\n{\n_transfer(_msgSender(), recipient, amount);\nreturn true;\n}\n\nfunction allowance(address owner, address spender)\npublic\nview\noverride\nreturns (uint256)\n{\nreturn _allowances[owner][spender];\n}\n\nfunction approve(address spender, uint256 amount)\npublic\noverride\nreturns (bool)\n{\n_approve(_msgSender(), spender, amount);\nreturn true;\n}\n\nfunction transferFrom(\naddress sender,\naddress recipient,\nuint256 amount\n) public override returns (bool) {\n_transfer(sender, recipient, amount);\n_approve(\nsender,\n_msgSender(),\n_allowances[sender][_msgSender()].sub(\namount,\n\"ERC20: transfer amount exceeds allowance\"\n)\n);\nreturn true;\n}\n\nfunction tokenFromReflection(uint256 rAmount)\nprivate\nview\nreturns (uint256)\n{\nrequire(\nrAmount <= _rTotal,\n\"Amount must be less than total reflections\"\n);\nuint256 currentRate = _getRate();\nreturn rAmount.div(currentRate);\n}\n\nfunction removeAllFee() private {\nif (_redisFee == 0 && _taxFee == 0) return;\n\n_previousredisFee = _redisFee;\n_previoustaxFee = _taxFee;\n\n_redisFee = 0;\n_taxFee = 0;\n}\n\nfunction restoreAllFee() private {\n_redisFee = _previousredisFee;\n_taxFee = _previoustaxFee;\n}\n\nfunction _approve(\naddress owner,\naddress spender,\nuint256 amount\n) private {\nrequire(owner != address(0), \"ERC20: approve from the zero address\");\nrequire(spender != address(0), \"ERC20: approve to the zero address\");\n_allowances[owner][spender] = amount;\nemit Approval(owner, spender, amount);\n}\n\nfunction _transfer(\naddress from,\naddress to,\nuint256 amount\n) private {\nrequire(from != address(0), \"ERC20: transfer from the zero address\");\nrequire(to != address(0), \"ERC20: transfer to the zero address\");\nrequire(amount > 0, \"Transfer amount must be greater than zero\");\n\nif (from != owner() && to != owner()) {\n\n//Trade start check\nif (!tradingOpen) {\nrequire(from == owner(), \"TOKEN: This account cannot send tokens until trading is enabled\");\n}\n\nrequire(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\nrequire(!bots[from] && !bots[to], \"TOKEN: Your account is blacklisted!\");\n\nif(to != uniswapV2Pair) {\nrequire(balanceOf(to) + amount < _maxWalletSize, \"TOKEN: Balance exceeds wallet size!\");\n}\n\nuint256 contractTokenBalance = balanceOf(address(this));\nbool canSwap = contractTokenBalance >= _swapTokensAtAmount;\n\nif(contractTokenBalance >= _maxTxAmount)\n{\ncontractTokenBalance = _maxTxAmount;\n}\n\nif (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\nswapTokensForEth(contractTokenBalance);\nuint256 contractETHBalance = address(this).balance;\nif (contractETHBalance > 0) {\nsendETHToFee(address(this).balance);\n}\n}\n}\n\nbool takeFee = true;\n\n//Transfer Tokens\nif ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {\ntakeFee = false;\n} else {\n\n//Set Fee for Buys\nif(from == uniswapV2Pair && to != address(uniswapV2Router)) {\n_redisFee = _redisFeeOnBuy;\n_taxFee = _taxFeeOnBuy;\n}\n\n//Set Fee for Sells\nif (to == uniswapV2Pair && from != address(uniswapV2Router)) {\n_redisFee = _redisFeeOnSell;\n_taxFee = _taxFeeOnSell;\n}\n\n}\n\n_tokenTransfer(from, to, amount, takeFee);\n}\n\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\naddress[] memory path = new address[](2);\npath[0] = address(this);\npath[1] = uniswapV2Router.WETH();\n_approve(address(this), address(uniswapV2Router), tokenAmount);\nuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\ntokenAmount,\n0,\npath,\naddress(this),\nblock.timestamp\n);\n}\n\nfunction sendETHToFee(uint256 amount) private {\n_marketingAddress.transfer(amount);\n}\n\nfunction setTrading(bool _tradingOpen) public onlyOwner {\ntradingOpen = _tradingOpen;\n}\n\nfunction manualswap() external {\nrequire(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\nuint256 contractBalance = balanceOf(address(this));\nswapTokensForEth(contractBalance);\n}\n\nfunction manualsend() external {\nrequire(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\nuint256 contractETHBalance = address(this).balance;\nsendETHToFee(contractETHBalance);\n}\n\nfunction blockBots(address[] memory bots_) public onlyOwner {\nfor (uint256 i = 0; i < bots_.length; i++) {\nbots[bots_[i]] = true;\n}\n}\n\nfunction unblockBot(address notbot) public onlyOwner {\nbots[notbot] = false;\n}\n\nfunction _tokenTransfer(\naddress sender,\naddress recipient,\nuint256 amount,\nbool takeFee\n) private {\nif (!takeFee) removeAllFee();\n_transferStandard(sender, recipient, amount);\nif (!takeFee) restoreAllFee();\n}\n\nfunction _transferStandard(\naddress sender,\naddress recipient,\nuint256 tAmount\n) private {\n(\nuint256 rAmount,\nuint256 rTransferAmount,\nuint256 rFee,\nuint256 tTransferAmount,\nuint256 tFee,\nuint256 tTeam\n) = _getValues(tAmount);\n_rOwned[sender] = _rOwned[sender].sub(rAmount);\n_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n_takeTeam(tTeam);\n_reflectFee(rFee, tFee);\nemit Transfer(sender, recipient, tTransferAmount);\n}\n\nfunction _takeTeam(uint256 tTeam) private {\nuint256 currentRate = _getRate();\nuint256 rTeam = tTeam.mul(currentRate);\n_rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n}\n\nfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n_rTotal = _rTotal.sub(rFee);\n_tFeeTotal = _tFeeTotal.add(tFee);\n}\n\nreceive() external payable {}\n\nfunction _getValues(uint256 tAmount)\nprivate\nview\nreturns (\nuint256,\nuint256,\nuint256,\nuint256,\nuint256,\nuint256\n)\n{\n(uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\n_getTValues(tAmount, _redisFee, _taxFee);\nuint256 currentRate = _getRate();\n(uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\n_getRValues(tAmount, tFee, tTeam, currentRate);\nreturn (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n}\n\nfunction _getTValues(\nuint256 tAmount,\nuint256 redisFee,\nuint256 taxFee\n)\nprivate\npure\nreturns (\nuint256,\nuint256,\nuint256\n)\n{\nuint256 tFee = tAmount.mul(redisFee).div(100);\nuint256 tTeam = tAmount.mul(taxFee).div(100);\nuint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\nreturn (tTransferAmount, tFee, tTeam);\n}\n\nfunction _getRValues(\nuint256 tAmount,\nuint256 tFee,\nuint256 tTeam,\nuint256 currentRate\n)\nprivate\npure\nreturns (\nuint256,\nuint256,\nuint256\n)\n{\nuint256 rAmount = tAmount.mul(currentRate);\nuint256 rFee = tFee.mul(currentRate);\nuint256 rTeam = tTeam.mul(currentRate);\nuint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\nreturn (rAmount, rTransferAmount, rFee);\n}\n\nfunction _getRate() private view returns (uint256) {\n(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\nreturn rSupply.div(tSupply);\n}\n\nfunction _getCurrentSupply() private view returns (uint256, uint256) {\nuint256 rSupply = _rTotal;\nuint256 tSupply = _tTotal;\nif (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\nreturn (rSupply, tSupply);\n}\n\nfunction setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\n_redisFeeOnBuy = redisFeeOnBuy;\n_redisFeeOnSell = redisFeeOnSell;\n_taxFeeOnBuy = taxFeeOnBuy;\n_taxFeeOnSell = taxFeeOnSell;\n}\n\n//Set minimum tokens required to swap.\nfunction setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {\n_swapTokensAtAmount = swapTokensAtAmount;\n}\n\n//Set minimum tokens required to swap.\nfunction toggleSwap(bool _swapEnabled) public onlyOwner {\nswapEnabled = _swapEnabled;\n}\n\n//Set maximum transaction\nfunction setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n_maxTxAmount = maxTxAmount;\n}\n\nfunction setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n_maxWalletSize = maxWalletSize;\n}\n\nfunction excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\nfor(uint256 i = 0; i < accounts.length; i++) {\n_isExcludedFromFee[accounts[i]] = excluded;\n}\n}\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}