{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/gauges/AbsGauge.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/ILT.sol\";\nimport \"../interfaces/IGaugeController.sol\";\nimport \"../interfaces/IVotingEscrow.sol\";\nimport \"../interfaces/IMinter.sol\";\nimport \"light-lib/contracts/LibTime.sol\";\n\nabstract contract AbsGauge is Ownable2Step {\n    event Deposit(address indexed provider, uint256 value);\n    event Withdraw(address indexed provider, uint256 value);\n    event UpdateLiquidityLimit(\n        address user,\n        uint256 originalBalance,\n        uint256 originalSupply,\n        uint256 workingBalance,\n        uint256 workingSupply,\n        uint256 votingBalance,\n        uint256 votingTotal\n    );\n    event SetPermit2Address(address oldAddress, address newAddress);\n\n    uint256 internal constant _TOKENLESS_PRODUCTION = 40;\n    uint256 internal constant _DAY = 86400;\n    uint256 internal constant _WEEK = _DAY * 7;\n\n    bool public isKilled;\n    // pool lp token\n    address public lpToken;\n\n    //Contracts\n    IMinter public minter;\n    // lt_token\n    ILT public ltToken;\n    //IERC20 public template;\n    IGaugeController public controller;\n    IVotingEscrow public votingEscrow;\n\n    uint256 public futureEpochTime;\n\n    mapping(address => uint256) public workingBalances;\n    uint256 public workingSupply;\n\n    // The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n    // All values are kept in units of being multiplied by 1e18\n    uint256 public period; //modified from \"int256 public period\" since it never be minus.\n\n    // uint256[100000000000000000000000000000] public period_timestamp;\n    mapping(uint256 => uint256) public periodTimestamp;\n\n    //uint256[100_000_000_000_000_000_000_000_000_000] public periodTimestamp;\n\n    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\n    // bump epoch when rate() changes\n    mapping(uint256 => uint256) integrateInvSupply;\n\n    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\n    mapping(address => uint256) public integrateInvSupplyOf;\n    mapping(address => uint256) public integrateCheckpointOf;\n\n    // ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n    // Units rate * t = already number of coins per address to issue\n    mapping(address => uint256) public integrateFraction; //Mintable Token amount (include minted amount)\n\n    uint256 public inflationRate;\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    function _init(address _lpAddr, address _minter, address _owner) internal {\n        require(_lpAddr != address(0), \"CE000\");\n        require(_minter != address(0), \"CE000\");\n        require(_owner != address(0), \"CE000\");\n        require(!_initialized, \"Initializable: contract is already initialized\");\n        _initialized = true;\n\n        _transferOwnership(_owner);\n\n        lpToken = _lpAddr;\n        minter = IMinter(_minter);\n        address _ltToken = minter.token();\n        ltToken = ILT(_ltToken);\n        controller = IGaugeController(minter.controller());\n        votingEscrow = IVotingEscrow(controller.votingEscrow());\n        periodTimestamp[0] = block.timestamp;\n        inflationRate = ltToken.rate();\n        futureEpochTime = ltToken.futureEpochTimeWrite();\n    }\n\n    /***\n     * @notice Calculate limits which depend on the amount of lp Token per-user.\n     *        Effectively it calculates working balances to apply amplification\n     *        of LT production by LT\n     * @param _addr User address\n     * @param _l User's amount of liquidity (LP tokens)\n     * @param _L Total amount of liquidity (LP tokens)\n     */\n    function _updateLiquidityLimit(address _addr, uint256 _l, uint256 _L) internal {\n        // To be called after totalSupply is updated\n        uint256 _votingBalance = votingEscrow.balanceOfAtTime(_addr, block.timestamp);\n        uint256 _votingTotal = votingEscrow.totalSupplyAtTime(block.timestamp);\n\n        uint256 _lim = (_l * _TOKENLESS_PRODUCTION) / 100;\n        if (_votingTotal > 0) {\n            // 0.4 * _l + 0.6 * _L * balance/total\n            _lim += (_L * _votingBalance * (100 - _TOKENLESS_PRODUCTION)) / _votingTotal / 100;\n        }\n\n        _lim = Math.min(_l, _lim);\n        uint256 _oldBal = workingBalances[_addr];\n        workingBalances[_addr] = _lim;\n        uint256 _workingSupply = workingSupply + _lim - _oldBal;\n        workingSupply = _workingSupply;\n\n        emit UpdateLiquidityLimit(_addr, _l, _L, _lim, _workingSupply, _votingBalance, _votingTotal);\n    }\n\n    //to avoid \"stack too deep\"\n    struct CheckPointParameters {\n        uint256 _period;\n        uint256 _periodTime;\n        uint256 _integrateInvSupply;\n        uint256 rate;\n        uint256 newRate;\n        uint256 prevFutureEpoch;\n    }\n\n    /***\n     * @notice Checkpoint for a user\n     * @param _addr User address\n     *\n     *This function does,\n     *1. Calculate Iis for All: Calc and add Iis for every week. Iis only increses over time.\n     *2. Calculate Iu for _addr: Calc by (defferece between Iis(last time) and Iis(this time))* LP deposit amount of _addr(include  locking boost)\n     *\n     * working_supply & working_balance = total_supply & total_balance with  locking boost。\n     * Check whitepaper about Iis and Iu.\n     */\n    function _checkpoint(address _addr) internal {\n        CheckPointParameters memory _st;\n\n        _st._period = period;\n        _st._periodTime = periodTimestamp[_st._period];\n        _st._integrateInvSupply = integrateInvSupply[_st._period];\n        _st.rate = inflationRate;\n        _st.newRate = _st.rate;\n        _st.prevFutureEpoch = futureEpochTime;\n        if (_st.prevFutureEpoch >= _st._periodTime) {\n            //update future_epoch_time & inflation_rate\n            futureEpochTime = ltToken.futureEpochTimeWrite();\n            _st.newRate = ltToken.rate();\n            inflationRate = _st.newRate;\n        }\n        controller.checkpointGauge(address(this));\n\n        if (isKilled) {\n            // Stop distributing inflation as soon as killed\n            _st.rate = 0;\n        }\n\n        // Update integral of 1/supply\n        if (block.timestamp > _st._periodTime) {\n            uint256 _workingSupply = workingSupply;\n            uint256 _prevWeekTime = _st._periodTime;\n            uint256 _weekTime = Math.min(LibTime.timesRoundedByWeek(_st._periodTime + _WEEK), block.timestamp);\n            for (uint256 i; i < 500; i++) {\n                uint256 _dt = _weekTime - _prevWeekTime;\n                uint256 _w = controller.gaugeRelativeWeight(address(this), LibTime.timesRoundedByWeek(_prevWeekTime));\n\n                if (_workingSupply > 0) {\n                    if (_st.prevFutureEpoch >= _prevWeekTime && _st.prevFutureEpoch < _weekTime) {\n                        // If we went across one or multiple epochs, apply the rate\n                        // of the first epoch until it ends, and then the rate of\n                        // the last epoch.\n                        // If more than one epoch is crossed - the gauge gets less,\n                        // but that'd meen it wasn't called for more than 1 year\n                        _st._integrateInvSupply += (_st.rate * _w * (_st.prevFutureEpoch - _prevWeekTime)) / _workingSupply;\n                        _st.rate = _st.newRate;\n                        _st._integrateInvSupply += (_st.rate * _w * (_weekTime - _st.prevFutureEpoch)) / _workingSupply;\n                    } else {\n                        _st._integrateInvSupply += (_st.rate * _w * _dt) / _workingSupply;\n                    }\n                    // On precisions of the calculation\n                    // rate ~= 10e18\n                    // last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                    // _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                    // The largest loss is at dt = 1\n                    // Loss is 1e-9 - acceptable\n                }\n                if (_weekTime == block.timestamp) {\n                    break;\n                }\n                _prevWeekTime = _weekTime;\n                _weekTime = Math.min(_weekTime + _WEEK, block.timestamp);\n            }\n        }\n\n        _st._period += 1;\n        period = _st._period;\n        periodTimestamp[_st._period] = block.timestamp;\n        integrateInvSupply[_st._period] = _st._integrateInvSupply;\n\n        uint256 _workingBalance = workingBalances[_addr];\n        // Update user-specific integrals\n        // Calc the ΔIu of _addr and add it to Iu.\n        integrateFraction[_addr] += (_workingBalance * (_st._integrateInvSupply - integrateInvSupplyOf[_addr])) / 10 ** 18;\n        integrateInvSupplyOf[_addr] = _st._integrateInvSupply;\n        integrateCheckpointOf[_addr] = block.timestamp;\n    }\n\n    /***\n     * @notice Record a checkpoint for `_addr`\n     * @param _addr User address\n     * @return bool success\n     */\n    function userCheckpoint(address _addr) external returns (bool) {\n        require((msg.sender == _addr) || (msg.sender == address(minter)), \"GP000\");\n        _checkpoint(_addr);\n        _updateLiquidityLimit(_addr, lpBalanceOf(_addr), lpTotalSupply());\n        return true;\n    }\n\n    /***\n     * @notice Get the number of claimable tokens per user\n     * @dev This function should be manually changed to \"view\" in the ABI\n     * @return uint256 number of claimable tokens per user\n     */\n    function claimableTokens(address _addr) external returns (uint256) {\n        _checkpoint(_addr);\n        return (integrateFraction[_addr] - minter.minted(_addr, address(this)));\n    }\n\n    /***\n     * @notice Kick `_addr` for abusing their boost\n     * @dev Only if either they had another voting event, or their voting escrow lock expired\n     * @param _addr Address to kick\n     */\n    function kick(address _addr) external {\n        uint256 _tLast = integrateCheckpointOf[_addr];\n        uint256 _tVe = votingEscrow.userPointHistoryTs(_addr, votingEscrow.userPointEpoch(_addr));\n        uint256 _balance = lpBalanceOf(_addr);\n\n        require(votingEscrow.balanceOfAtTime(_addr, block.timestamp) == 0 || _tVe > _tLast, \"GP001\");\n        require(workingBalances[_addr] > (_balance * _TOKENLESS_PRODUCTION) / 100, \"GP001\");\n\n        _checkpoint(_addr);\n        _updateLiquidityLimit(_addr, lpBalanceOf(_addr), lpTotalSupply());\n    }\n\n    function integrateCheckpoint() external view returns (uint256) {\n        return periodTimestamp[period];\n    }\n\n    /***\n     * @notice Set the killed status for this contract\n     * @dev When killed, the gauge always yields a rate of 0 and so cannot mint LT\n     * @param _is_killed Killed status to set\n     */\n    function setKilled(bool _isKilled) external onlyOwner {\n        isKilled = _isKilled;\n    }\n\n    /***\n     * @notice The total amount of LP tokens that are currently deposited into the Gauge.\n     */\n    function lpBalanceOf(address _addr) public view virtual returns (uint256);\n\n    /***\n     * @notice The total amount of LP tokens that are currently deposited into the Gauge.\n     */\n    function lpTotalSupply() public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IGaugeController {\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    struct UserPoint {\n        uint256 bias;\n        uint256 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n\n    event AddType(string name, int128 type_id);\n\n    event NewTypeWeight(int128 indexed type_id, uint256 time, uint256 weight, uint256 total_weight);\n\n    event NewGaugeWeight(address indexed gauge_address, uint256 time, uint256 weight, uint256 total_weight);\n\n    event VoteForGauge(address indexed user, address indexed gauge_address, uint256 time, uint256 weight);\n\n    event NewGauge(address indexed gauge_address, int128 gauge_type, uint256 weight);\n\n    /**\n     * @notice Get gauge type for address\n     *  @param _addr Gauge address\n     * @return Gauge type id\n     */\n    function gaugeTypes(address _addr) external view returns (int128);\n\n    /**\n     * @notice Add gauge `addr` of type `gauge_type` with weight `weight`\n     * @param addr Gauge address\n     * @param gaugeType Gauge type\n     * @param weight Gauge weight\n     */\n    function addGauge(address addr, int128 gaugeType, uint256 weight) external;\n\n    /**\n     * @notice Checkpoint to fill data common for all gauges\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Checkpoint to fill data for both a specific gauge and common for all gauge\n     * @param addr Gauge address\n     */\n    function checkpointGauge(address addr) external;\n\n    /**\n     * @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18(e.g. 1.0 == 1e18). Inflation which will be received by\n     * it is inflation_rate * relative_weight / 1e18\n     * @param gaugeAddress Gauge address\n     * @param time Relative weight at the specified timestamp in the past or present\n     * @return Value of relative weight normalized to 1e18\n     */\n    function gaugeRelativeWeight(address gaugeAddress, uint256 time) external view returns (uint256);\n\n    /**\n     *  @notice Get gauge weight normalized to 1e18 and also fill all the unfilled values for type and gauge records\n     * @dev Any address can call, however nothing is recorded if the values are filled already\n     * @param gaugeAddress Gauge address\n     * @param time Relative weight at the specified timestamp in the past or present\n     * @return Value of relative weight normalized to 1e18\n     */\n    function gaugeRelativeWeightWrite(address gaugeAddress, uint256 time) external returns (uint256);\n\n    /**\n     * @notice Add gauge type with name `_name` and weight `weight`\n     * @dev only owner call\n     * @param _name Name of gauge type\n     * @param weight Weight of gauge type\n     */\n    function addType(string memory _name, uint256 weight) external;\n\n    /**\n     * @notice Change gauge type `type_id` weight to `weight`\n     * @dev only owner call\n     * @param type_id Gauge type id\n     * @param weight New Gauge weight\n     */\n    function changeTypeWeight(int128 type_id, uint256 weight) external;\n\n    /**\n     * @notice Change weight of gauge `addr` to `weight`\n     * @param gaugeAddress `Gauge` contract address\n     * @param weight New Gauge weight\n     */\n    function changeGaugeWeight(address gaugeAddress, uint256 weight) external;\n\n    /**\n     * @notice Allocate voting power for changing pool weights\n     * @param gaugeAddress Gauge which `msg.sender` votes for\n     * @param userWeight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0.\n     *        example: 10%=1000,3%=300,0.01%=1,100%=10000\n     */\n    function voteForGaugeWeights(address gaugeAddress, uint256 userWeight) external;\n\n    /**\n     * @notice Get current gauge weight\n     * @param addr Gauge address\n     * @return Gauge weight\n     */\n\n    function getGaugeWeight(address addr) external view returns (uint256);\n\n    /**\n     * @notice Get current type weight\n     * @param type_id Type id\n     * @return Type weight\n     */\n    function getTypeWeight(int128 type_id) external view returns (uint256);\n\n    /**\n     * @notice Get current total (type-weighted) weight\n     * @return Total weight\n     */\n    function getTotalWeight() external view returns (uint256);\n\n    /**\n     * @notice Get sum of gauge weights per type\n     * @param type_id Type id\n     * @return Sum of gauge weights\n     */\n    function getWeightsSumPreType(int128 type_id) external view returns (uint256);\n\n    function votingEscrow() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILT.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface ILT {\n    /**\n     * @dev Emitted when LT inflation rate update\n     *\n     * Note once a year\n     */\n    event UpdateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n\n    /**\n     * @dev Emitted when set LT minter,can set the minter only once, at creation\n     */\n    event SetMinter(address indexed minter);\n\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Update mining rate and supply at the start of the epoch\n     * @dev   Callable by any address, but only once per epoch\n     *        Total supply becomes slightly larger if this function is called late\n     */\n    function updateMiningParameters() external;\n\n    /**\n     * @notice Get timestamp of the next mining epoch start while simultaneously updating mining parameters\n     * @return Timestamp of the next epoch\n     */\n    function futureEpochTimeWrite() external returns (uint256);\n\n    /**\n     * @notice Current number of tokens in existence (claimed or unclaimed)\n     */\n    function availableSupply() external view returns (uint256);\n\n    /**\n     * @notice How much supply is mintable from start timestamp till end timestamp\n     * @param start Start of the time interval (timestamp)\n     * @param end End of the time interval (timestamp)\n     * @return Tokens mintable from `start` till `end`\n     */\n    function mintableInTimeframe(uint256 start, uint256 end) external view returns (uint256);\n\n    /**\n     *  @notice Set the minter address\n     *  @dev Only callable once, when minter has not yet been set\n     *  @param _minter Address of the minter\n     */\n    function setMinter(address _minter) external;\n\n    /**\n     *  @notice Mint `value` tokens and assign them to `to`\n     *   @dev Emits a Transfer event originating from 0x00\n     *   @param to The account that will receive the created tokens\n     *   @param value The amount that will be created\n     *   @return bool success\n     */\n    function mint(address to, uint256 value) external returns (bool);\n\n    /**\n     * @notice Burn `value` tokens belonging to `msg.sender`\n     * @dev Emits a Transfer event with a destination of 0x00\n     * @param value The amount that will be burned\n     * @return bool success\n     */\n    function burn(uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IMinter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IMinter {\n    function token() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function minted(address user, address gauge) external view returns (uint256);\n\n    function mint(address gaugeAddress) external;\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStaking {\n    event Staking(address indexed user, uint256 amount);\n    event Unstaking(address indexed user, uint256 amount);\n    event Redeem(address indexed user, uint256 amount);\n    event RewardsAccrued(address user, uint256 amount);\n    event RewardsClaimed(address indexed user, uint256 amount);\n\n    function staking(uint256 amount, uint256 nonce, uint256 deadline, bytes memory signature) external returns (bool);\n\n    function redeemAll() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IVotingEscrow {\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n\n    struct LockedBalance {\n        int256 amount;\n        uint256 end;\n    }\n\n    event Deposit(\n        address indexed provider,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 afterAmount,\n        uint256 indexed locktime,\n        uint256 _type,\n        uint256 ts\n    );\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\n\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    event SetSmartWalletChecker(address sender, address indexed newChecker, address oldChecker);\n\n    event SetPermit2Address(address oldAddress, address newAddress);\n\n    /***\n     * @dev Get the most recently recorded rate of voting power decrease for `_addr`\n     * @param _addr Address of the user wallet\n     * @return Value of the slope\n     */\n    function getLastUserSlope(address _addr) external view returns (int256);\n\n    /***\n     * @dev Get the timestamp for checkpoint `_idx` for `_addr`\n     * @param _addr User wallet address\n     * @param _idx User epoch number\n     * @return Epoch time of the checkpoint\n     */\n    function userPointHistoryTs(address _addr, uint256 _idx) external view returns (uint256);\n\n    /***\n     * @dev Get timestamp when `_addr`'s lock finishes\n     * @param _addr User wallet\n     * @return Epoch time of the lock end\n     */\n    function lockedEnd(address _addr) external view returns (uint256);\n\n    function createLock(uint256 _value, uint256 _unlockTime, uint256 nonce, uint256 deadline, bytes memory signature) external;\n\n    function createLockFor(\n        address _beneficiary,\n        uint256 _value,\n        uint256 _unlockTime,\n        uint256 nonce,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n\n    function increaseAmount(uint256 _value, uint256 nonce, uint256 deadline, bytes memory signature) external;\n\n    function increaseAmountFor(address _beneficiary, uint256 _value, uint256 nonce, uint256 deadline, bytes memory signature) external;\n\n    function increaseUnlockTime(uint256 _unlockTime) external;\n\n    function checkpointSupply() external;\n\n    function withdraw() external;\n\n    function epoch() external view returns (uint256);\n\n    function getUserPointHistory(address _userAddress, uint256 _index) external view returns (Point memory);\n\n    function supplyPointHistory(uint256 _index) external view returns (int256 bias, int256 slope, uint256 ts, uint256 blk);\n\n    /***\n     * @notice Get the current voting power for `msg.sender`\n     * @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n     * @param _addr User wallet address\n     * @param _t Epoch time to return voting power at\n     * @return User voting power\n     * @dev return the present voting power if _t is 0\n     */\n    function balanceOfAtTime(address _addr, uint256 _t) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalSupplyAtTime(uint256 _t) external view returns (uint256);\n\n    function userPointEpoch(address _user) external view returns (uint256);\n}\n"
    },
    "contracts/StakingHOPE.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/IStaking.sol\";\nimport \"./gauges/AbsGauge.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {TransferHelper} from \"light-lib/contracts/TransferHelper.sol\";\n\ncontract StakingHOPE is IStaking, ERC20, AbsGauge {\n    uint256 internal constant _LOCK_TIME = 28;\n\n    // permit2 contract\n    address public permit2Address;\n\n    struct UnstakingOrderDetail {\n        uint256 amount;\n        uint256 redeemTime;\n        bool redeemExecuted;\n    }\n\n    struct UnstakingOrderSummary {\n        uint256 notRedeemAmount;\n        uint256 index;\n        mapping(uint256 => UnstakingOrderDetail) orderMap;\n    }\n\n    uint256 public totalNotRedeemAmount;\n    mapping(address => UnstakingOrderSummary) public unstakingMap;\n    mapping(uint256 => uint256) public unstakingDayHistory;\n    uint256 private _unstakeTotal;\n\n    constructor(address _stakedToken, address _minter, address _permit2Address) ERC20(\"staked HOPE\", \"stHOPE\") {\n        require(_stakedToken != address(0), \"CE000\");\n        require(_permit2Address != address(0), \"CE000\");\n\n        _init(_stakedToken, _minter, _msgSender());\n\n        permit2Address = _permit2Address;\n    }\n\n    /***\n     * @notice Stake HOPE to get stHOPE\n     *\n     * @param amount\n     * @param nonce\n     * @param deadline\n     * @param signature\n     */\n    function staking(uint256 amount, uint256 nonce, uint256 deadline, bytes memory signature) external override returns (bool) {\n        require(amount != 0, \"CE002\");\n\n        address staker = _msgSender();\n        // checking amount\n        uint256 balanceOfUser = IERC20(lpToken).balanceOf(staker);\n        require(balanceOfUser >= amount, \"CE002\");\n        TransferHelper.doTransferIn(permit2Address, lpToken, amount, staker, nonce, deadline, signature);\n\n        _checkpoint(staker);\n\n        _mint(staker, amount);\n\n        _updateLiquidityLimit(staker, lpBalanceOf(staker), lpTotalSupply());\n\n        emit Staking(staker, amount);\n        return true;\n    }\n\n    /***\n     * @notice unstaking the staked amount\n     * The unstaking process takes 28 days to complete. During this period,\n     *  the unstaked $HOPE cannot be traded, and no staking rewards are accrued.\n     *\n     * @param\n     * @return\n     */\n    function unstaking(uint256 amount) external {\n        require(amount != 0, \"CE002\");\n\n        address staker = _msgSender();\n        // checking amount\n        uint256 balanceOfUser = lpBalanceOf(staker);\n        require(balanceOfUser >= amount, \"CE002\");\n\n        _checkpoint(staker);\n\n        uint256 nextDayTime = ((block.timestamp + _DAY) / _DAY) * _DAY;\n        // lock 28 days\n        uint256 redeemTime = nextDayTime + _DAY * _LOCK_TIME;\n\n        unstakingDayHistory[nextDayTime] = unstakingDayHistory[nextDayTime] + amount;\n        _unstakeTotal = _unstakeTotal + amount;\n\n        UnstakingOrderSummary storage summaryMap = unstakingMap[staker];\n\n        summaryMap.notRedeemAmount = summaryMap.notRedeemAmount + amount;\n        summaryMap.index = summaryMap.index + 1;\n        summaryMap.orderMap[summaryMap.index] = UnstakingOrderDetail(amount, redeemTime, false);\n        totalNotRedeemAmount += amount;\n\n        _updateLiquidityLimit(staker, lpBalanceOf(staker), lpTotalSupply());\n        emit Unstaking(staker, amount);\n    }\n\n    /***\n     * @notice get unstaking amount\n     *\n     * @return\n     */\n    function unstakingBalanceOf(address _addr) public view returns (uint256) {\n        uint256 _unstakingAmount = 0;\n        UnstakingOrderSummary storage summaryMap = unstakingMap[_addr];\n        for (uint256 _index = summaryMap.index; _index > 0; _index--) {\n            if (summaryMap.orderMap[_index].redeemExecuted) {\n                break;\n            }\n            if (block.timestamp < summaryMap.orderMap[_index].redeemTime) {\n                _unstakingAmount += summaryMap.orderMap[_index].amount;\n            }\n        }\n        return _unstakingAmount;\n    }\n\n    function unstakingTotal() public view returns (uint256) {\n        uint256 _unstakingTotal = 0;\n\n        uint256 nextDayTime = ((block.timestamp + _DAY) / _DAY) * _DAY;\n        for (uint256 i = 0; i < _LOCK_TIME; i++) {\n            _unstakingTotal += unstakingDayHistory[nextDayTime - _DAY * i];\n        }\n        return _unstakingTotal;\n    }\n\n    /***\n     * @notice get can redeem amount\n     *\n     * @param\n     * @return\n     */\n    function unstakedBalanceOf(address _addr) public view returns (uint256) {\n        uint256 amountToRedeem = 0;\n        UnstakingOrderSummary storage summaryMap = unstakingMap[_addr];\n        for (uint256 _index = summaryMap.index; _index > 0; _index--) {\n            if (summaryMap.orderMap[_index].redeemExecuted) {\n                break;\n            }\n            if (block.timestamp >= summaryMap.orderMap[_index].redeemTime) {\n                amountToRedeem += summaryMap.orderMap[_index].amount;\n            }\n        }\n        return amountToRedeem;\n    }\n\n    function unstakedTotal() external view returns (uint256) {\n        return _unstakeTotal - unstakingTotal();\n    }\n\n    /***\n     * @notice Redeem all amounts to your account\n     *\n     * @param\n     * @return\n     */\n    function redeemAll() external override returns (uint256) {\n        address redeemer = _msgSender();\n        uint256 amountToRedeem = unstakedBalanceOf(redeemer);\n        require(amountToRedeem != 0, \"CE002\");\n\n        _checkpoint(redeemer);\n\n        UnstakingOrderSummary storage summaryMap = unstakingMap[redeemer];\n        for (uint256 _index = summaryMap.index; _index > 0; _index--) {\n            if (summaryMap.orderMap[_index].redeemExecuted) {\n                break;\n            }\n            if (block.timestamp >= summaryMap.orderMap[_index].redeemTime) {\n                uint256 amount = summaryMap.orderMap[_index].amount;\n                summaryMap.orderMap[_index].redeemExecuted = true;\n                summaryMap.notRedeemAmount = summaryMap.notRedeemAmount - amount;\n                totalNotRedeemAmount -= amount;\n            }\n        }\n\n        _burn(redeemer, amountToRedeem);\n        TransferHelper.doTransferOut(lpToken, redeemer, amountToRedeem);\n        _updateLiquidityLimit(redeemer, lpBalanceOf(redeemer), lpTotalSupply());\n\n        _unstakeTotal = _unstakeTotal - amountToRedeem;\n\n        emit Redeem(redeemer, amountToRedeem);\n        return amountToRedeem;\n    }\n\n    /***\n     * @notice redeem amount by index(Prevent the number of unstaking too much to redeem)\n     *\n     * @param maxIndex\n     * @return\n     */\n    function redeemByMaxIndex(uint256 maxIndex) external returns (uint256) {\n        address redeemer = _msgSender();\n\n        uint256 allToRedeemAmount = unstakedBalanceOf(redeemer);\n        require(allToRedeemAmount != 0, \"CE002\");\n\n        uint256 amountToRedeem = 0;\n        _checkpoint(redeemer);\n\n        UnstakingOrderSummary storage summaryMap = unstakingMap[redeemer];\n        uint256 indexCount = 0;\n        for (uint256 _index = 1; _index <= summaryMap.index; _index++) {\n            if (indexCount >= maxIndex) {\n                break;\n            }\n            if (block.timestamp >= summaryMap.orderMap[_index].redeemTime && !summaryMap.orderMap[_index].redeemExecuted) {\n                uint256 amount = summaryMap.orderMap[_index].amount;\n                amountToRedeem += amount;\n                summaryMap.orderMap[_index].redeemExecuted = true;\n                summaryMap.notRedeemAmount = summaryMap.notRedeemAmount - amount;\n                totalNotRedeemAmount -= amount;\n                indexCount++;\n            }\n        }\n\n        if (amountToRedeem > 0) {\n            _burn(redeemer, amountToRedeem);\n            TransferHelper.doTransferOut(lpToken, redeemer, amountToRedeem);\n            _updateLiquidityLimit(redeemer, lpBalanceOf(redeemer), lpTotalSupply());\n\n            _unstakeTotal = _unstakeTotal - amountToRedeem;\n            emit Redeem(redeemer, amountToRedeem);\n        }\n        return amountToRedeem;\n    }\n\n    /**\n     * @dev Set permit2 address, onlyOwner\n     * @param newAddress New permit2 address\n     */\n    function setPermit2Address(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"CE000\");\n        address oldAddress = permit2Address;\n        permit2Address = newAddress;\n        emit SetPermit2Address(oldAddress, newAddress);\n    }\n\n    function lpBalanceOf(address _addr) public view override returns (uint256) {\n        return super.balanceOf(_addr) - unstakingMap[_addr].notRedeemAmount;\n    }\n\n    function lpTotalSupply() public view override returns (uint256) {\n        return super.totalSupply() - totalNotRedeemAmount;\n    }\n\n    /***\n     * @notice Transfers Gauge deposit (stHOPE) from the caller to _to.\n     *\n     * @param to\n     * @param amount\n     * @return bool\n     */\n    function transfer(address _to, uint256 _amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        uint256 fromBalance = lpBalanceOf(owner);\n        require(fromBalance >= _amount, \"CE002\");\n\n        _checkpoint(owner);\n        _checkpoint(_to);\n\n        bool result = super.transfer(_to, _amount);\n\n        _updateLiquidityLimit(owner, lpBalanceOf(owner), lpTotalSupply());\n        _updateLiquidityLimit(_to, lpBalanceOf(_to), lpTotalSupply());\n        return result;\n    }\n\n    /***\n     * @notice Tansfers a Gauge deposit between _from and _to.\n     *\n     * @param from\n     * @param to\n     * @param amount\n     * @return bool\n     */\n    function transferFrom(address _from, address _to, uint256 _amount) public override returns (bool) {\n        uint256 fromBalance = lpBalanceOf(_from);\n        require(fromBalance >= _amount, \"CE002\");\n\n        _checkpoint(_from);\n        _checkpoint(_to);\n\n        bool result = super.transferFrom(_from, _to, _amount);\n\n        _updateLiquidityLimit(_from, lpBalanceOf(_from), lpTotalSupply());\n        _updateLiquidityLimit(_to, lpBalanceOf(_to), lpTotalSupply());\n        return result;\n    }\n}\n"
    },
    "light-lib/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "light-lib/contracts/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IPermit2 {\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
    },
    "light-lib/contracts/LibTime.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nlibrary LibTime {\n\n    // 7 * 86400 seconds - all future times are rounded by week\n    uint256 public constant DAY = 86400;\n    uint256 public constant WEEK = DAY * 7;\n\n    /**\n     * @dev times are rounded by week\n     * @param time time\n     */\n    function timesRoundedByWeek(uint256 time) internal pure returns (uint256) {\n        return (time / WEEK) * WEEK;\n    }\n}"
    },
    "light-lib/contracts/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IPermit2.sol\";\n\nlibrary TransferHelper {\n    \n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     */\n    function doTransferFrom(address tokenAddress, address from, address to, uint256 amount) internal returns(uint256) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 balanceBefore = token.balanceOf(to);\n        safeTransferFrom(token, from, to, amount);\n        uint256 balanceAfter = token.balanceOf(to);\n        uint256 actualAmount = balanceAfter - balanceBefore;\n        assert(actualAmount <= amount);\n        return actualAmount;\n    }\n\n    /**\n     * @dev transfer with permit2\n     */\n    function doTransferIn(\n        address permit2Address,\n        address tokenAddress,\n        uint256 _value,\n        address from,\n        uint256 nonce,\n        uint256 deadline,\n        bytes memory signature\n    ) internal returns (uint256) {\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({token: tokenAddress, amount: _value}),\n            nonce: nonce,\n            deadline: deadline\n        });\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: _value\n        });\n        // Read from storage once\n        IERC20 token = IERC20(permit.permitted.token);\n        uint256 balanceBefore = token.balanceOf(transferDetails.to);\n        if (nonce == 0 && deadline == 0) {\n            safeTransferFrom(token, from, transferDetails.to, transferDetails.requestedAmount);\n        } else {\n            IPermit2(permit2Address).permitTransferFrom(permit, transferDetails, from, signature);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = IERC20(permit.permitted.token).balanceOf(address(this));\n        uint256 actualAmount = balanceAfter - balanceBefore;\n        assert(actualAmount <= transferDetails.requestedAmount);\n        \n        return actualAmount;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     */\n    function doTransferOut(address tokenAddress, address to, uint256 amount) internal returns(uint256) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 balanceBefore = token.balanceOf(to);\n        safeTransfer(token, to, amount);\n        uint256 balanceAfter = token.balanceOf(to);\n        uint256 actualAmount = balanceAfter - balanceBefore;\n        assert(actualAmount <= amount);\n        return actualAmount;\n    }\n\n    function doApprove(address tokenAddress, address to, uint256 amount) internal {\n        IERC20 token = IERC20(tokenAddress);\n        safeApprove(token, to, amount);\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}