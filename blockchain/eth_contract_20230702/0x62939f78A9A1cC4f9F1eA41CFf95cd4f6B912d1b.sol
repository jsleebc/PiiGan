{{
  "language": "Solidity",
  "sources": {
    "/contracts/NTWO.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Dex Factory contract interface\ninterface IDexFactory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}\n\n// Dex Router contract interface\ninterface IDexRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = payable(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract Numisme2 is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) public isExcludedFromFee;\n\n    string private _name = \"Numisme2\";\n    string private _symbol = \"NUME2\";\n    uint8 private _decimals = 18;\n    uint256 private _totalSupply = 1_000_000 * 1e18;\n    uint256 private _maxSupply = 3_000_000 * 1e18;\n\n    IDexRouter public dexRouter;\n    address public dexPair;\n    address public treasuryWallet;\n\n    uint256 public minTokenToSwap = _totalSupply.div(1e5); // this amount will trigger swap and distribute\n    uint256 public percentDivider = 1000;\n    uint256 public timeStep = 262800 minutes;\n    uint256 public mintAmount = 100_000 * 1e18;\n    uint256 public mintedAmount;\n    uint256 public lastMintAt;\n    uint256 public launchedAt;\n\n    bool public distributeAndLiquifyStatus; // should be true to turn on to liquidate the pool\n    bool public feesStatus; // enable by default\n    bool public trading; // once enable can't be disable afterwards\n\n    uint256 public liquidityFeeOnSelling = 20; // 2% will be added to the liquidity\n    uint256 public sellFeeOnSelling = 20; // 2% will be added to the marketing address\n\n    uint256 liquidityFeeCounter = 0;\n    uint256 sellFeeCounter = 0;\n\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n\n    constructor(address _treasuryWallet) {\n        treasuryWallet = payable(_treasuryWallet);\n        _balances[treasuryWallet] = _totalSupply;\n        mintedAmount += _totalSupply;\n\n        IDexRouter _dexRouter = IDexRouter(\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n        );\n        // Create a dex pair for this new ERC20\n        dexPair = IDexFactory(_dexRouter.factory()).createPair(\n            address(this),\n            _dexRouter.WETH()\n        );\n\n        // set the rest of the contract variables\n        dexRouter = _dexRouter;\n\n        //exclude owner and this contract from fee\n        isExcludedFromFee[owner()] = true;\n        isExcludedFromFee[treasuryWallet] = true;\n        isExcludedFromFee[address(this)] = true;\n\n        emit Transfer(address(0), treasuryWallet, _totalSupply);\n    }\n\n    //to receive ETH from dexRouter when swapping\n    receive() external payable {}\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"NUME2: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"NUME2: decreased allowance or below zero\"\n            )\n        );\n        return true;\n    }\n\n    function includeOrExcludeFromFee(address account, bool value)\n        external\n        onlyOwner\n    {\n        isExcludedFromFee[account] = value;\n    }\n\n    function setMinTokenToSwap(uint256 _amount) external onlyOwner {\n        require(_amount > 0, \"NUME2: can't be 0\");\n        minTokenToSwap = _amount;\n    }\n\n    function setSellFeePercent(uint256 _lpFee, uint256 _marketingFee)\n        external\n        onlyOwner\n    {\n        sellFeeOnSelling = _marketingFee;\n        liquidityFeeOnSelling = _lpFee;\n        require(\n            _lpFee.add(_marketingFee) <= percentDivider.div(25),\n            \"NUME2: can't be more than 4%\"\n        );\n    }\n\n    function setDistributionStatus(bool _value) public onlyOwner {\n        distributeAndLiquifyStatus = _value;\n    }\n\n    function enableOrDisableFees(bool _value) external onlyOwner {\n        feesStatus = _value;\n    }\n\n    function updateAddresses(address _treasuryWallet) external onlyOwner {\n        treasuryWallet = _treasuryWallet;\n    }\n    \n    function setUnlockTokenAmount(uint256 unlockAmount) external onlyOwner {\n        mintAmount = unlockAmount;\n    }\n         \n    function setTimeStep(uint256 time) external onlyOwner {\n        timeStep = time;\n    }\n\n      function withdrawStuckToken(address _token, address _to)\n        external\n        onlyOwner\n        returns (bool _sent)\n    {\n        require(_token != address(0), \"_token address cannot be 0\");\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\n        emit Transfer(address(this), _to, _contractBalance);\n    }\n\n    \n      // change the minimum amount of tokens to sell from fees\n    function updateMinimumTokensBeforeSwap(uint256 newAmount) external onlyOwner{\n  \t    minTokenToSwap = newAmount;\n  \t}\n    function enableTrading() external onlyOwner {\n        require(!trading, \"NUME2: already enabled\");\n        trading = true;\n        feesStatus = true;\n        distributeAndLiquifyStatus = true;\n        launchedAt = block.timestamp;\n        lastMintAt = block.timestamp;\n    }\n\n    function mint() external onlyOwner {\n        require(\n            block.timestamp >= timeStep + lastMintAt,\n            \"You cannot unlock before time \"\n        );\n        require(mintedAmount < _maxSupply, \"ERC20 , max supply reached\");\n        uint256 time = (block.timestamp - lastMintAt) / timeStep;\n        uint256 amount;\n        amount = time * mintAmount;\n        if (amount + mintedAmount > _maxSupply) {\n            amount = _maxSupply - mintedAmount;\n            _balances[treasuryWallet] += amount;\n            mintedAmount += amount;\n        } else {\n            _balances[treasuryWallet] += amount;\n            mintedAmount += amount;\n        }\n        lastMintAt += time * timeStep;\n        emit Transfer(address(this), treasuryWallet, amount);\n    }\n\n    function removeStuckEth(address _receiver) public onlyOwner {\n        payable(_receiver).transfer(address(this).balance);\n    }\n\n    function totalSellFeePerTx(uint256 amount) public view returns (uint256) {\n        uint256 fee = amount\n            .mul(sellFeeOnSelling.add(liquidityFeeOnSelling))\n            .div(percentDivider);\n        return fee;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"NUME2: approve from the zero address\");\n        require(spender != address(0), \"NUME2: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"NUME2: transfer from the zero address\");\n        require(to != address(0), \"NUME2: transfer to the zero address\");\n        require(amount > 0, \"NUME2: Amount must be greater than zero\");\n\n        // trading disable till launch\n        if (!trading) {\n            require(\n                dexPair != from && dexPair != to,\n                \"NUME2: trading is disable\"\n            );\n        }\n\n        // swap and liquify\n        distributeAndLiquify(from, to);\n\n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n\n        //if any account belongs to isExcludedFromFee account then remove the fee\n        if (isExcludedFromFee[from] || isExcludedFromFee[to] || !feesStatus) {\n            takeFee = false;\n        }\n\n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from, to, amount, takeFee);\n    }\n\n    //this method is responsible for taking all fee, if takeFee is true\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeFee\n    ) private {\n        if (dexPair == recipient && takeFee) {\n            uint256 allFee = totalSellFeePerTx(amount);\n            uint256 tTransferAmount = amount.sub(allFee);\n            _balances[sender] = _balances[sender].sub(\n                amount,\n                \"NUME2: insufficient balance\"\n            );\n            _balances[recipient] = _balances[recipient].add(tTransferAmount);\n            emit Transfer(sender, recipient, tTransferAmount);\n\n            takeTokenFee(sender, allFee);\n            setFeeCountersOnSelling(amount);\n        } else {\n            _balances[sender] = _balances[sender].sub(\n                amount,\n                \"NUME2: insufficient balance\"\n            );\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        }\n    }\n\n    function takeTokenFee(address sender, uint256 amount) private {\n        _balances[address(this)] = _balances[address(this)].add(amount);\n\n        emit Transfer(sender, address(this), amount);\n    }\n\n    function setFeeCountersOnSelling(uint256 amount) private {\n        liquidityFeeCounter += amount.mul(liquidityFeeOnSelling).div(\n            percentDivider\n        );\n        sellFeeCounter += amount.mul(sellFeeOnSelling).div(percentDivider);\n    }\n\n    function distributeAndLiquify(address from, address to) private {\n        if (liquidityFeeCounter + sellFeeCounter <= 0) return;\n        // is the token balance of this contract address over the min number of\n        // tokens that we need to initiate a swap + liquidity lock?\n        // also, don't get caught in a circular liquidity event.\n        // also, don't swap & liquify if sender is Dex pair.\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool shouldSell = contractTokenBalance >= minTokenToSwap;\n\n        if (\n            shouldSell &&\n            from != dexPair &&\n            distributeAndLiquifyStatus &&\n            !(from == address(this) && to == dexPair) // swap 1 time\n        ) {\n            // approve contract\n            _approve(address(this), address(dexRouter), contractTokenBalance);\n\n            uint256 halfLiquidity = liquidityFeeCounter.div(2);\n            uint256 otherHalfLiquidity = liquidityFeeCounter.sub(halfLiquidity);\n\n            uint256 tokenAmountToBeSwapped = contractTokenBalance.sub(\n                otherHalfLiquidity\n            );\n\n            uint256 balanceBefore = address(this).balance;\n\n            // now is to lock into liquidty pool\n            Utils.swapTokensForEth(address(dexRouter), tokenAmountToBeSwapped);\n\n            uint256 deltaBalance = address(this).balance.sub(balanceBefore);\n\n            uint256 ethToBeAddedToLiquidity = deltaBalance\n                .mul(halfLiquidity)\n                .div(tokenAmountToBeSwapped);\n\n            // add liquidity to Dex\n            if (ethToBeAddedToLiquidity > 0) {\n                Utils.addLiquidity(\n                    address(dexRouter),\n                    address(this),\n                    otherHalfLiquidity,\n                    ethToBeAddedToLiquidity\n                );\n\n                emit SwapAndLiquify(\n                    halfLiquidity,\n                    ethToBeAddedToLiquidity,\n                    otherHalfLiquidity\n                );\n            }\n\n            uint256 ethForMarketing = address(this).balance;\n\n            // sending Eth to Marketing wallet\n            if (ethForMarketing > 0)\n                payable(treasuryWallet).transfer(ethForMarketing);\n\n            // Reset all fee counters\n            liquidityFeeCounter = 0;\n            sellFeeCounter = 0;\n        }\n    }\n}\n\n// Library for doing a swap on Dex\nlibrary Utils {\n    using SafeMath for uint256;\n\n    function swapTokensForEth(address routerAddress, uint256 tokenAmount)\n        internal\n    {\n        IDexRouter dexRouter = IDexRouter(routerAddress);\n\n        // generate the Dex pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = dexRouter.WETH();\n\n        // make the swap\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp + 300\n        );\n    }\n\n    function addLiquidity(\n        address routerAddress,\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) internal {\n        IDexRouter dexRouter = IDexRouter(routerAddress);\n\n        // add the liquidity\n        dexRouter.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner,\n            block.timestamp + 300\n        );\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}