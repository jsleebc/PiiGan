{{
  "language": "Solidity",
  "sources": {
    "contracts/SFROGContract.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2023-06-01\n*/\n\n/**\n\n$SFROG - SALUTING FROG\n\nhttps://salutingfrog.xyz\n\nhttps://t.me/SFROGPORTAL\n\nhttps://twitter.com/salutingfrog\n\n\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB) external returns(address pair);\n}\n\ninterface IERC20 {\n\n    function totalSupply() external view returns(uint256);\n\n    function balanceOf(address account) external view returns(uint256);\n\n    function transfer(address recipient, uint256 amount) external returns(bool);\n\n    function allowance(address owner, address spender) external view returns(uint256);\n\n    function approve(address spender, uint256 amount) external returns(bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns(bool);\n\n        event Transfer(address indexed from, address indexed to, uint256 value);\n\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns(string memory);\n\n    function symbol() external view returns(string memory);\n\n    function decimals() external view returns(uint8);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns(address) {\n        return msg.sender;\n    }\n\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    using SafeMath for uint256;\n\n        mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n \n    uint256 private _totalSupply;\n \n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns(string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns(string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns(uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns(uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns(uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns(bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns(uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns(bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns(bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns(bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns(bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased cannot be below zero\"));\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        \n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n}\n \nlibrary SafeMath {\n   \n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n   \n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n    \n        if (a == 0) {\n            return 0;\n        }\n \n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n \n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n  \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }   \n}\n \ncontract Ownable is Context {\n    address private _owner;\n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns(address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n \nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) << 255;\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n    function mul(int256 a, int256 b) internal pure returns(int256) {\n        int256 c = a * b;\n\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns(int256) {\n        require(b != -1 || a != MIN_INT256);\n\n        return a / b;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns(int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n    function add(int256 a, int256 b) internal pure returns(int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    function abs(int256 a) internal pure returns(int256) {\n        require(a != MIN_INT256);\n        return a < 0 ? -a : a;\n    }\n\n    function toUint256Safe(int256 a) internal pure returns(uint256) {\n        require(a >= 0);\n        return uint256(a);\n    }\n}\n \nlibrary SafeMathUint {\n    function toInt256Safe(uint256 a) internal pure returns(int256) {\n    int256 b = int256(a);\n        require(b >= 0);\n        return b;\n    }\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns(address);\n    function WETH() external pure returns(address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns(uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns(uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns(uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns(uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns(uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns(uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns(uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns(uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns(uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns(uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns(uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns(uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns(uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns(uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns(uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns(uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n \ncontract SFROGContract is ERC20, Ownable {\n    using SafeMath for uint256;\n\n    IUniswapV2Router02 public immutable router;\n    address public immutable uniswapV2Pair;\n\n    // addresses\n    address private developmentWallet;\n    address private marketingWallet;\n\n    // limits \n    uint256 private maxBuyAmount;\n    uint256 private maxSellAmount;   \n    uint256 private maxWalletAmount;\n \n    uint256 private thresholdSwapAmount;\n\n    // status flags\n    bool private isTrading = false;\n    bool public swapEnabled = false;\n    bool public isSwapping;\n\n    struct Fees {\n        uint256 buyTotalFees;\n        uint256 buyMarketingFee;\n        uint256 buyDevelopmentFee;\n        uint256 buyLiquidityFee;\n\n        uint256 sellTotalFees;\n        uint256 sellMarketingFee;\n        uint256 sellDevelopmentFee;\n        uint256 sellLiquidityFee;\n    }  \n\n    Fees public _fees = Fees({\n        buyTotalFees: 0,\n        buyMarketingFee: 0,\n        buyDevelopmentFee:0,\n        buyLiquidityFee: 0,\n\n        sellTotalFees: 0,\n        sellMarketingFee: 0,\n        sellDevelopmentFee:0,\n        sellLiquidityFee: 0\n    });\n\n    uint256 public tokensForMarketing;\n    uint256 public tokensForLiquidity;\n    uint256 public tokensForDevelopment;\n    uint256 private taxTill;\n\n    mapping(address => bool) private _isExcludedFromFees;\n    mapping(address => bool) public _isExcludedMaxTransactionAmount;\n    mapping(address => bool) public _isExcludedMaxWalletAmount;\n\n    mapping(address => bool) public marketPair;\n \n  \n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived\n    );\n\n    constructor() ERC20(\"Saluting Frog\", \"SFROG\") {\n \n        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n        uniswapV2Pair = IUniswapV2Factory(router.factory()).createPair(address(this), router.WETH());\n\n        _isExcludedMaxTransactionAmount[address(router)] = true;\n        _isExcludedMaxTransactionAmount[address(uniswapV2Pair)] = true;        \n        _isExcludedMaxTransactionAmount[owner()] = true;\n        _isExcludedMaxTransactionAmount[address(this)] = true;\n        _isExcludedMaxTransactionAmount[address(0xdead)] = true;\n\n        _isExcludedFromFees[owner()] = true;\n        _isExcludedFromFees[address(this)] = true;\n\n        _isExcludedMaxWalletAmount[owner()] = true;\n        _isExcludedMaxWalletAmount[address(0xdead)] = true;\n        _isExcludedMaxWalletAmount[address(this)] = true;\n        _isExcludedMaxWalletAmount[address(uniswapV2Pair)] = true;\n\n        marketPair[address(uniswapV2Pair)] = true;\n\n        approve(address(router), type(uint256).max);\n\n        uint8 _decimals = 18;\n        uint256 totalSupply = 9_999_999_999_999 * (10 ** _decimals);\n\n        maxBuyAmount = totalSupply * 100 / 100; // 1% maxBuyAmount\n        maxSellAmount = totalSupply * 100 / 100; // 1% maxSellAmount\n        maxWalletAmount = totalSupply * 100 / 100; // 1% maxWallet\n        thresholdSwapAmount = totalSupply * 1 / 1000; \n\n        _fees.buyMarketingFee = 0;\n        _fees.buyLiquidityFee = 0;\n        _fees.buyDevelopmentFee = 40;\n        _fees.buyTotalFees = _fees.buyMarketingFee + _fees.buyLiquidityFee + _fees.buyDevelopmentFee;\n\n        _fees.sellMarketingFee = 0;\n        _fees.sellLiquidityFee = 0;\n        _fees.sellDevelopmentFee = 40;\n        _fees.sellTotalFees = _fees.sellMarketingFee + _fees.sellLiquidityFee + _fees.sellDevelopmentFee;\n\n        marketingWallet = address(0x3265403897b80DB188a240f3D49673b82ae60177);\n        developmentWallet = address(0xEcD9c2cB26a7D6DC56D41c2129FeBCc26d2E06f2);\n\n        /*\n            _mint is an internal function in ERC20.sol that is only called here,\n            and CANNOT be called ever again\n        */\n\n        uint256 marketingSupply = totalSupply.mul(690).div(10000); // 6.9%\n        uint256 devSupply = totalSupply.mul(10).div(100); // 10%\n        uint256 poolSupply = totalSupply - (marketingSupply + devSupply); // 83.1%\n\n        _mint(marketingWallet, marketingSupply);\n        _mint(developmentWallet, devSupply);\n        _mint(msg.sender, poolSupply);\n    }\n\n    receive() external payable {\n\n    }\n\n    // once enabled, can never be turned off\n    function enableTrading() external onlyOwner {\n        isTrading = true;\n        swapEnabled = true;\n        taxTill = block.number + 0;\n    }\n\n    // change the minimum amount of tokens to sell from fees\n    function updateThresholdSwapAmount(uint256 newAmount) external onlyOwner returns(bool){\n        thresholdSwapAmount = newAmount;\n        return true;\n    }\n\n    function updateMaxTxnAmount(uint256 newMaxBuy, uint256 newMaxSell) public onlyOwner {\n        maxBuyAmount = (totalSupply() * newMaxBuy) / 1000;\n        maxSellAmount = (totalSupply() * newMaxSell) / 1000;\n    }\n\n    function updateMaxWalletAmount(uint256 newPercentage) public onlyOwner {\n        maxWalletAmount = (totalSupply() * newPercentage) / 1000;\n    }\n\n    // only use to disable contract sales if absolutely necessary (emergency use only)\n    function toggleSwapEnabled(bool enabled) external onlyOwner(){\n        swapEnabled = enabled;\n    }\n\n    function updateFees(uint256 _marketingFeeBuy, uint256 _liquidityFeeBuy,uint256 _developmentFeeBuy,uint256 _marketingFeeSell, uint256 _liquidityFeeSell,uint256 _developmentFeeSell) external onlyOwner{\n        _fees.buyMarketingFee = _marketingFeeBuy;\n        _fees.buyLiquidityFee = _liquidityFeeBuy;\n        _fees.buyDevelopmentFee = _developmentFeeBuy;\n        _fees.buyTotalFees = _fees.buyMarketingFee + _fees.buyLiquidityFee + _fees.buyDevelopmentFee;\n\n        _fees.sellMarketingFee = _marketingFeeSell;\n        _fees.sellLiquidityFee = _liquidityFeeSell;\n        _fees.sellDevelopmentFee = _developmentFeeSell;\n        _fees.sellTotalFees = _fees.sellMarketingFee + _fees.sellLiquidityFee + _fees.sellDevelopmentFee;\n        require(_fees.buyTotalFees <= 70, \"Must keep fees at 70% or less\");   \n        require(_fees.sellTotalFees <= 70, \"Must keep fees at 70% or less\");\n    }\n    \n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        _isExcludedFromFees[account] = excluded;\n    }\n    function excludeFromWalletLimit(address account, bool excluded) public onlyOwner {\n        _isExcludedMaxWalletAmount[account] = excluded;\n    }\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\n    }\n\n    function removeLimits() external onlyOwner {\n        updateMaxTxnAmount(1000,1000);\n        updateMaxWalletAmount(1000);\n    }\n\n    function setMarketPair(address pair, bool value) public onlyOwner {\n        require(pair != uniswapV2Pair, \"The pair cannot be removed from marketPair\");\n        marketPair[pair] = value;\n    }\n\n    function setWallets(address _marketingWallet,address _developmentWallet) external onlyOwner{\n        marketingWallet = _marketingWallet;\n        developmentWallet = _developmentWallet;\n    }\n\n    function isExcludedFromFees(address account) public view returns(bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        \n        if (amount == 0) {\n            super._transfer(sender, recipient, 0);\n            return;\n        }\n\n        if (\n            sender != owner() &&\n            recipient != owner() &&\n            !isSwapping\n        ) {\n\n            if (!isTrading) {\n                require(_isExcludedFromFees[sender] || _isExcludedFromFees[recipient], \"Trading is not active.\");\n            }\n            if (marketPair[sender] && !_isExcludedMaxTransactionAmount[recipient]) {\n                require(amount <= maxBuyAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\n            } \n            else if (marketPair[recipient] && !_isExcludedMaxTransactionAmount[sender]) {\n                require(amount <= maxSellAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            }\n\n            if (!_isExcludedMaxWalletAmount[recipient]) {\n                require(amount + balanceOf(recipient) <= maxWalletAmount, \"Max wallet exceeded\");\n            }\n\n        }\n \n        uint256 contractTokenBalance = balanceOf(address(this));\n \n        bool canSwap = contractTokenBalance >= thresholdSwapAmount;\n\n        if (\n            canSwap &&\n            swapEnabled &&\n            !isSwapping &&\n            marketPair[recipient] &&\n            !_isExcludedFromFees[sender] &&\n            !_isExcludedFromFees[recipient]\n        ) {\n            isSwapping = true;\n            swapBack();\n            isSwapping = false;\n        }\n \n        bool takeFee = !isSwapping;\n\n        // if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) {\n            takeFee = false;\n        }\n \n        \n        // only take fees on buys/sells, do not take on wallet transfers\n        if (takeFee) {\n            uint256 fees = 0;\n            if(block.number < taxTill) {\n                fees = amount; // 100% of the amount\n                tokensForDevelopment += fees;\n            } else if (marketPair[recipient] && _fees.sellTotalFees > 0) {\n                fees = amount.mul(_fees.sellTotalFees).div(100);\n                tokensForLiquidity += fees * _fees.sellLiquidityFee / _fees.sellTotalFees;\n                tokensForMarketing += fees * _fees.sellMarketingFee / _fees.sellTotalFees;\n                tokensForDevelopment += fees * _fees.sellDevelopmentFee / _fees.sellTotalFees;\n            }\n            // on buy\n            else if (marketPair[sender] && _fees.buyTotalFees > 0) {\n                fees = amount.mul(_fees.buyTotalFees).div(100);\n                tokensForLiquidity += fees * _fees.buyLiquidityFee / _fees.buyTotalFees;\n                tokensForMarketing += fees * _fees.buyMarketingFee / _fees.buyTotalFees;\n                tokensForDevelopment += fees * _fees.buyDevelopmentFee / _fees.buyTotalFees;\n            }\n\n            if (fees > 0) {\n                super._transfer(sender, address(this), fees);\n            }\n\n            amount -= fees;\n\n        }\n\n        super._transfer(sender, recipient, amount);\n    }\n\n    function swapTokensForEth(uint256 tAmount) private {\n\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.WETH();\n\n        _approve(address(this), address(router), tAmount);\n\n        // make the swap\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n\n    }\n\n    function addLiquidity(uint256 tAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(router), tAmount);\n\n        // add the liquidity\n        router.addLiquidityETH{ value: ethAmount } (address(this), tAmount, 0, 0 , address(this), block.timestamp);\n    }\n\n    function swapBack() private {\n        uint256 contractTokenBalance = balanceOf(address(this));\n        uint256 toSwap = tokensForLiquidity + tokensForMarketing + tokensForDevelopment;\n        bool success;\n\n        if (contractTokenBalance == 0 || toSwap == 0) { return; }\n\n        if (contractTokenBalance > thresholdSwapAmount * 20) {\n            contractTokenBalance = thresholdSwapAmount * 20;\n        }\n\n        // Halve the amount of liquidity tokens\n        uint256 liquidityTokens = contractTokenBalance * tokensForLiquidity / toSwap / 2;\n        uint256 amountToSwapForETH = contractTokenBalance.sub(liquidityTokens);\n \n        uint256 initialETHBalance = address(this).balance;\n\n        swapTokensForEth(amountToSwapForETH); \n \n        uint256 newBalance = address(this).balance.sub(initialETHBalance);\n \n        uint256 ethForMarketing = newBalance.mul(tokensForMarketing).div(toSwap);\n        uint256 ethForDevelopment = newBalance.mul(tokensForDevelopment).div(toSwap);\n        uint256 ethForLiquidity = newBalance - (ethForMarketing + ethForDevelopment);\n\n\n        tokensForLiquidity = 0;\n        tokensForMarketing = 0;\n        tokensForDevelopment = 0;\n\n\n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\n            addLiquidity(liquidityTokens, ethForLiquidity);\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity);\n        }\n\n        (success,) = address(developmentWallet).call{ value: (address(this).balance - ethForMarketing) } (\"\");\n        (success,) = address(marketingWallet).call{ value: address(this).balance } (\"\");\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}