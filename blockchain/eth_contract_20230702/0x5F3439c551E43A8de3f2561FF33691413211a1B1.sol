{{
  "language": "Solidity",
  "sources": {
    "contracts/SEH.sol": {
      "content": "/*\nhttps://t.me/Sendethhere\nhttp://twitter.com/sendethhere\n*/\n\n/*\nMMMMMMMMMMMMMMMMMMMMMMMNo,,;:ccc:cccccc:,,,',,;:cc;:k0000000000Ol::,,;,,',,;:ccccccccc::;,,xWMMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMMMMMMMMMWN0dc:;;;:::cccccc:,,,'',;ccc:;cdkO00000Oko::;,;;,',,,;:ccccccc:;;;;:cxKWMMMMMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMMWWWWMWNK0xollcc:;;,,;;::::;,,,,'',:cccc:;:cclllccccc:,;;,'',,,,;:::;;;,,;;:clllok0XNWMMMMMMMMMMMMMMMMMMMMMM\nMMMMMMMMMMMMXkkkkkxdooolccccccccccccclccccccccclooooollllllllooolllllcccccccccllcc::ccccccccloolodxxxxxxxxKWMMMMMMMMMMMM\nMMMMMMMMMMMW0olollooooooooooddxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdooooooooollllcc:ccc::cOWMMMMMMMMMMMM\nMMMMMMMMMWN0dlloooooooooddxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdoooooooooooolcccccc:cOWMMMMMMMMMMMM\nMMMMMMMMW0xlccoooolooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdoooooooooololccccccckWMMMMMMMMMMMM\nMMMMMMMWKdl:;cooooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxoooooooooooolccccc:oKMMMMMMMMMMMM\nMMMMMMMXkoc;;coooolodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdoooooooooollcccc:lkNMMMMMMMMMMM\nMMMMMMW0xoc:;cooooooxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdoooooooooolcccc:oxKWMMMMMMMMMM\nMMMMMMNkoolc:cooolodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdooooooolollccc:lokNMMMMMMMMMM\nWWWWNN0dlcll:cooooodxxxxxxxxxxxxxxxxxxxxxxdlccloxxdlcccc:cddlccdxxxxo;cxxolccloxxxxxxxxxxxxoooooooooolccc::lxKWWWWWWWWWW\nxxxxxdoolccc:cooooodxxxxxxxxxxxxxxxxxxxxo;.....'ld;  .....l:.  .cxxx, .c'. .....:dxxxxxxxxxdolooloooolccc::looxxxxxxxxxx\nlllllcldlccc:cooooodxxxxxxxxxxxxxxxxxxxx; .;looodx; .cdoodx:.    ,ox, .l;  ;doc. 'oxxxxxxxxxdooooooooolcc::ldlclllllllll\n;;;;;;ldcccc:cooooodxxxxxxxxxxxxxxxxxxxxl'....':ox;  ....:xc. .;. .:' .dl. :xxxc. cxxxxxxxxxxolooooooolcc::ldc;;;;;;;;;;\nccccccooccc::cooooodxxxxxxxxxxxxxxxxxxxxddolc;. 'o; .,::coxc. .ld;.   'dl. cxxd, .lxxxxxxxxxxdoooooololcc::cdocccccccccc\nllllcldl:ldxkO0Okxdxxxxxxxxxxxxxxxxxxxxx;.';::. .o: .,;;,;oc. .lxxl.  'xl. ':,. .cxxxxxxxxxxxxollooololcc:::odllllllllll\n;;:;;ldcoOKK000KK0Okxxxxxxxxxxxxxxxxxxxxo:'....,lxo;'''',;ol;',oxxxo,.:xo,...';cdxxxxxxxxxxxxxdoloooooolc:::ldl;;;::;;;:\n;;:;:ood0K00KKKK0Oxxxxxxxxxxxxxxxxxxxxxxxxxddddxxxxxxxxxxxxxxddxxxxxxxxxxxddxxxxxxxxxxxxxxxxxxdoloooooolc::ccoo;;::;;;;;\n:::;cdk0K0000000KK0kxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxooooooollc::ccldc;::::;::\n::::lk0K0KKKKKKK00Okxxxxxxxxxxxxxxxxxxxxxxxxxxdlcccccldocccccccccodclxxxxo:lxxxxxxxxxxxxxxxxxxxdooooooolc::c:ldl;:::::::\nooold0KK0000000KKK0Oxxxxxxxxxxxxxxxxxxxxxxxxxo'  ....,l;...   ...:; .oxxd' 'dxxxxxxxxxxxxxxxxxxdoollooolc::c:cdolooooooo\n:::cx000KKXXXKKK0000kxxxxxxxxxxxxxxxxxxxxxxxxd' 'ododdxxdd:  .:ddd; .oxxd' 'dxxxxxxxxxxxxxxxxxxdooolodxkkxxdolddc:::::::\n;;;ck0KXXXXXKKKXXK0Oxxxxxxxxxxxxxxxxxxxxxxxxxd'  ...'lxxxxc  .cxxx;  .''.  .cxxxxxxxxxxxxxxxxxxdooook0KKKKKK0Okdc;;;;;;,\n;;;ckKXXXKK0OxxkO0KKOxxxxxxxxxxxxxxxxxxxxxxxxd' .;::cdxxxxc  .cxxx;  ',,'. .cxxxxxxxxxxxxxxxxxxdoooodk0000K00KKkc;:;;;;,\n;;;lOKXXKK00Odloooxkkxxxxxxxxxxxxxxxxxxxxxxxxd' .;:;,:dxxxc. .cxxx; .okxd' 'dxxxxxxxxxxxxxxxxxxdooodk0KKKK0000KKd:;;;;,'\ncc:lk0KKKK0KOdlooodxxxxxxxxxxxxxxxxxxxxxxxxxxxc'...',:dxxxl'.'oxxxc.;dxxx:.:xxxxxxxxxxxxxxxxxxxdoodkOO000KKKK00K0xcccc::\ncoccok00KKKKOdlooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdddxxxxxxxxxxxxdxxxxxxxxxxxxxxxxxxxxdoooxO0KKK0000000K0dlc:::\n,:;;clk0000KOdoooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxolox00000KKKKKK0000d;,,,,\n,:;;:cok0K0KOdlooodxxxxxxxxxxxxxxxxxxxxxo:ldxxxl:lxdoccc:::oxxo:;,',;ldxxdlccc::cdxxxxxxxxxxxxdooodxO0KXXXXXXXXXKKx;,,,,\n,:;,;cccodk0Odoooodxxxxxxxxxxxxxxxxxxxxx; .oxxd' 'dc. .....:xo' .','. ,dd,  ....'lxxxxxxxxxxxxdooox0KK0OxxO0KKXXXXk:,,,,\n;::;;::;,,;coooooodxxxxxxxxxxxxxxxxxxxxx; .lxxd' 'dc. :doodxxx, .okx: .cx, .ldoddxxxxxxxxxxxxxdooodxxdolccx000KXXKOl;;;;\ncool:,;,,,,;:coooodxxxxxxxxxxxxxxxxxxxxx;  .'..  .cc. ....,dkx, .;:'. ,dx;  ....:xxxxxxxxxxxxdooooollool:cx0K00KKKkoclll\n;ccc:,,,,,,::coooodxxxxxxxxxxxxxxxxxxxxx;  ';,,. .lc. ':::lxxx,  ..  ;dxx; .,::coxxxxxxxxxxxxdoooooooolcccx00000KOo;;;;;\n,;;;;;,,,,,;:loooodxxxxxxxxxxxxxxxxxxxxx; .okxd' .dl. ';;,,cdx; .lo;. 'lx; .,;;,;oxxxxxxxxxxdolooooooolcccx0KK000o;,,,,,\n,;;;;;;,',,,;coooooxxxxxxxxxxxxxxxxxxxxxc';dxxx:.:xd:''''';ldxc.;dxxo,.:xo;'''',:oxxxxxxxxxxdlooooooollc:lxKK000d;,,,,,,\n,;;;;,''',;,,coooooxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdxxxxxxxxxxxxxxxxxxxxdolooooooollc:cx00kdc,'''''''\n;ccc;''',clc:cooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxollooloooolccccdxl;',::::::::\n:lc;''';cooollooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdoooooloololccc:col;'';;::::::\n','''',coooollooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdooooooooooolccc:cllc;'''''''''\n''''',cooooollooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxddooooooooooolcccc:clc::;''.'''''\n.'''':odooolllooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdooooooooooooolcccc:c::;;;,'..''''\n.''''cxxooolllooooooxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxddooooooooooooolccccc:c:,,''''.',;;;\n.'''':xkoloolloooooodxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxddoooooooooooooolcccccc:cc,'.....'clcl\n.'''',lkdooollllllccloooolcccccccccccccclccccccccccccccccccccccccccccccccccccccccc::;::::::clllllllcccccccll;'......,;;;\n.''''';dxolllcccccccloollc:,''''.'''''',,''''''......''''''''''.........'''....'''''''''',:loolloooolllloool;'.......'''\n.''.''':xxlllllllllolllloooc;''..'''''''''''''''.....'''''''''........''''....'''''...',:loolollllllllclllll:'.......'.'\n.''.''',lkdlloooooollcllooooc,''..'''''''''''''''.....''''''''........''.....'''''.'''':loloolollllcclccclol:...........\n*/\n\n//SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.8.17;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 9;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n        ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n\n        return a % b;\n    }\n}\n\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) << 255;\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != -1 || a != MIN_INT256);\n        return a / b;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    function abs(int256 a) internal pure returns (int256) {\n        require(a != MIN_INT256);\n        return a < 0 ? -a : a;\n    }\n\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0);\n        return uint256(a);\n    }\n}\n\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b >= 0);\n    return b;\n  }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n     function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n\n        uint deadline\n    ) external;\n}\n\ncontract SEH is ERC20, Ownable {\n    using SafeMath for uint256;\n\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    address public deployerAddress;\n    address public sendEthHere;\n\n    uint256 public mintAmount = 1000000 * 10 ** decimals();\n    uint256 public maxHoldingAmount   = mintAmount / 40;   // 2.50% absolute max per wallet\n    uint256 public swapTokensAtAmount = mintAmount / 2000; // 0.05% max before swapBack\n\n    uint256 public buyTotalFees = 3;\n    uint256 public buyLiquidityFee = 1;\n    uint256 public buySendEthFee = 2;\n\n    uint256 public sellTotalFees = 3;\n    uint256 public sellLiquidityFee = 1;\n    uint256 public sellSendEthFee = 2;\n\n    uint256 public tokensForLiquidity;\n    uint256 public tokensForSendEth;\n\n    bool private swapping;\n    bool public swapEnabled = true;\n    bool public limitOn = true;\n\n    mapping (address => bool) public blacklist;\n    mapping (address => bool) public isExcludedFromFees;\n    mapping (address => bool) public isExcludedMaxTxAmount;\n    mapping (address => bool) public tradingPairs;\n\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event SendEthWalletUpdated(address indexed newWallet, address indexed oldWallet);\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n    constructor() ERC20(\"SendEthHere\", \"SEH\") {\n\n        address newOwner = address(owner());\n\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\n          .createPair(address(this), uniswapV2Router.WETH());\n        excludeFromMaxTransaction(address(uniswapV2Router), true);\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n\n        deployerAddress = address(owner());\n      \tsendEthHere = 0xA8BCC998F366de5248CfC5cC2C5e4bCD077699AE;\n\n        excludeFromFees(newOwner, true); // Owner address\n        excludeFromFees(address(this), true); // CA\n        excludeFromFees(address(0xdead), true); // Burn address\n        excludeFromFees(sendEthHere, true); // sendEth wallet\n        excludeFromFees(deployerAddress, true); // Deployer Address\n\n        excludeFromMaxTransaction(newOwner, true); // Owner address\n        excludeFromMaxTransaction(address(this), true); // CA\n        excludeFromMaxTransaction(address(0xdead), true); // Burn address\n        excludeFromMaxTransaction(sendEthHere, true); // sendEth wallet\n        excludeFromMaxTransaction(deployerAddress, true); // Deployer Address\n\n        /* _mint only called once and CANNOT be called again */\n        _mint(newOwner, mintAmount);\n\n        transferOwnership(newOwner);\n    }\n\n    receive() external payable {}\n\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool) {\n  \t    require(newAmount >= totalSupply() / 100000, \"Swap amount cannot be lower than 0.001% total supply.\");\n  \t    require(newAmount <= totalSupply() / 200, \"Swap amount cannot be higher than 0.5% total supply.\");\n  \t    swapTokensAtAmount = newAmount;\n  \t    return true;\n  \t}\n\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\n        isExcludedMaxTxAmount[updAds] = isEx;\n    }\n\n    function updateSwapEnabled(bool enabled) external onlyOwner {\n        swapEnabled = enabled;\n    }\n\n    function updateBuyFees(uint256 _liquidityFee, uint256 _sendEthFee) external onlyOwner {\n        buyLiquidityFee = _liquidityFee;\n        buySendEthFee = _sendEthFee;\n        buyTotalFees = buyLiquidityFee + buySendEthFee;\n        require(buyTotalFees <= 10, \"Must keep buy fees at 10% or less\");\n    }\n\n    function updateSellFees(uint256 _liquidityFee, uint256 _sendEthFee) external onlyOwner {\n        sellLiquidityFee = _liquidityFee;\n        sellSendEthFee = _sendEthFee;\n        sellTotalFees = sellLiquidityFee + sellSendEthFee;\n        require(sellTotalFees <= 10, \"Must keep sell fees at 10% or less\");\n    }\n\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        isExcludedFromFees[account] = excluded;\n        emit ExcludeFromFees(account, excluded);\n    }\n\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n        require(pair != uniswapV2Pair, \"The pair cannot be removed from tradingPairs\");\n        _setAutomatedMarketMakerPair(pair, value);\n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        tradingPairs[pair] = value;\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    function updateSendEthWallet(address newSendEthWallet) external onlyOwner {\n        emit SendEthWalletUpdated(newSendEthWallet, sendEthHere);\n        sendEthHere = newSendEthWallet;\n    }\n\n    function setBlacklist(address _address, bool _isBlacklisted) external onlyOwner {\n        blacklist[_address] = _isBlacklisted;\n    }\n\n    function finalize() external onlyOwner {\n        limitOn = false;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(!blacklist[to] && !blacklist[from], \"bl\");\n\n        if (amount == 0) {\n          super._transfer(from, to, 0);\n          return;\n        }\n\n        if (\n            limitOn &&\n            from != owner() &&\n            to != owner() &&\n            to != address(0xdead) &&\n            !swapping &&\n            tradingPairs[from] // when buy\n        ) {\n            require(amount + balanceOf(to) <= maxHoldingAmount, \"Too many tokens\");\n        }\n\n    \t\tuint256 contractTokenBalance = balanceOf(address(this));\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if (\n            canSwap &&\n            swapEnabled &&\n            !swapping &&\n            !tradingPairs[from] &&\n            !isExcludedFromFees[from] &&\n            !isExcludedFromFees[to]\n        ) {\n            swapping = true;\n            swapBack();\n            swapping = false;\n        }\n\n        bool takeFee = !swapping;\n        if (isExcludedFromFees[from] || isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n\n        uint256 fees = 0;\n        // only take fees on buys/sells, do not take on wallet transfers\n        if (takeFee) {\n            if (tradingPairs[to] && sellTotalFees > 0) {\n                // on sell\n                fees = amount.mul(sellTotalFees).div(100);\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\n                tokensForSendEth += fees * sellSendEthFee / sellTotalFees;\n            } else if (tradingPairs[from] && buyTotalFees > 0) {\n                // on buy\n          \t    fees = amount.mul(buyTotalFees).div(100);\n          \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForSendEth += fees * buySendEthFee / buyTotalFees;\n            }\n\n            if (fees > 0) {\n                super._transfer(from, address(this), fees);\n            }\n\n          \tamount -= fees;\n        }\n\n        super._transfer(from, to, amount);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0,\n            0,\n            address(0xdead),\n            block.timestamp\n        );\n    }\n\n    function swapBack() private {\n        uint256 contractBalance = balanceOf(address(this));\n        if (contractBalance == 0 || tokensForLiquidity == 0 || tokensForSendEth == 0) {\n          return;\n        }\n        uint256 _tokensForLiquidity = tokensForLiquidity.div(2);\n        uint256 tokensToSwapForEth = contractBalance.sub(_tokensForLiquidity);\n        swapTokensForEth(tokensToSwapForEth);\n        uint256 divisor = buyTotalFees.add(sellTotalFees).sub(1);\n        uint256 ethForLiquidity = address(this).balance.div(divisor);\n        tokensForLiquidity = 0;\n        tokensForSendEth = 0;\n        if (_tokensForLiquidity > 0 && ethForLiquidity > 0) {\n            addLiquidity(_tokensForLiquidity, ethForLiquidity);\n            emit SwapAndLiquify(tokensToSwapForEth, ethForLiquidity, tokensForLiquidity);\n        }\n        (bool success,) = address(sendEthHere).call{value: address(this).balance}(\"\");\n        require(success, \"failed to send to buyback wallet\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}