{{
  "language": "Solidity",
  "sources": {
    "1.sol": {
      "content": "/**\r\nA fight to the death..\r\n\r\n8888888888P                  888      \r\n      d88P                   888      \r\n     d88P                    888      \r\n    d88P   888  888  .d8888b 888  888 \r\n   d88P    888  888 d88P\"    888 .88P \r\n  d88P     888  888 888      888888K  \r\n d88P      Y88b 888 Y88b.    888 \"88b \r\nd8888888888 \"Y88888  \"Y8888P 888  888 \r\n                                      \r\n                                      \r\n                                      \r\n                                      \r\n                                      \r\n                                      \r\n      888  888 .d8888b                \r\n      888  888 88K                    \r\n      Y88  88P \"Y8888b.               \r\n       Y8bd8P       X88               \r\n        Y88P    88888P'               \r\n                                      \r\n                                      \r\n                                      \r\n8888888888 888                        \r\n888        888                        \r\n888        888                        \r\n8888888    888  .d88b.  88888b.       \r\n888        888 d88\"\"88b 888 \"88b      \r\n888        888 888  888 888  888      \r\n888        888 Y88..88P 888  888      \r\n8888888888 888  \"Y88P\"  888  888 \r\n\r\n\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.25;\r\n\r\ninterface ERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) external;\r\n}\r\n\r\ncontract ZuckvsElon is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private balances;\r\n  mapping (address => mapping (address => uint256)) private allowed;\r\n  string public constant name  = \"Zuck vs Elon\";\r\n  string public constant symbol = \"DUEL\";\r\n  uint8 public constant decimals = 18;\r\n  address owner;\r\n  uint256 _totalSupply = 1000000000000 * (10 ** 18); // 1 trillion supply\r\n\r\n  constructor() public {\r\n    balances[msg.sender] = _totalSupply;\r\n    owner = msg.sender;\r\n    emit Transfer(address(0), msg.sender, _totalSupply);\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address player) public view returns (uint256) {\r\n    return balances[player];\r\n  }\r\n\r\n  function allowance(address player, address spender) public view returns (uint256) {\r\n    return allowed[player][spender];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    require(value <= balances[msg.sender]);\r\n    require(to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(value);\r\n    balances[to] = balances[to].add(value);\r\n\r\n    emit Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\r\n    for (uint256 i = 0; i < receivers.length; i++) {\r\n      transfer(receivers[i], amounts[i]);\r\n    }\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n    allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function approveAndCall(address spender, uint256 tokens, bytes data) external returns (bool) {\r\n    allowed[msg.sender][spender] = tokens;\r\n    emit Approval(msg.sender, spender, tokens);\r\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    require(value <= balances[from]);\r\n    require(value <= allowed[from][msg.sender]);\r\n    require(to != address(0));\r\n\r\n    balances[from] = balances[from].sub(value);\r\n    balances[to] = balances[to].add(value);\r\n\r\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n\r\n    emit Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);\r\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].sub(subtractedValue);\r\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  function burn(uint256 amount) external {\r\n    require(amount != 0);\r\n    require(amount <= balances[msg.sender]);\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    balances[msg.sender] = balances[msg.sender].sub(amount);\r\n    emit Transfer(msg.sender, address(0), amount);\r\n  }\r\n  \r\n  function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}