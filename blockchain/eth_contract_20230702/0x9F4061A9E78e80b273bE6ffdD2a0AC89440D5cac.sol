{{
  "language": "Solidity",
  "sources": {
    "mpepe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n//telegram: https://t.me/MuskPepeGateway\n//twitter: https://twitter.com/MuskPepe\n// website: muskpepe.com ( Not live at launch )\npragma solidity 0.8.9;\n \n\n\ninterface IUniswapV2Factory {\n function createPair(address tokenA, address tokenB) external returns(address pair);\n}\n\ninterface IERC20 {\n /**\n * @dev Returns the amount of tokens in existence.\n */\n function totalSupply() external view returns(uint256);\n\n /**\n * @dev Returns the amount of tokens owned by `account`.\n */\n function balanceOf(address account) external view returns(uint256);\n\n /**\n * @dev Moves `amount` tokens from the caller's account to `recipient`.\n *\n * Returns a boolean value indicating whether the operation succeeded.\n *\n * Emits a {Transfer} event.\n */\n function transfer(address recipient, uint256 amount) external returns(bool);\n\n /**\n * @dev Returns the remaining number of tokens that `spender` will be\n * allowed to spend on behalf of `owner` through {transferFrom}. This is\n * zero by default.\n *\n * This value changes when {approve} or {transferFrom} are called.\n */\n function allowance(address owner, address spender) external view returns(uint256);\n\n /**\n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n *\n * Returns a boolean value indicating whether the operation succeeded.\n *\n * IMPORTANT: Beware that changing an allowance with this method brings the risk\n * that someone may use both the old and the new allowance by unfortunate\n * transaction ordering. One possible solution to mitigate this race\n * condition is to first reduce the spender's allowance to 0 and set the\n * desired value afterwards:\n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n *\n * Emits an {Approval} event.\n */\n function approve(address spender, uint256 amount) external returns(bool);\n\n /**\n * @dev Moves `amount` tokens from `sender` to `recipient` using the\n * allowance mechanism. `amount` is then deducted from the caller's\n * allowance.\n *\n * Returns a boolean value indicating whether the operation succeeded.\n *\n * Emits a {Transfer} event.\n */\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) external returns(bool);\n\n /**\n * @dev Emitted when `value` tokens are moved from one account (`from`) to\n * another (`to`).\n *\n * Note that `value` may be zero.\n */\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n /**\n * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n * a call to {approve}. `value` is the new allowance.\n */\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n /**\n * @dev Returns the name of the token.\n */\n function name() external view returns(string memory);\n\n /**\n * @dev Returns the symbol of the token.\n */\n function symbol() external view returns(string memory);\n\n /**\n * @dev Returns the decimals places of the token.\n */\n function decimals() external view returns(uint8);\n}\n\nabstract contract Context {\n function _msgSender() internal view virtual returns(address) {\n return msg.sender;\n }\n\n}\n\n \ncontract ERC20 is Context, IERC20, IERC20Metadata {\n using SafeMath for uint256;\n\n mapping(address => uint256) private _balances;\n\n mapping(address => mapping(address => uint256)) private _allowances;\n \n uint256 private _totalSupply;\n \n string private _name;\n string private _symbol;\n\n /**\n * @dev Sets the values for {name} and {symbol}.\n *\n * The default value of {decimals} is 18. To select a different value for\n * {decimals} you should overload it.\n *\n * All two of these values are immutable: they can only be set once during\n * construction.\n */\n constructor(string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n }\n\n /**\n * @dev Returns the name of the token.\n */\n function name() public view virtual override returns(string memory) {\n return _name;\n }\n\n /**\n * @dev Returns the symbol of the token, usually a shorter version of the\n * name.\n */\n function symbol() public view virtual override returns(string memory) {\n return _symbol;\n }\n\n /**\n * @dev Returns the number of decimals used to get its user representation.\n * For example, if `decimals` equals `2`, a balance of `505` tokens should\n * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n *\n * Tokens usually opt for a value of 18, imitating the relationship between\n * Ether and Wei. This is the value {ERC20} uses, unless this function is\n * overridden;\n *\n * NOTE: This information is only used for _display_ purposes: it in\n * no way affects any of the arithmetic of the contract, including\n * {IERC20-balanceOf} and {IERC20-transfer}.\n */\n function decimals() public view virtual override returns(uint8) {\n return 18;\n }\n\n /**\n * @dev See {IERC20-totalSupply}.\n */\n function totalSupply() public view virtual override returns(uint256) {\n return _totalSupply;\n }\n\n /**\n * @dev See {IERC20-balanceOf}.\n */\n function balanceOf(address account) public view virtual override returns(uint256) {\n return _balances[account];\n }\n\n /**\n * @dev See {IERC20-transfer}.\n *\n * Requirements:\n *\n * - `recipient` cannot be the zero address.\n * - the caller must have a balance of at least `amount`.\n */\n function transfer(address recipient, uint256 amount) public virtual override returns(bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n /**\n * @dev See {IERC20-allowance}.\n */\n function allowance(address owner, address spender) public view virtual override returns(uint256) {\n return _allowances[owner][spender];\n }\n\n /**\n * @dev See {IERC20-approve}.\n *\n * Requirements:\n *\n * - `spender` cannot be the zero address.\n */\n function approve(address spender, uint256 amount) public virtual override returns(bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n /**\n * @dev See {IERC20-transferFrom}.\n *\n * Emits an {Approval} event indicating the updated allowance. This is not\n * required by the EIP. See the note at the beginning of {ERC20}.\n *\n * Requirements:\n *\n * - `sender` and `recipient` cannot be the zero address.\n * - `sender` must have a balance of at least `amount`.\n * - the caller must have allowance for ``sender``'s tokens of at least\n * `amount`.\n */\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public virtual override returns(bool) {\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n return true;\n }\n\n /**\n * @dev Atomically increases the allowance granted to `spender` by the caller.\n *\n * This is an alternative to {approve} that can be used as a mitigation for\n * problems described in {IERC20-approve}.\n *\n * Emits an {Approval} event indicating the updated allowance.\n *\n * Requirements:\n *\n * - `spender` cannot be the zero address.\n */\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns(bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n return true;\n }\n\n /**\n * @dev Atomically decreases the allowance granted to `spender` by the caller.\n *\n * This is an alternative to {approve} that can be used as a mitigation for\n * problems described in {IERC20-approve}.\n *\n * Emits an {Approval} event indicating the updated allowance.\n *\n * Requirements:\n *\n * - `spender` cannot be the zero address.\n * - `spender` must have allowance for the caller of at least\n * `subtractedValue`.\n */\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns(bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased cannot be below zero\"));\n return true;\n }\n\n /**\n * @dev Moves tokens `amount` from `sender` to `recipient`.\n *\n * This is internal function is equivalent to {transfer}, and can be used to\n * e.g. implement automatic token fees, slashing mechanisms, etc.\n *\n * Emits a {Transfer} event.\n *\n * Requirements:\n *\n * - `sender` cannot be the zero address.\n * - `recipient` cannot be the zero address.\n * - `sender` must have a balance of at least `amount`.\n */\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n \n _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n _balances[recipient] = _balances[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n }\n\n /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n * the total supply.\n *\n * Emits a {Transfer} event with `from` set to the zero address.\n *\n * Requirements:\n *\n * - `account` cannot be the zero address.\n */\n function _mint(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }\n\n \n /**\n * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n *\n * This internal function is equivalent to `approve`, and can be used to\n * e.g. set automatic allowances for certain subsystems, etc.\n *\n * Emits an {Approval} event.\n *\n * Requirements:\n *\n * - `owner` cannot be the zero address.\n * - `spender` cannot be the zero address.\n */\n function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n \n}\n \nlibrary SafeMath {\n \n function add(uint256 a, uint256 b) internal pure returns(uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n \n function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n \n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n \n if (a == 0) {\n return 0;\n }\n \n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n \n function div(uint256 a, uint256 b) internal pure returns(uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n \n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n return c;\n }\n\n \n}\n \ncontract Ownable is Context {\n address private _owner;\n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n /**\n * @dev Initializes the contract setting the deployer as the initial owner.\n */\n constructor() {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n /**\n * @dev Returns the address of the current owner.\n */\n function owner() public view returns(address) {\n return _owner;\n }\n\n /**\n * @dev Throws if called by any account other than the owner.\n */\n modifier onlyOwner() {\n require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n _;\n }\n\n /**\n * @dev Leaves the contract without owner. It will not be possible to call\n * `onlyOwner` functions anymore. Can only be called by the current owner.\n *\n * NOTE: Renouncing ownership will leave the contract without an owner,\n * thereby removing any functionality that is only available to the owner.\n */\n function renounceOwnership() public virtual onlyOwner {\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n /**\n * @dev Transfers ownership of the contract to a new account (`newOwner`).\n * Can only be called by the current owner.\n */\n function transferOwnership(address newOwner) public virtual onlyOwner {\n require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n emit OwnershipTransferred(_owner, newOwner);\n _owner = newOwner;\n }\n}\n \n \n \nlibrary SafeMathInt {\n int256 private constant MIN_INT256 = int256(1) << 255;\n int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n /**\n * @dev Multiplies two int256 variables and fails on overflow.\n */\n function mul(int256 a, int256 b) internal pure returns(int256) {\n int256 c = a * b;\n\n // Detect overflow when multiplying MIN_INT256 with -1\n require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n require((b == 0) || (c / b == a));\n return c;\n }\n\n /**\n * @dev Division of two int256 variables and fails on overflow.\n */\n function div(int256 a, int256 b) internal pure returns(int256) {\n // Prevent overflow when dividing MIN_INT256 by -1\n require(b != -1 || a != MIN_INT256);\n\n // Solidity already throws when dividing by 0.\n return a / b;\n }\n\n /**\n * @dev Subtracts two int256 variables and fails on overflow.\n */\n function sub(int256 a, int256 b) internal pure returns(int256) {\n int256 c = a - b;\n require((b >= 0 && c <= a) || (b < 0 && c > a));\n return c;\n }\n\n /**\n * @dev Adds two int256 variables and fails on overflow.\n */\n function add(int256 a, int256 b) internal pure returns(int256) {\n int256 c = a + b;\n require((b >= 0 && c >= a) || (b < 0 && c < a));\n return c;\n }\n\n /**\n * @dev Converts to absolute value, and fails on overflow.\n */\n function abs(int256 a) internal pure returns(int256) {\n require(a != MIN_INT256);\n return a < 0 ? -a : a;\n }\n\n\n function toUint256Safe(int256 a) internal pure returns(uint256) {\n require(a >= 0);\n return uint256(a);\n }\n}\n \nlibrary SafeMathUint {\n function toInt256Safe(uint256 a) internal pure returns(int256) {\n int256 b = int256(a);\n require(b >= 0);\n return b;\n }\n}\n\n\ninterface IUniswapV2Router01 {\n function factory() external pure returns(address);\n function WETH() external pure returns(address);\n\n function addLiquidity(\n address tokenA,\n address tokenB,\n uint amountADesired,\n uint amountBDesired,\n uint amountAMin,\n uint amountBMin,\n address to,\n uint deadline\n ) external returns(uint amountA, uint amountB, uint liquidity);\n function addLiquidityETH(\n address token,\n uint amountTokenDesired,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline\n ) external payable returns(uint amountToken, uint amountETH, uint liquidity);\n function removeLiquidity(\n address tokenA,\n address tokenB,\n uint liquidity,\n uint amountAMin,\n uint amountBMin,\n address to,\n uint deadline\n ) external returns(uint amountA, uint amountB);\n function removeLiquidityETH(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline\n ) external returns(uint amountToken, uint amountETH);\n function removeLiquidityWithPermit(\n address tokenA,\n address tokenB,\n uint liquidity,\n uint amountAMin,\n uint amountBMin,\n address to,\n uint deadline,\n bool approveMax, uint8 v, bytes32 r, bytes32 s\n ) external returns(uint amountA, uint amountB);\n function removeLiquidityETHWithPermit(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline,\n bool approveMax, uint8 v, bytes32 r, bytes32 s\n ) external returns(uint amountToken, uint amountETH);\n function swapExactTokensForTokens(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external returns(uint[] memory amounts);\n function swapTokensForExactTokens(\n uint amountOut,\n uint amountInMax,\n address[] calldata path,\n address to,\n uint deadline\n ) external returns(uint[] memory amounts);\n function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n external\n payable\n returns(uint[] memory amounts);\n function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n external\n returns(uint[] memory amounts);\n function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n external\n returns(uint[] memory amounts);\n function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n external\n payable\n returns(uint[] memory amounts);\n\n function quote(uint amountA, uint reserveA, uint reserveB) external pure returns(uint amountB);\n function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns(uint amountOut);\n function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns(uint amountIn);\n function getAmountsOut(uint amountIn, address[] calldata path) external view returns(uint[] memory amounts);\n function getAmountsIn(uint amountOut, address[] calldata path) external view returns(uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n function removeLiquidityETHSupportingFeeOnTransferTokens(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline\n ) external returns(uint amountETH);\n function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n address token,\n uint liquidity,\n uint amountTokenMin,\n uint amountETHMin,\n address to,\n uint deadline,\n bool approveMax, uint8 v, bytes32 r, bytes32 s\n ) external returns(uint amountETH);\n\n function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external;\n function swapExactETHForTokensSupportingFeeOnTransferTokens(\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external payable;\n function swapExactTokensForETHSupportingFeeOnTransferTokens(\n uint amountIn,\n uint amountOutMin,\n address[] calldata path,\n address to,\n uint deadline\n ) external;\n}\n \ncontract MUSK is ERC20, Ownable {\n using SafeMath for uint256;\n\n IUniswapV2Router02 public immutable router;\n address public immutable uniswapV2Pair;\n\n\n // addresses\n address public devWallet;\n address private marketingWallet;\n\n // limits \n uint256 private maxBuyAmount;\n uint256 private maxSellAmount; \n uint256 private maxWalletAmount;\n \n uint256 private thresholdSwapAmount;\n\n // status flags\n bool private isTrading = false;\n bool public swapEnabled = false;\n bool public isSwapping;\n\n\n struct Fees {\n uint8 buyTotalFees;\n uint8 buyMarketingFee;\n uint8 buyDevFee;\n uint8 buyLiquidityFee;\n\n uint8 sellTotalFees;\n uint8 sellMarketingFee;\n uint8 sellDevFee;\n uint8 sellLiquidityFee;\n } \n\n Fees public _fees = Fees({\n buyTotalFees: 0,\n buyMarketingFee: 0,\n buyDevFee:0,\n buyLiquidityFee: 0,\n\n sellTotalFees: 0,\n sellMarketingFee: 0,\n sellDevFee:0,\n sellLiquidityFee: 0\n });\n \n \n\n uint256 public tokensForMarketing;\n uint256 public tokensForLiquidity;\n uint256 public tokensForDev;\n uint256 private taxTill;\n // exclude from fees and max transaction amount\n mapping(address => bool) private _isExcludedFromFees;\n mapping(address => bool) public _isExcludedMaxTransactionAmount;\n mapping(address => bool) public _isExcludedMaxWalletAmount;\n\n // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n // could be subject to a maximum transfer amount\n mapping(address => bool) public marketPair;\n mapping(address => bool) public _isBlacklisted;\n \n \n event SwapAndLiquify(\n uint256 tokensSwapped,\n uint256 ethReceived\n );\n\n\n constructor() ERC20(\"Musk Pepe\", \"MUSKPEPE\") {\n \n router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n\n uniswapV2Pair = IUniswapV2Factory(router.factory()).createPair(address(this), router.WETH());\n\n _isExcludedMaxTransactionAmount[address(router)] = true;\n _isExcludedMaxTransactionAmount[address(uniswapV2Pair)] = true; \n _isExcludedMaxTransactionAmount[owner()] = true;\n _isExcludedMaxTransactionAmount[address(this)] = true;\n\n _isExcludedFromFees[owner()] = true;\n _isExcludedFromFees[address(this)] = true;\n\n _isExcludedMaxWalletAmount[owner()] = true;\n _isExcludedMaxWalletAmount[address(this)] = true;\n _isExcludedMaxWalletAmount[address(uniswapV2Pair)] = true;\n\n\n marketPair[address(uniswapV2Pair)] = true;\n\n approve(address(router), type(uint256).max);\n uint256 totalSupply = 1e10 * 1e18;\n\n maxBuyAmount = totalSupply * 1 / 100; // 1% maxTransactionAmountTxn\n maxSellAmount = totalSupply * 1 / 100; // 1% maxTransactionAmountTxn\n maxWalletAmount = totalSupply * 1 / 100; // 1% maxWallet\n thresholdSwapAmount = totalSupply * 1 / 10000; // 0.01% swap wallet\n\n _fees.buyMarketingFee = 25;\n _fees.buyLiquidityFee = 0;\n _fees.buyDevFee = 5;\n _fees.buyTotalFees = _fees.buyMarketingFee + _fees.buyLiquidityFee + _fees.buyDevFee;\n\n _fees.sellMarketingFee = 28;\n _fees.sellLiquidityFee = 0;\n _fees.sellDevFee = 2;\n _fees.sellTotalFees = _fees.sellMarketingFee + _fees.sellLiquidityFee + _fees.sellDevFee;\n\n\n marketingWallet = address(0x8d0eb111b837930aCD56AD4bd6656bbFeE968949);\n devWallet = address(0xEc552Be973De7A1F13F704126F8b679D56b46Db7);\n\n // exclude from paying fees or having max transaction amount\n\n /*\n _mint is an internal function in ERC20.sol that is only called here,\n and CANNOT be called ever again\n */\n _mint(msg.sender, totalSupply);\n }\n\n receive() external payable {\n\n }\n\n // once enabled, can never be turned off\n function swapTrading() external onlyOwner {\n isTrading = true;\n swapEnabled = true;\n taxTill = block.number + 2;\n }\n\n\n\n // change the minimum amount of tokens to sell from fees\n function updateThresholdSwapAmount(uint256 newAmount) external onlyOwner returns(bool){\n thresholdSwapAmount = newAmount;\n return true;\n }\n\n\n function updateMaxTxnAmount(uint256 newMaxBuy, uint256 newMaxSell) external onlyOwner {\n require(((totalSupply() * newMaxBuy) / 1000) >= (totalSupply() / 100), \"maxBuyAmount must be higher than 1%\");\n require(((totalSupply() * newMaxSell) / 1000) >= (totalSupply() / 100), \"maxSellAmount must be higher than 1%\");\n maxBuyAmount = (totalSupply() * newMaxBuy) / 1000;\n maxSellAmount = (totalSupply() * newMaxSell) / 1000;\n }\n\n\n function updateMaxWalletAmount(uint256 newPercentage) external onlyOwner {\n require(((totalSupply() * newPercentage) / 1000) >= (totalSupply() / 100), \"Cannot set maxWallet lower than 1%\");\n maxWalletAmount = (totalSupply() * newPercentage) / 1000;\n }\n\n // only use to disable contract sales if absolutely necessary (emergency use only)\n function toggleSwapEnabled(bool enabled) external onlyOwner(){\n swapEnabled = enabled;\n }\n\n function blacklistAddress(address account, bool value) external onlyOwner{\n _isBlacklisted[account] = value;\n }\n\n function updateFees(uint8 _marketingFeeBuy, uint8 _liquidityFeeBuy,uint8 _devFeeBuy,uint8 _marketingFeeSell, uint8 _liquidityFeeSell,uint8 _devFeeSell) external onlyOwner{\n _fees.buyMarketingFee = _marketingFeeBuy;\n _fees.buyLiquidityFee = _liquidityFeeBuy;\n _fees.buyDevFee = _devFeeBuy;\n _fees.buyTotalFees = _fees.buyMarketingFee + _fees.buyLiquidityFee + _fees.buyDevFee;\n\n _fees.sellMarketingFee = _marketingFeeSell;\n _fees.sellLiquidityFee = _liquidityFeeSell;\n _fees.sellDevFee = _devFeeSell;\n _fees.sellTotalFees = _fees.sellMarketingFee + _fees.sellLiquidityFee + _fees.sellDevFee;\n require(_fees.buyTotalFees <= 30, \"Must keep fees at 30% or less\"); \n require(_fees.sellTotalFees <= 30, \"Must keep fees at 30% or less\");\n \n }\n \n function excludeFromFees(address account, bool excluded) public onlyOwner {\n _isExcludedFromFees[account] = excluded;\n }\n function excludeFromWalletLimit(address account, bool excluded) public onlyOwner {\n _isExcludedMaxWalletAmount[account] = excluded;\n }\n function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\n _isExcludedMaxTransactionAmount[updAds] = isEx;\n }\n\n\n function setMarketPair(address pair, bool value) public onlyOwner {\n require(pair != uniswapV2Pair, \"Must keep uniswapV2Pair\");\n marketPair[pair] = value;\n }\n\n\n function setWallets(address _marketingWallet,address _devWallet) external onlyOwner{\n marketingWallet = _marketingWallet;\n devWallet = _devWallet;\n }\n\n function isExcludedFromFees(address account) public view returns(bool) {\n return _isExcludedFromFees[account];\n }\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n \n ) internal override {\n \n if (amount == 0) {\n super._transfer(sender, recipient, 0);\n return;\n }\n\n if (\n sender != owner() &&\n recipient != owner() &&\n !isSwapping\n ) {\n\n if (!isTrading) {\n require(_isExcludedFromFees[sender] || _isExcludedFromFees[recipient], \"Trading is not active.\");\n }\n if (marketPair[sender] && !_isExcludedMaxTransactionAmount[recipient]) {\n require(amount <= maxBuyAmount, \"buy transfer over max amount\");\n } \n else if (marketPair[recipient] && !_isExcludedMaxTransactionAmount[sender]) {\n require(amount <= maxSellAmount, \"Sell transfer over max amount\");\n }\n\n if (!_isExcludedMaxWalletAmount[recipient]) {\n require(amount + balanceOf(recipient) <= maxWalletAmount, \"Max wallet exceeded\");\n }\n require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], \"Blacklisted address\");\n }\n \n \n \n uint256 contractTokenBalance = balanceOf(address(this));\n \n bool canSwap = contractTokenBalance >= thresholdSwapAmount;\n\n if (\n canSwap &&\n swapEnabled &&\n !isSwapping &&\n marketPair[recipient] &&\n !_isExcludedFromFees[sender] &&\n !_isExcludedFromFees[recipient]\n ) {\n isSwapping = true;\n swapBack();\n isSwapping = false;\n }\n \n bool takeFee = !isSwapping;\n\n // if any account belongs to _isExcludedFromFee account then remove the fee\n if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) {\n takeFee = false;\n }\n \n \n // only take fees on buys/sells, do not take on wallet transfers\n if (takeFee) {\n uint256 fees = 0;\n if(block.number < taxTill) {\n fees = amount.mul(99).div(100);\n tokensForMarketing += (fees * 94) / 99;\n tokensForDev += (fees * 5) / 99;\n } else if (marketPair[recipient] && _fees.sellTotalFees > 0) {\n fees = amount.mul(_fees.sellTotalFees).div(100);\n tokensForLiquidity += fees * _fees.sellLiquidityFee / _fees.sellTotalFees;\n tokensForMarketing += fees * _fees.sellMarketingFee / _fees.sellTotalFees;\n tokensForDev += fees * _fees.sellDevFee / _fees.sellTotalFees;\n }\n // on buy\n else if (marketPair[sender] && _fees.buyTotalFees > 0) {\n fees = amount.mul(_fees.buyTotalFees).div(100);\n tokensForLiquidity += fees * _fees.buyLiquidityFee / _fees.buyTotalFees;\n tokensForMarketing += fees * _fees.buyMarketingFee / _fees.buyTotalFees;\n tokensForDev += fees * _fees.buyDevFee / _fees.buyTotalFees;\n }\n\n if (fees > 0) {\n super._transfer(sender, address(this), fees);\n }\n\n amount -= fees;\n\n }\n\n super._transfer(sender, recipient, amount);\n }\n\n function swapTokensForEth(uint256 tAmount) private {\n\n // generate the uniswap pair path of token -> weth\n address[] memory path = new address[](2);\n path[0] = address(this);\n path[1] = router.WETH();\n\n _approve(address(this), address(router), tAmount);\n\n // make the swap\n router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n tAmount,\n 0, // accept any amount of ETH\n path,\n address(this),\n block.timestamp\n );\n\n }\n\n function addLiquidity(uint256 tAmount, uint256 ethAmount) private {\n // approve token transfer to cover all possible scenarios\n _approve(address(this), address(router), tAmount);\n\n // add the liquidity\n router.addLiquidityETH{ value: ethAmount } (address(this), tAmount, 0, 0 , address(this), block.timestamp);\n }\n\n function swapBack() private {\n uint256 contractTokenBalance = balanceOf(address(this));\n uint256 toSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\n bool success;\n\n if (contractTokenBalance == 0 || toSwap == 0) { return; }\n\n if (contractTokenBalance > thresholdSwapAmount * 20) {\n contractTokenBalance = thresholdSwapAmount * 20;\n }\n\n // Halve the amount of liquidity tokens\n uint256 liquidityTokens = contractTokenBalance * tokensForLiquidity / toSwap / 2;\n uint256 amountToSwapForETH = contractTokenBalance.sub(liquidityTokens);\n \n uint256 initialETHBalance = address(this).balance;\n\n swapTokensForEth(amountToSwapForETH); \n \n uint256 newBalance = address(this).balance.sub(initialETHBalance);\n \n uint256 ethForMarketing = newBalance.mul(tokensForMarketing).div(toSwap);\n uint256 ethForDev = newBalance.mul(tokensForDev).div(toSwap);\n uint256 ethForLiquidity = newBalance - (ethForMarketing + ethForDev);\n\n\n tokensForLiquidity = 0;\n tokensForMarketing = 0;\n tokensForDev = 0;\n\n\n if (liquidityTokens > 0 && ethForLiquidity > 0) {\n addLiquidity(liquidityTokens, ethForLiquidity);\n emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity);\n }\n\n (success,) = address(devWallet).call{ value: (address(this).balance - ethForMarketing) } (\"\");\n (success,) = address(marketingWallet).call{ value: address(this).balance } (\"\");\n }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}