{"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"ERC20UniswapV2InternalSwaps.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.18;\n\nimport {ERC20} from \"ERC20.sol\";\n\ninterface IUniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function mint(address to) external;\n}\n\ninterface IUniswapV2Factory {\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint amount) external;\n\n    function balanceOf(address account) external view returns (uint);\n\n    function approve(address spender, uint256 amount) external;\n}\n\ninterface IWETH {\n    function deposit() external payable;\n}\n\n/**\n * @notice UniswapV2Pair does not allow to receive to token0 or token1.\n * As a workaround, this contract can receive tokens and has max approval\n * for the creator.\n */\ncontract ERC20HolderWithApproval {\n    constructor(address token) {\n        IERC20(token).approve(msg.sender, type(uint256).max);\n    }\n}\n\n/**\n * @notice Gas optimized ERC20 token based on solmate\u0027s ERC20 contract.\n * @dev Optimizations assume a UniswapV2 WETH pair as main liquidity.\n */\nabstract contract ERC20UniswapV2InternalSwaps is ERC20 {\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant FACTORY =\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address private immutable wethReceiver;\n    address public immutable pair;\n\n    error InvalidAddress();\n\n    constructor() {\n        // assumption to save additional gas\n        if (address(this) \u003e= WETH) {\n            revert InvalidAddress();\n        }\n        pair = IUniswapV2Factory(FACTORY).createPair(address(this), WETH);\n        wethReceiver = address(new ERC20HolderWithApproval(WETH));\n    }\n\n    /**\n     * @dev Swap tokens to WETH directly on pair, to save gas.\n     * No check for minimal return, susceptible to price manipulation!\n     */\n    function _swapForWETH(uint amountToken, address to) internal {\n        uint amountWeth = _getAmountWeth(amountToken);\n        _transferFromContractBalance(pair, amountToken);\n        // Pair prevents receiving tokens to one of the pairs addresses\n        IUniswapV2Pair(pair).swap(0, amountWeth, wethReceiver, new bytes(0));\n        IERC20(WETH).transferFrom(wethReceiver, to, amountWeth);\n    }\n\n    /**\n     * @dev Add tokens and WETH to liquidity, directly on pair, to save gas.\n     * No check for minimal return, susceptible to price manipulation!\n     * Sufficient WETH in contract balancee assumed!\n     */\n    function _addLiquidity(\n        uint amountToken,\n        address to\n    ) internal returns (uint amountWeth) {\n        amountWeth = _quoteToken(amountToken);\n        _transferFromContractBalance(pair, amountToken);\n        IERC20(WETH).transferFrom(address(this), pair, amountWeth);\n        IUniswapV2Pair(pair).mint(to);\n    }\n\n    /**\n     * @dev Add tokens and WETH as initial liquidity, directly on pair, to save gas.\n     * No checks performed. Caller has to make sure to have access to the token before public!\n     * Sufficient WETH in contract balancee assumed!\n     */\n    function _addInitialLiquidity(\n        uint amountToken,\n        uint amountWeth,\n        address to\n    ) internal {\n        _transferFromContractBalance(pair, amountToken);\n        IERC20(WETH).transferFrom(address(this), pair, amountWeth);\n        IUniswapV2Pair(pair).mint(to);\n    }\n\n    /**\n     * @dev Add tokens and ETH as initial liquidity, directly on pair, to save gas.\n     * No checks performed. Caller has to make sure to have access to the token before public!\n     * Sufficient ETH in contract balancee assumed!\n     */\n    function _addInitialLiquidityEth(\n        uint amountToken,\n        uint amountEth,\n        address to\n    ) internal {\n        IWETH(WETH).deposit{value: amountEth}();\n        _addInitialLiquidity(amountToken, amountEth, to);\n    }\n\n    /** @dev Transfer all WETH from contract balance to `to`. */\n    function _sweepWeth(address to) internal returns (uint amountWeth) {\n        amountWeth = IERC20(WETH).balanceOf(address(this));\n        IERC20(WETH).transferFrom(address(this), to, amountWeth);\n    }\n\n    /** @dev Transfer all ETH from contract balance to `to`. */\n    function _sweepEth(address to) internal {\n        _safeTransferETH(to, address(this).balance);\n    }\n\n    /** @dev Quote `amountToken` in ETH, assuming no fees (used for liquidity). */\n    function _quoteToken(\n        uint amountToken\n    ) internal view returns (uint amountEth) {\n        (uint reserveToken, uint reserveEth) = IUniswapV2Pair(pair)\n            .getReserves();\n        amountEth = (amountToken * reserveEth) / reserveToken;\n    }\n\n    /** @dev Quote `amountToken` in WETH, assuming 0.3% uniswap fees (used for swap). */\n    function _getAmountWeth(\n        uint amounToken\n    ) internal view returns (uint amountWeth) {\n        (uint reserveToken, uint reserveWeth) = IUniswapV2Pair(pair)\n            .getReserves();\n        uint amountTokenWithFee = amounToken * 997;\n        uint numerator = amountTokenWithFee * reserveWeth;\n        uint denominator = (reserveToken * 1000) + amountTokenWithFee;\n        amountWeth = numerator / denominator;\n    }\n\n    /** @dev Quote `amountWeth` in tokens, assuming 0.3% uniswap fees (used for swap). */\n    function _getAmountToken(\n        uint amounWeth,\n        uint reserveToken,\n        uint reserveWeth\n    ) internal pure returns (uint amountToken) {\n        uint numerator = reserveToken * amounWeth * 1000;\n        uint denominator = (reserveWeth - amounWeth) * 997;\n        amountToken = (numerator / denominator) + 1;\n    }\n\n    /** @dev Get reserves of pair. */\n    function _getReserve()\n        internal\n        view\n        returns (uint reserveToken, uint reserveWeth)\n    {\n        (reserveToken, reserveWeth) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    /** @dev Transfer `amount` ETH to `to` gas efficiently. */\n    function _safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /** @dev Returns true if `_address` is a contract. */\n    function _isContract(address _address) internal view returns (bool) {\n        uint32 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_address)\n        }\n        return (size \u003e 0);\n    }\n\n    /** @dev Transfeer `amount` tokens from contract balance to `to`. */\n    function _transferFromContractBalance(\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        balanceOf[address(this)] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(this), to, amount);\n\n        return true;\n    }\n}\n"},"Owned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"},"SixPackRick.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.18;\n\nimport {ERC20UniswapV2InternalSwaps, ERC20} from \"./ERC20UniswapV2InternalSwaps.sol\";\nimport {Owned} from \"Owned.sol\";\n\n/**\n * @title 6 Pack Rick token contract\n *\n * @notice 6PR has a 2% transfer tax, with 50% of tax used for adding liquidity.\n * 6PR is launched as a fair launch with 132 ETH hardcap.\n *\n * https://6packrick.com\n */\ncontract SixPackRick is\n    ERC20(\"6PackRick\", \"6PR\", 18),\n    ERC20UniswapV2InternalSwaps,\n    Owned\n{\n    /** @notice The presale states. */\n    enum PresaleState {\n        CLOSED,\n        OPEN_FOR_WHITELIST,\n        OPEN_FOR_PUBLIC,\n        COMPLETED\n    }\n\n    /** @notice Percentage of supply allocated for presale participants (50%). */\n    uint256 public constant SHARE_PRESALE = 50;\n    /** @notice Percentage of supply allocated for initial liquidity (30%).*/\n    uint256 public constant SHARE_LIQUIDITY = 30;\n    /** @notice Percentage of supply allocated for team, marketing, cex listings, etc. (20%). */\n    uint256 public constant SHARE_OTHER = 20;\n    /** @notice Hardcap in ETH for presale (132 ETH). */\n    uint256 public constant PRESALE_HARDCAP = 132 ether;\n    /** @notice Per account limit in ETH for presale (0.6 ETH). */\n    uint256 public constant PRESALE_ACCOUNT_LIMIT = 0.6 ether;\n    /** @notice Minimum threshold in ETH to trigger #swapTokensAndAddLiquidity. */\n    uint256 public constant SWAP_THRESHOLD_ETH_MIN = 0.005 ether;\n    /** @notice Maximum threshold in ETH to trigger #swapTokensAndAddLiquidity. */\n    uint256 public constant SWAP_THRESHOLD_ETH_MAX = 50 ether;\n    /** @notice Transfer tax in percent (2%). 50% of this fee is used to add liquidity. */\n    uint256 public constant TRANSFER_TAX = 2;\n\n    uint256 private constant _MAX_SUPPLY = 420_690_000_000_000 ether;\n    uint256 private constant _SUPPLY_PRESALE =\n        (_MAX_SUPPLY * SHARE_PRESALE) / 100;\n    uint256 private constant _SUPPLY_LIQUIDITY =\n        (_MAX_SUPPLY * SHARE_LIQUIDITY) / 100;\n    uint256 private constant _SUPPLY_OTHER =\n        _MAX_SUPPLY - _SUPPLY_PRESALE - _SUPPLY_LIQUIDITY;\n\n    /** @notice Tax recipient wallet. */\n    address public taxRecipient = 0x9134A698F674D3a0D9154Ce812662526E279A8EF;\n    /** @notice Whether address is extempt from transfer tax. */\n    mapping(address =\u003e bool) public taxFreeAccount;\n    /** @notice Whether address is an exchange pool. */\n    mapping(address =\u003e bool) public isExchangePool;\n    /** @notice Threshold in ETH of tokens to collect before triggering #swapTokensAndAddLiquidity. */\n    uint256 public swapThresholdEth = 0.1 ether;\n    /** @notice Tax manager. @dev Can **NOT** change transfer taxes. */\n    address public taxManager;\n    /** @notice Whether address is whitelisted for early presale access. */\n    mapping(address =\u003e bool) public presaleWhitelist;\n    /** @notice Presale commitment in ETH per address. */\n    mapping(address =\u003e uint256) public commitment;\n    /** @notice Presale amount of claimed tokens per address. */\n    mapping(address =\u003e uint256) public claimedTokens;\n    /** @notice Presale total commitment in ETH. */\n    uint256 public totalCommitments;\n    /** @notice Presale total amount of claimed tokens. */\n    uint256 public totalClaimed;\n    /** @notice Current presale state. */\n    PresaleState public presaleState;\n    /** @notice Whether buys and sells in the same block are blocked to prevent sandwitch attacks. */\n    bool public limitPerBlockTransfers = true;\n\n    /** @notice Anti sniper bot measure for initial opening of trading. */\n    uint256 private _tradeableAfterBlock = type(uint256).max;\n    /** @notice Anti sandwitch bot measure while limitPerBlockTransfers is enabled. */\n    mapping(bytes32 =\u003e bool) private _perBlock;\n\n    event CommitedToPresale(address indexed account, uint256 amount);\n    event PresaleOpened();\n    event TradingEnabled();\n    event PublicPresaleOpened();\n    event PresaleCompleted(uint256 totalCommitments);\n    event PresaleClaimed(address indexed account, uint256 amount);\n    event TaxRecipientChanged(address indexed taxRecipient);\n    event SwapThresholdChanged(uint256 swapThresholdEth);\n    event TaxFreeStateChanged(address indexed account, bool indexed taxFree);\n    event ExchangePoolStateChanged(\n        address indexed account,\n        bool indexed isExchangePool\n    );\n    event TaxManagerChanged(address indexed taxManager);\n    event LimitPerBlockTransfersChangeed(bool indexed limitPerBlockTransfers);\n    event SwappedTokensAndAddedLiquidity(\n        uint256 tokensSwapped,\n        uint256 tokensAddedToLiquidity,\n        uint256 wethAddedToLiquidity,\n        uint256 wethCollected\n    );\n\n    error TradingNotOpenYet();\n    error MaxAccountLimitExceeded();\n    error HardcapExceeded();\n    error NotWhitelistedForPresale();\n    error PresaleClosed();\n    error PresaleNotCompleted();\n    error AlreadyClaimed();\n    error NothingCommitted();\n    error Unauthorized();\n    error InvalidSwapThreshold();\n    error NoContract();\n    error TradeAlreadyOpend();\n    error InvalidBlockDelay();\n    error InvalidParameters();\n    error InvalidState();\n    error NoSameBlockBuySell();\n    error ZeroTransfer();\n    error NoCommittments();\n    error TransferToZeroAddress();\n\n    modifier onlyTaxManager() {\n        if (msg.sender != taxManager) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    constructor() Owned(msg.sender) {\n        taxManager = msg.sender;\n        emit TaxManagerChanged(msg.sender);\n\n        taxFreeAccount[msg.sender] = true;\n        emit TaxFreeStateChanged(msg.sender, true);\n        taxFreeAccount[taxRecipient] = true;\n        emit TaxFreeStateChanged(taxRecipient, true);\n        isExchangePool[pair] = true;\n        emit ExchangePoolStateChanged(pair, true);\n\n        _mint(address(this), _SUPPLY_PRESALE + _SUPPLY_LIQUIDITY);\n        _mint(msg.sender, _SUPPLY_OTHER);\n    }\n\n    /** @dev Users can send ETH directly to **this** contract to participate */\n    receive() external payable {\n        commitToPresale();\n    }\n\n    /** @notice IERC20#transfer */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        if (amount == 0) {\n            revert ZeroTransfer();\n        }\n        if (to == address(0)) {\n            revert TransferToZeroAddress();\n        }\n        if (!taxFreeAccount[msg.sender] \u0026\u0026 !taxFreeAccount[to]) {\n            if (block.number \u003c= _tradeableAfterBlock) {\n                revert TradingNotOpenYet();\n            }\n            if (limitPerBlockTransfers) {\n                _enforceTransferLimit(msg.sender, to);\n            }\n\n            uint256 fee = (amount * TRANSFER_TAX) / 100;\n            super.transfer(address(this), fee);\n            unchecked {\n                amount -= fee;\n            }\n\n            if (isExchangePool[to]) {\n                _swapTokensAndAddLiquidity(swapThresholdToken());\n            }\n        }\n        return super.transfer(to, amount);\n    }\n\n    /** @notice IERC20#transferFrom */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        if (amount == 0) {\n            revert ZeroTransfer();\n        }\n        if (to == address(0)) {\n            revert TransferToZeroAddress();\n        }\n        if (\n            !taxFreeAccount[from] \u0026\u0026\n            !taxFreeAccount[to] \u0026\u0026\n            !taxFreeAccount[msg.sender]\n        ) {\n            if (block.number \u003c= _tradeableAfterBlock) {\n                revert TradingNotOpenYet();\n            }\n            if (limitPerBlockTransfers) {\n                _enforceTransferLimit(from, to);\n            }\n\n            uint256 fee = (amount * TRANSFER_TAX) / 100;\n            super.transferFrom(from, address(this), fee);\n            unchecked {\n                amount -= fee;\n            }\n\n            if (isExchangePool[to]) {\n                _swapTokensAndAddLiquidity(swapThresholdToken());\n            }\n        }\n        return super.transferFrom(from, to, amount);\n    }\n\n    // *** Tax Manager Interface ***\n\n    /**\n     * @notice Set `taxFree` state of `account`.\n     * @param account account\n     * @param taxFree true if `account` should be extempt from transfer taxes.\n     * @dev Only callable by taxManager.\n     */\n    function setTaxFreeAccount(\n        address account,\n        bool taxFree\n    ) external onlyTaxManager {\n        if (taxFreeAccount[account] == taxFree) {\n            revert InvalidParameters();\n        }\n        taxFreeAccount[account] = taxFree;\n        emit TaxFreeStateChanged(account, taxFree);\n    }\n\n    /**\n     * @notice Set `exchangePool` state of `account`\n     * @param account account\n     * @param exchangePool whether `account` is an exchangePool\n     * @dev ExchangePool state is used to decide if transfer is a swap\n     * and should trigger #swapTokensAndAddLiquidity.\n     */\n    function setExchangePool(\n        address account,\n        bool exchangePool\n    ) external onlyTaxManager {\n        if (isExchangePool[account] == exchangePool) {\n            revert InvalidParameters();\n        }\n        isExchangePool[account] = exchangePool;\n        emit ExchangePoolStateChanged(account, exchangePool);\n    }\n\n    /**\n     * @notice Transfer taxManager role to `newTaxManager`.\n     * @param newTaxManager new taxManager\n     * @dev Only callable by taxManager.\n     */\n    function transferTaxManager(address newTaxManager) external onlyTaxManager {\n        if (newTaxManager == taxManager) {\n            revert InvalidParameters();\n        }\n        taxManager = newTaxManager;\n        emit TaxManagerChanged(newTaxManager);\n    }\n\n    /**\n     * @notice Change the amount of tokens collected via tax before a swap is triggered.\n     * @param newSwapThresholdEth new threshold received in ETH\n     * @dev Only callable by taxManager\n     */\n    function setSwapThresholdEth(\n        uint256 newSwapThresholdEth\n    ) external onlyTaxManager {\n        if (\n            newSwapThresholdEth \u003c SWAP_THRESHOLD_ETH_MIN ||\n            newSwapThresholdEth \u003e SWAP_THRESHOLD_ETH_MAX ||\n            newSwapThresholdEth == swapThresholdEth\n        ) {\n            revert InvalidSwapThreshold();\n        }\n        swapThresholdEth = newSwapThresholdEth;\n        emit SwapThresholdChanged(newSwapThresholdEth);\n    }\n\n    /**\n     * @notice Set whether or not to limit buy/sells to single per block to prevent\n     * sandwitch attacks.\n     * @param newLimitPerBlockTransfers new state\n     * @dev Only callable by taxManager\n     */\n    function setLimitPerBlockTransfers(\n        bool newLimitPerBlockTransfers\n    ) external onlyTaxManager {\n        if (newLimitPerBlockTransfers == limitPerBlockTransfers) {\n            revert InvalidParameters();\n        }\n        limitPerBlockTransfers = newLimitPerBlockTransfers;\n        emit LimitPerBlockTransfersChangeed(newLimitPerBlockTransfers);\n    }\n\n    /**\n     * @notice Change the address receiving the 1% tax in WETH.\n     * @param newTaxRecipient new adddress receiving the 1% tax in WETH.\n     * @dev Only callable by taxManager.\n     */\n    function setTaxRecipient(address newTaxRecipient) external onlyTaxManager {\n        if (newTaxRecipient == address(0) || taxRecipient == newTaxRecipient) {\n            revert InvalidParameters();\n        }\n        taxRecipient = newTaxRecipient;\n        emit TaxRecipientChanged(newTaxRecipient);\n    }\n\n    // *** presale interface ***\n\n    /**\n     * @notice Whitelist wallet addresses for ealry presale access.\n     * @param accounts accounts to whitelist\n     */\n    function whitelistForPresale(\n        address[] calldata accounts\n    ) external onlyOwner {\n        for (uint256 i = 0; i \u003c accounts.length; ++i) {\n            presaleWhitelist[accounts[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Open presale for whitelisted users.\n     * @dev Called after #whitelistForPresale.\n     */\n    function openPresale() external onlyOwner {\n        if (presaleState != PresaleState.CLOSED) {\n            revert InvalidState();\n        }\n        presaleState = PresaleState.OPEN_FOR_WHITELIST;\n        emit PresaleOpened();\n    }\n\n    /**\n     * @notice Open presale for all users.\n     * @dev Called after #openPresale.\n     */\n    function openPublicPresale() external onlyOwner {\n        if (presaleState != PresaleState.OPEN_FOR_WHITELIST) {\n            revert InvalidState();\n        }\n        presaleState = PresaleState.OPEN_FOR_PUBLIC;\n        emit PublicPresaleOpened();\n    }\n\n    /**\n     * @notice Complete the presale.\n     * @dev Adds 60% of collected ETH with 30% of totalSupply to Liquidity.\n     * Sends the remaining 40% of collected ETH to current owner.\n     * Called after #openPublicPresale.\n     */\n    function completePresale() external onlyOwner {\n        if (presaleState != PresaleState.OPEN_FOR_PUBLIC) {\n            revert InvalidState();\n        }\n        if (totalCommitments == 0) {\n            revert NoCommittments();\n        }\n\n        presaleState = PresaleState.COMPLETED;\n\n        uint256 amountEthForLiquidity = (totalCommitments * _SUPPLY_LIQUIDITY) /\n            _SUPPLY_PRESALE;\n        _addInitialLiquidityEth(\n            _SUPPLY_LIQUIDITY,\n            amountEthForLiquidity,\n            msg.sender\n        );\n\n        _sweepEth(msg.sender);\n\n        emit PresaleCompleted(totalCommitments);\n    }\n\n    /**\n     * @notice Enable trading.\n     * @param blocksDelay variable number of blocks to delay the actual start of trading, [1-5].\n     * @dev Exact start is delayed a variable amount of 1-5 blocks to make it harder for automated bots.\n     * Called after #completePresale.\n     */\n    function enableTrading(uint256 blocksDelay) external onlyOwner {\n        if (_tradeableAfterBlock != type(uint256).max) {\n            revert TradeAlreadyOpend();\n        }\n        if (blocksDelay == 0 || blocksDelay \u003e 5) {\n            revert InvalidBlockDelay();\n        }\n        if (presaleState != PresaleState.COMPLETED) {\n            revert PresaleNotCompleted();\n        }\n        _tradeableAfterBlock = block.number + blocksDelay;\n        emit TradingEnabled();\n\n        // renounce ownership\n        transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Claim callers presale tokens.\n     * @dev Callable once presaleCompleted.\n     */\n    function claimPresale() external {\n        address account = msg.sender;\n\n        if (_isContract(account)) {\n            revert NoContract();\n        }\n        if (presaleState != PresaleState.COMPLETED) {\n            revert PresaleNotCompleted();\n        }\n        if (commitment[account] == 0) {\n            revert NothingCommitted();\n        }\n        if (claimedTokens[account] != 0) {\n            revert AlreadyClaimed();\n        }\n\n        uint256 amountTokens = (_SUPPLY_PRESALE * commitment[account]) /\n            totalCommitments;\n        claimedTokens[account] = amountTokens;\n        totalClaimed += amountTokens;\n\n        _transferFromContractBalance(account, amountTokens);\n\n        emit PresaleClaimed(account, amountTokens);\n    }\n\n    /** @notice Returns amount of tokens to be claimed by presale participants. */\n    function unclaimedSupply() external view returns (uint256) {\n        return _SUPPLY_PRESALE - totalClaimed;\n    }\n\n    /**\n     * @notice Returns false if trading was not enabled yet.\n     * Trading can not be paused once enabled.\n     */\n    function isTradeOpen() external view returns (bool) {\n        return block.number \u003e _tradeableAfterBlock;\n    }\n\n    /**\n     * @notice Commit ETH to presale.\n     * Presale supply is claimable proportionally for all presale participants.\n     * Presale has a 132 ETH hardcap and 0.6 ETH per wallet limit.\n     * Users can also send ETH directly to **this** contract to participate.\n     * @dev Callable once presaleOpen.\n     */\n    function commitToPresale() public payable {\n        address account = msg.sender;\n        if (_isContract(account)) {\n            revert NoContract();\n        }\n        if (\n            presaleState == PresaleState.OPEN_FOR_WHITELIST \u0026\u0026\n            !presaleWhitelist[account]\n        ) {\n            revert NotWhitelistedForPresale();\n        }\n        if (\n            presaleState != PresaleState.OPEN_FOR_WHITELIST \u0026\u0026\n            presaleState != PresaleState.OPEN_FOR_PUBLIC\n        ) {\n            revert PresaleClosed();\n        }\n\n        commitment[account] += msg.value;\n        totalCommitments += msg.value;\n\n        if (totalCommitments \u003e PRESALE_HARDCAP) {\n            revert HardcapExceeded();\n        }\n        if (commitment[account] \u003e PRESALE_ACCOUNT_LIMIT) {\n            revert MaxAccountLimitExceeded();\n        }\n\n        emit CommitedToPresale(account, msg.value);\n    }\n\n    /**\n     * @notice Threshold of how many tokens to collect from tax before\n     * calling #swapTokensAndAddLiquidity.\n     * @dev Depends on swapThresholdEth which can be configured by taxManager.\n     * Restricted to 5% of liquidity.\n     */\n    function swapThresholdToken() public view returns (uint256) {\n        (uint reserveToken, uint reserveWeth) = _getReserve();\n        uint256 maxSwapEth = (reserveWeth * 5) / 100;\n        return\n            _getAmountToken(\n                swapThresholdEth \u003e maxSwapEth ? maxSwapEth : swapThresholdEth,\n                reserveToken,\n                reserveWeth\n            );\n    }\n\n    /**\n     * @notice Swap 3/4 of `amountToken` collected from tax to WETH to add to\n     * liquidity and send to taxRecipient.\n     */\n    function _swapTokensAndAddLiquidity(uint256 amountToken) internal {\n        if (\n            balanceOf[address(this)] + totalClaimed \u003c\n            amountToken + _SUPPLY_PRESALE\n        ) {\n            return;\n        }\n\n        uint256 amountToSell = (amountToken * 3) / 4;\n        uint256 amountToAddToLiquidity = amountToken - amountToSell;\n\n        _swapForWETH(amountToSell, address(this));\n\n        uint256 amountWethAddedToLiquidity = _addLiquidity(\n            amountToAddToLiquidity,\n            address(0xdead)\n        );\n        uint256 amountWethCollected = _sweepWeth(taxRecipient);\n\n        emit SwappedTokensAndAddedLiquidity(\n            amountToSell,\n            amountToAddToLiquidity,\n            amountWethAddedToLiquidity,\n            amountWethCollected\n        );\n    }\n\n    /**\n     * @dev Enforce a one buy/sell per block limit to prevent sandwitch attacks.\n     * These checks come with a gas cost tradeoff and can be configured via\n     * limitPerBlockTransfers.\n     * @param from sender\n     * @param to receiver\n     */\n    function _enforceTransferLimit(address from, address to) internal {\n        bool toPool = isExchangePool[to];\n        bool fromPool = isExchangePool[from];\n        if (fromPool \u0026\u0026 !toPool) {\n            bytes32 key = keccak256(abi.encodePacked(block.number, to));\n            if (_perBlock[key]) {\n                revert NoSameBlockBuySell();\n            }\n            _perBlock[key] = true;\n        } else if (!fromPool \u0026\u0026 toPool) {\n            bytes32 key = keccak256(abi.encodePacked(block.number, from));\n            if (_perBlock[key]) {\n                revert NoSameBlockBuySell();\n            }\n            _perBlock[key] = true;\n        }\n    }\n}\n"}}