{{
  "language": "Solidity",
  "sources": {
    "contracts/Boomcoin.sol": {
      "content": "/*\n    twitter: twitter.com/hankhillforreal\n    website: boomcoin.kingofthecryptohill.com\n*/\n\npragma solidity 0.8.19;\n\n// SPDX-License-Identifier: MIT\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20{\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n}\n\n\ncontract TokenHandler is Ownable {\n    function sendTokenToOwner(address token) external onlyOwner {\n        if(IERC20(token).balanceOf(address(this)) > 0){\n            SafeERC20.safeTransfer(IERC20(token),owner(), IERC20(token).balanceOf(address(this)));\n        }\n    }\n}\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\ninterface IWETH {\n    function deposit() external payable; \n}\n\ninterface ILpPair {\n    function sync() external;\n}\n\ninterface IDexRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IDexFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ncontract Boomcoin is ERC20, Ownable {\n\n    mapping (address => bool) public exemptFromFees;\n    mapping (address => bool) public exemptFromLimits;\n\n    bool public tradingActive;\n\n    mapping (address => bool) public isAMMPair;\n\n    uint256 public maxTransaction;\n    uint256 public maxWallet;\n\n    address public operationsAddress;\n    address public devAddress;\n    address public reservesAddress;\n    address public influencerAddress;\n\n    uint256 public buyTotalTax;\n    uint256 public buyOperationsTax;\n    uint256 public buyLiquidityTax;\n    uint256 public buyInfluencerTax;\n    uint256 public buyDevTax;\n\n    uint256 public sellTotalTax;\n    uint256 public sellOperationsTax;\n    uint256 public sellLiquidityTax;\n    uint256 public sellDevTax;\n\n    uint256 public tokensForOperations;\n    uint256 public tokensForLiquidity;\n    uint256 public tokensForDev;\n    uint256 public tokensForInfluencer;\n\n    mapping(address => uint256) private _holderLastTransferBlock; // to hold last Transfers temporarily during launch\n    bool public transferDelayEnabled = true;\n\n    bool public limitsInEffect = true;\n\n    bool private swapping;\n    uint256 public swapTokensAtAmt;\n\n    address public lpPair;\n    IDexRouter public dexRouter;\n    IERC20Metadata public eth;\n    IWETH public WETH;\n\n    uint256 public constant FEE_DIVISOR = 10000;\n\n    // events\n\n    event UpdatedMaxTransaction(uint256 newMax);\n    event UpdatedMaxWallet(uint256 newMax);\n    event SetExemptFromFees(address _address, bool _isExempt);\n    event SetExemptFromLimits(address _address, bool _isExempt);\n    event RemovedLimits();\n    event UpdatedBuyTax(uint256 newAmt);\n    event UpdatedSellTax(uint256 newAmt);\n\n    // constructor\n\n    constructor(string memory _name, string memory _symbol)\n        ERC20(_name, _symbol)\n    {   \n        _mint(msg.sender, 1_000_000_000 * 1e18);\n        uint256 _totalSupply = totalSupply();\n\n        address _v2Router;\n\n        // @dev assumes WETH pair\n        if(block.chainid == 1){\n            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n        } else if(block.chainid == 5){\n            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n        } else if(block.chainid == 97){\n            _v2Router = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\n        } else if(block.chainid == 42161){\n            _v2Router = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n        } else {\n            revert(\"Chain not configured\");\n        }\n\n        dexRouter = IDexRouter(_v2Router);\n\n        maxTransaction = _totalSupply * 1 / 1000;\n        maxWallet = _totalSupply * 2/ 100;\n        swapTokensAtAmt = _totalSupply * 25 / 100000;\n\n        operationsAddress = 0xa56d8E550db019E34Fc16b5B8317150F97033dC0;\n        devAddress = 0xC8704FE12f98035ce7F55a93D51153F5318E0854;\n        reservesAddress = 0x9673C4b6Ad428a651B583FC57c4f5Ae58cf73a33;\n        influencerAddress = 0xC8704FE12f98035ce7F55a93D51153F5318E0854;\n\n        buyOperationsTax = 150;\n        buyLiquidityTax = 100;\n        buyDevTax = 100;\n        buyInfluencerTax = 100;\n        buyTotalTax = buyOperationsTax + buyLiquidityTax + buyDevTax + buyInfluencerTax;\n\n        sellOperationsTax = 200;\n        sellLiquidityTax = 0;\n        sellDevTax = 250;\n        sellTotalTax = sellOperationsTax + sellLiquidityTax + sellDevTax;\n\n        lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), dexRouter.WETH());\n\n        WETH = IWETH(dexRouter.WETH());\n        isAMMPair[lpPair] = true;\n\n        exemptFromLimits[lpPair] = true;\n        exemptFromLimits[msg.sender] = true;\n        exemptFromLimits[address(this)] = true;\n        exemptFromLimits[devAddress] = true;\n        exemptFromLimits[address(dexRouter)] = true;\n\n        exemptFromFees[msg.sender] = true;\n        exemptFromFees[address(this)] = true;\n        exemptFromFees[devAddress] = true;\n        exemptFromFees[address(dexRouter)] = true;\n \n        _approve(address(msg.sender), address(dexRouter), _totalSupply);\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        super._transfer(msg.sender, reservesAddress, _totalSupply * 10 / 100);\n    }\n\n    receive() external payable {}\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        \n        checkLimits(from, to, amount);\n\n        if(!exemptFromFees[from] && !exemptFromFees[to]){\n            amount -= handleTax(from, to, amount);\n        }\n\n        super._transfer(from,to,amount);\n    }\n\n    function checkLimits(address from, address to, uint256 amount) internal {\n\n        if(!exemptFromFees[from] && !exemptFromFees[to]){\n            require(tradingActive, \"Trading not active\");\n        }\n\n        if(limitsInEffect){\n            if (transferDelayEnabled){\n                if (to != address(dexRouter) && !isAMMPair[to]){\n                    require(_holderLastTransferBlock[tx.origin] < block.number && _holderLastTransferBlock[to] < block.number, \"Transfer Delay enabled.\");\n                    _holderLastTransferBlock[tx.origin] = block.number;\n                    _holderLastTransferBlock[to] = block.number;\n                }\n            }\n\n            // buy\n            if (isAMMPair[from] && !exemptFromLimits[to]) {\n                require(amount <= maxTransaction, \"Buy transfer amount exceeded.\");\n                require(amount + balanceOf(to) <= maxWallet, \"Unable to exceed Max Wallet\");\n            } \n            // sell\n            else if (isAMMPair[to] && !exemptFromLimits[from]) {\n                require(amount <= maxTransaction, \"Sell transfer amount exceeded.\");\n            }\n            else if(!exemptFromLimits[to]) {\n                require(amount + balanceOf(to) <= maxWallet, \"Unable to exceed Max Wallet\");\n            }\n        }\n    }\n\n    function handleTax(address from, address to, uint256 amount) internal returns (uint256){\n        if(balanceOf(address(this)) >= swapTokensAtAmt && !swapping && isAMMPair[to]) {\n            swapping = true;\n            swapBack();\n            swapping = false;\n        }\n        \n        uint256 tax = 0;\n\n        // on sell\n        if (isAMMPair[to] && sellTotalTax > 0){\n            tax = amount * sellTotalTax / FEE_DIVISOR;\n            tokensForLiquidity += tax * sellLiquidityTax / sellTotalTax;\n            tokensForOperations += tax * sellOperationsTax / sellTotalTax;\n            tokensForDev += tax * sellDevTax / sellTotalTax;\n        }\n\n        // on buy\n        else if(isAMMPair[from] && buyTotalTax > 0) {\n            tax = amount * buyTotalTax / FEE_DIVISOR;\n            tokensForOperations += tax * buyOperationsTax / buyTotalTax;\n            tokensForLiquidity += tax * buyLiquidityTax / buyTotalTax;\n            tokensForDev += tax * buyDevTax / buyTotalTax;\n            tokensForInfluencer += tax * buyInfluencerTax / buyTotalTax;\n        }\n        \n        if(tax > 0){    \n            super._transfer(from, address(this), tax);\n        }\n        \n        return tax;\n    }\n\n    function swapTokensForETH(uint256 tokenAmt) private {\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = dexRouter.WETH();\n\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmt,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapBack() private {\n\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForOperations + tokensForDev + tokensForInfluencer;\n        \n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\n\n        if(contractBalance > swapTokensAtAmt * 40){\n            contractBalance = swapTokensAtAmt * 40;\n        }\n        \n        if(tokensForLiquidity > 0){\n            uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap;\n            super._transfer(address(this), lpPair, liquidityTokens);\n            try ILpPair(lpPair).sync(){} catch {}\n            contractBalance -= liquidityTokens;\n            totalTokensToSwap -= tokensForLiquidity;\n            tokensForLiquidity = 0;\n        }\n        \n        if(totalTokensToSwap > 0 && contractBalance > 0){\n            swapTokensForETH(contractBalance);\n            \n            uint256 ethBalance = address(this).balance;\n\n            uint256 ethForDev = ethBalance * tokensForDev / totalTokensToSwap;\n\n            uint256 ethForInfluencer = ethBalance * tokensForInfluencer / totalTokensToSwap;\n\n            bool success;\n            if(ethForDev > 0){\n                (success, ) = devAddress.call{value: ethForDev}(\"\");\n                tokensForDev = 0;\n            }\n\n            if(ethForInfluencer > 0){\n                (success, ) = influencerAddress.call{value: ethForInfluencer}(\"\");\n                tokensForInfluencer = 0;\n            }\n\n            if(address(this).balance > 0){\n                (success, ) = operationsAddress.call{value: address(this).balance}(\"\");\n                tokensForOperations = 0;\n            }\n        }\n    }\n\n    // owner functions\n\n    function increaseMaxTxnSetAmount() external onlyOwner {\n        maxTransaction = totalSupply() * 5 / 1000;\n    }\n\n    function increaseMaxTxnToMaxWallet() external onlyOwner {\n        maxTransaction = maxWallet;\n    }\n\n    function setExemptFromFees(address _address, bool _isExempt) external onlyOwner {\n        require(_address != address(0), \"Zero Address\");\n        exemptFromFees[_address] = _isExempt;\n        emit SetExemptFromFees(_address, _isExempt);\n    }\n\n    function setExemptFromLimits(address _address, bool _isExempt) external onlyOwner {\n        require(_address != address(0), \"Zero Address\");\n        if(!_isExempt){\n            require(_address != lpPair, \"Cannot remove pair\");\n        }\n        exemptFromLimits[_address] = _isExempt;\n        emit SetExemptFromLimits(_address, _isExempt);\n    }\n\n    function updateMaxTransaction(uint256 newNumInTokens) external onlyOwner {\n        require(newNumInTokens >= (totalSupply() * 5 / 1000)/(10**decimals()), \"Too low\");\n        maxTransaction = newNumInTokens * (10**decimals());\n        emit UpdatedMaxTransaction(maxTransaction);\n    }\n\n    function updateMaxWallet(uint256 newNumInTokens) external onlyOwner {\n        require(newNumInTokens >= (totalSupply() * 1 / 100)/(10**decimals()), \"Too low\");\n        maxWallet = newNumInTokens * (10**decimals());\n        emit UpdatedMaxWallet(maxWallet);\n    }\n\n    function updateBuyTax(uint256 _operationsTax, uint256 _liquidityTax, uint256 _devTax, uint _influencerTax) external onlyOwner {\n        buyOperationsTax = _operationsTax;\n        buyLiquidityTax = _liquidityTax;\n        buyDevTax = _devTax;\n        buyInfluencerTax = _influencerTax;\n        buyTotalTax = buyOperationsTax + buyLiquidityTax + buyDevTax + buyInfluencerTax;\n        require(buyTotalTax <= 499, \"Keep tax below 5%\");\n        emit UpdatedBuyTax(buyTotalTax);\n    }\n\n    function updateSellTax(uint256 _operationsTax, uint256 _liquidityTax, uint256 _devTax) external onlyOwner {\n        sellOperationsTax = _operationsTax;\n        sellLiquidityTax = _liquidityTax;\n        sellDevTax = _devTax;\n        sellTotalTax = sellOperationsTax + sellLiquidityTax + sellDevTax;\n        require(sellTotalTax <= 499, \"Keep tax below 5%\");\n        emit UpdatedSellTax(sellTotalTax);\n    }\n\n    function enableTrading() external onlyOwner {\n        tradingActive = true;\n    }\n\n    function removeLimits() external onlyOwner {\n        limitsInEffect = false;\n        transferDelayEnabled = false;\n        maxTransaction = totalSupply();\n        maxWallet = totalSupply();\n        emit RemovedLimits();\n    }\n\n    function disableTransferDelay() external onlyOwner {\n        transferDelayEnabled = false;\n    }\n\n    function rescueEth(address toAddress) external onlyOwner {\n        require(address(this).balance > 0, \"Contract has zero ETH\");\n        (bool sent, bytes memory data) = toAddress.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether.\");\n    }\n\n    function rescueTokens(address _token, address _to) external onlyOwner {\n        require(_token != address(0), \"_token address cannot be 0\");\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\n        SafeERC20.safeTransfer(IERC20(_token),_to, _contractBalance);\n    }\n\n    function updateOperationsAddress(address _address) external onlyOwner {\n        require(_address != address(0), \"zero address\");\n        operationsAddress = _address;\n    }\n\n    function updateDevAddress(address _address) external onlyOwner {\n        require(_address != address(0), \"zero address\");\n        devAddress = _address;\n    }\n\n    function updateInfluencerAddress(address _address) external onlyOwner {\n        require(_address != address(0), \"zero address\");\n        influencerAddress = _address;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}