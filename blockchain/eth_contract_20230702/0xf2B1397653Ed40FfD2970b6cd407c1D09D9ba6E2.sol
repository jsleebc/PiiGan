{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/Uniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n}\n"
    },
    "contracts/YiLongMa.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * Website: https://yilongma-erc.com\n * Telegram: https://t.me/yilongmaercportal\n * Twitter: https://twitter.com/YiLongMaERC\n */\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\n\nimport {IUniswapV2Factory, IUniswapV2Router} from \"./interfaces/Uniswap.sol\";\n\ncontract YiLongMa is Owned, ERC20 {\n    uint8 internal _decimals = 9;\n    uint256 internal _totalSupply = 1000000 * 10 ** _decimals;\n\n    uint256 public _maxTxAmount = (_totalSupply * 2) / 100;\n    uint256 public _maxWalletAmount = _maxTxAmount;\n    uint256 public _buyTax = 30;\n    uint256 public _sellTax = 30;\n\n    uint256 internal swapThreshold = _maxWalletAmount;\n    IUniswapV2Router internal uniswapV2Router;\n    address internal WETH;\n    address internal uniswapV2Pair;\n    address internal marketingWallet;\n    mapping(address => bool) internal excludedFromLimits;\n    uint256 internal launchedBlock;\n    bool internal tradingEnabled;\n    bool internal internalSwap;\n\n    modifier lockInternalSwap() {\n        internalSwap = true;\n        _;\n        internalSwap = false;\n    }\n\n    constructor() Owned(msg.sender) ERC20(unicode\"YiLongMa\", unicode\"一龙马\", _decimals) {\n        super._mint(address(this), _totalSupply);\n        uniswapV2Router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        marketingWallet = msg.sender;\n        excludedFromLimits[msg.sender] = true;\n        excludedFromLimits[address(this)] = true;\n    }\n\n    function removeLimits() external onlyOwner {\n        uint256 maxAmount = _totalSupply;\n        _maxTxAmount = maxAmount;\n        _maxWalletAmount = maxAmount;\n    }\n\n    function removeTaxes() external onlyOwner {\n        _buyTax = 0;\n        _sellTax = 0;\n    }\n\n    function enableTrading(uint256 db) external payable onlyOwner {\n        require(!tradingEnabled, \"Trading Already Enabled\");\n        WETH = uniswapV2Router.WETH();\n        IUniswapV2Factory uniswapV2Factory = IUniswapV2Factory(uniswapV2Router.factory());\n        address currentPair = uniswapV2Factory.getPair(address(this), WETH);\n        if (currentPair == address(0)) currentPair = uniswapV2Factory.createPair(address(this), WETH);\n        uniswapV2Pair = currentPair;\n        uint256 initialDb = _buyTax;\n        _buyTax = db;\n        allowance[address(this)][address(uniswapV2Router)] = type(uint256).max;\n        uniswapV2Router.addLiquidityETH{value: msg.value}(address(this), balanceOf[address(this)], 0, 0, owner, block.timestamp);\n        launchedBlock = block.number;\n        tradingEnabled = true;\n        _buyTax = initialDb;\n    }\n\n    function renounceOwnership() external onlyOwner {\n        uint256 maxAmount = _totalSupply;\n        require(_maxTxAmount == maxAmount && _maxWalletAmount == maxAmount, \"Limits Not Yet Removed\");\n        require(_buyTax == 0 && _sellTax == 0, \"Taxes Not Yet Removed\");\n        require(tradingEnabled, \"Trading Not Yet Enabled\");\n        Owned.transferOwnership(address(0));\n    }\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        return _tokenTransfer(msg.sender, to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        return _tokenTransfer(from, to, amount);\n    }\n\n    function _tokenTransfer(address from, address to, uint256 amount) internal returns (bool) {\n        if (!excludedFromLimits[from]) require(tradingEnabled, \"Trading Not Yet Enabled\");\n        require(from != address(0) && to != address(0), \"Transfer From/To Zero Address\");\n        require(amount > 0, \"Transfer Amount Zero\");\n\n        uint256 taxAmount = 0;\n        if (from != owner && to != owner) {\n            taxAmount = !internalSwap ? (amount * (block.number <= launchedBlock ? 99 : _buyTax)) / 100 : 0;\n            if (from == uniswapV2Pair && !excludedFromLimits[to]) {\n                require(amount <= _maxTxAmount, \"Exceeds Max TX\");\n                require(balanceOf[to] + amount <= _maxWalletAmount, \"Exceeds Max Wallet\");\n            } else if (to == uniswapV2Pair && from != address(this)) {\n                taxAmount = (amount * _sellTax) / 100;\n                if (!internalSwap) _internalSwap(amount);\n            }\n        }\n\n        balanceOf[from] -= amount;\n\n        if (taxAmount > 0) {\n            balanceOf[address(this)] += taxAmount;\n            emit Transfer(from, address(this), taxAmount);\n        }\n\n        uint256 finalAmount = amount - taxAmount;\n        balanceOf[to] += finalAmount;\n        emit Transfer(from, to, finalAmount);\n\n        return true;\n    }\n\n    function _internalSwap(uint256 amount) internal lockInternalSwap {\n        uint256 swapAmount = _min(amount, _min(balanceOf[address(this)], swapThreshold));\n        if (swapAmount > 0) {\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = WETH;\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(swapAmount, 0, path, marketingWallet, block.timestamp);\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = (a > b) ? b : a;\n    }\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "remappings": [],
    "libraries": {}
  }
}}