{{
  "language": "Solidity",
  "sources": {
    "contracts/MemeLisa.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.17;\r\n\r\nimport {ERC20} from \"./libraries/solmate/ERC20.sol\";\r\nimport {Owned} from \"./libraries/solmate/Owned.sol\";\r\n\r\nimport {IsContract} from \"./libraries/isContract.sol\";\r\n\r\nimport \"./interfaces/univ2.sol\";\r\n\r\nerror NotStartedYet();\r\nerror Blocked();\r\n\r\ncontract MEMELIToken is ERC20(\"MEMELISA Token\", \"MEMELI\", 18), Owned(msg.sender) {\r\n    using IsContract for address;\r\n\r\n    mapping(address => bool) public whitelisted;\r\n    mapping(address => bool) public blocked;\r\n\r\n    IUniswapV2Pair public pair;\r\n    IUniswapV2Router02 public router;\r\n    uint256 public startedIn = 0;\r\n    uint256 public startedAt = 0;\r\n\r\n    address public treasury;\r\n\r\n    uint256 public feeCollected = 0;\r\n    uint256 public feeSwapBps = 100; // 1.00% liquidity increase\r\n    uint256 public feeSwapTrigger = 10e18;\r\n\r\n    uint256 maxBps = 10000; // 10000 is 100.00%\r\n\r\n    // 0-1 blocks:\r\n    uint256 public zeroBlockBuyBPS = 9000; // 90.00%\r\n    uint256 public zeroBlockSellBPS = 9000; // 90.00%\r\n    // first 30min:\r\n    uint256 public initialBuyBPS = 1000; // 10.00%\r\n    uint256 public initialSellBPS = 3000; // 30.00%\r\n    // 7 days:\r\n    uint256 public weekBuyBPS = 500; // 5.00%\r\n    uint256 public weekSellBPS = 2000; // 20.00%\r\n    // after\r\n    uint256 public buyBPS = 500; // 5.00%\r\n    uint256 public sellBPS = 500; // 5.00%\r\n\r\n    constructor() {\r\n        treasury = address(0x3b6869106b4F747fB36bB94f7089165AdD128365);\r\n        uint256 expectedTotalSupply = 811_000_000_000 ether;\r\n        whitelisted[treasury] = true;\r\n        whitelisted[address(this)] = true;\r\n        _mint(treasury, expectedTotalSupply);\r\n    }\r\n\r\n    // getters\r\n    function isLiqudityPool(address account) public view returns (bool) {\r\n        if (!account.isContract()) return false;\r\n        (bool success0, bytes memory result0) = account.staticcall(\r\n            abi.encodeWithSignature(\"token0()\")\r\n        );\r\n        if (!success0) return false;\r\n        (bool success1, bytes memory result1) = account.staticcall(\r\n            abi.encodeWithSignature(\"token1()\")\r\n        );\r\n        if (!success1) return false;\r\n        address token0 = abi.decode(result0, (address));\r\n        address token1 = abi.decode(result1, (address));\r\n        if (token0 == address(this) || token1 == address(this)) return true;\r\n        return false;\r\n    }\r\n\r\n    // public functions\r\n\r\n    function burn(uint256 amount) public {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    // transfer functions\r\n    function _onTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        if (blocked[to] || blocked[from]) {\r\n            revert Blocked();\r\n        }\r\n        if(whitelisted[from] || whitelisted[to]) {\r\n            return amount;\r\n        }\r\n\r\n        if (startedIn == 0) {\r\n            revert NotStartedYet();\r\n        }\r\n\r\n        if (isLiqudityPool(to) || isLiqudityPool(from)) {\r\n            return _transferFee(from, to, amount);\r\n        }\r\n\r\n        if (feeCollected > feeSwapTrigger) {\r\n            _swapFee();\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    function _swapFee() internal {\r\n        uint256 feeAmount = feeCollected;\r\n        feeCollected = 0;\r\n        if(address(pair) == address(0)) return;\r\n\r\n\r\n        (address token0, address token1) = (pair.token0(), pair.token1());\r\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\r\n\r\n        if (token1 == address(this)) {\r\n            (token0, token1) = (token1, token0);\r\n            (reserve0, reserve1) = (reserve1, reserve0);\r\n        }\r\n\r\n        uint256 maxFee = reserve0 * feeSwapBps / maxBps;\r\n        if (maxFee < feeAmount) {\r\n            feeCollected = feeAmount - maxFee;\r\n            feeAmount = maxFee;\r\n        }\r\n\r\n        if(feeAmount == 0) return;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = token0;\r\n        path[1] = token1;\r\n\r\n        this.approve(address(router), feeAmount);\r\n        router.swapExactTokensForTokens(\r\n            feeAmount,\r\n            0,\r\n            path,\r\n            treasury,\r\n            block.timestamp + 1000\r\n        );\r\n    }\r\n\r\n    function _transferFee(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        uint256 taxBps = 0;\r\n\r\n        if (isLiqudityPool(from)) {\r\n            if (block.number <= startedIn + 1) {\r\n                taxBps = zeroBlockBuyBPS;\r\n            } else if (block.timestamp <= startedAt + 30 minutes) {\r\n                taxBps = initialBuyBPS;\r\n            } else if (block.timestamp <= startedAt + 7 days) {\r\n                taxBps = weekBuyBPS;\r\n            } else {\r\n                taxBps = buyBPS;\r\n            }\r\n        } else if (isLiqudityPool(to)) {\r\n            if (block.number <= startedIn + 1) {\r\n                taxBps = zeroBlockSellBPS;\r\n            } else if (block.timestamp <= startedAt + 30 minutes) {\r\n                taxBps = initialSellBPS;\r\n            } else if (block.timestamp <= startedAt + 7 days) {\r\n                taxBps = weekSellBPS;\r\n            } else {\r\n                taxBps = sellBPS;\r\n            }\r\n        }\r\n\r\n        uint256 feeAmount = (amount * taxBps) / maxBps;\r\n        if (feeAmount == 0) return amount;\r\n\r\n        feeCollected += feeAmount;\r\n        amount -= feeAmount;\r\n\r\n        _transfer(from, address(this), feeAmount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        if (from != address(this) && to != address(this)) {\r\n            amount = _onTransfer(from, to, amount);\r\n        }\r\n\r\n        return super.transferFrom(from, to, amount);\r\n    }\r\n\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (msg.sender != address(this) && to != address(this)) {\r\n            amount = _onTransfer(msg.sender, to, amount);\r\n        }\r\n        return super.transfer(to, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        balanceOf[from] -= amount;\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // Only owner functions\r\n    function start() public onlyOwner {\r\n        require(startedIn == 0, \"MEMELI: already started\");\r\n        startedIn = block.number;\r\n        startedAt = block.timestamp;\r\n    }\r\n\r\n    function setUni(address _router, address _pair) public onlyOwner {\r\n        router = IUniswapV2Router02(_router);\r\n        pair = IUniswapV2Pair(_pair);\r\n        (address token0, address token1) = (pair.token0(), pair.token1());\r\n        require(token0 == address(this) || token1 == address(this), \"MEMELI: wrong pair\");\r\n        require(pair.factory() == router.factory(), \"MEMELI: wrong pair\");\r\n    }\r\n\r\n    function setFeeSwapConfig(uint256 _feeSwapTrigger, uint256 _feeSwapBps) public onlyOwner {\r\n        feeSwapTrigger = _feeSwapTrigger;\r\n        feeSwapBps = _feeSwapBps;\r\n    }\r\n\r\n    function setBps(uint256 _buyBPS, uint256 _sellBPS) public onlyOwner {\r\n        require(_buyBPS <= 500, \"MEMELI: wrong buyBPS\");\r\n        require(_sellBPS <= 500, \"MEMELI: wrong sellBPS\");\r\n        buyBPS = _buyBPS;\r\n        sellBPS = _sellBPS;\r\n    }\r\n\r\n    function setTreasury(address _treasury) public onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    function whitelist(address account, bool _whitelisted) public onlyOwner {\r\n        whitelisted[account] = _whitelisted;\r\n    }\r\n\r\n    function blocklist(address account, bool _blocked) public onlyOwner {\r\n        require(startedAt > 0, \"MEMELI: too early\");\r\n        require(startedAt + 7 days > block.timestamp, \"MEMELI: too late\");\r\n        blocked[account] = _blocked;\r\n    }\r\n}"
    },
    "contracts/interfaces/univ2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >0.5.16;\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "contracts/libraries/isContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Taken from Address.sol from OpenZeppelin.\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary IsContract {\r\n  /// @dev Returns true if `account` is a contract.\r\n  function isContract(address account) internal view returns (bool) {\r\n      // This method relies on extcodesize, which returns 0 for contracts in\r\n      // construction, since the code is only stored at the end of the\r\n      // constructor execution.\r\n\r\n      uint256 size;\r\n      assembly { size := extcodesize(account) }\r\n      return size > 0;\r\n  }\r\n}"
    },
    "contracts/libraries/solmate/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\r\nabstract contract Owned {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            OWNERSHIP STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             OWNERSHIP LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        owner = newOwner;\r\n\r\n        emit OwnershipTransferred(msg.sender, newOwner);\r\n    }\r\n}"
    },
    "contracts/libraries/solmate/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}